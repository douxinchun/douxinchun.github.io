<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-10-12T21:00:57+08:00</updated><id>/feed.xml</id><title type="html">Spring Notes</title><subtitle>Dying is the day worth living for</subtitle><entry><title type="html">Swift 中的协变与逆变</title><link href="/swift/2023/09/27/covariance-and-contravariance.html" rel="alternate" type="text/html" title="Swift 中的协变与逆变" /><published>2023-09-27T22:47:33+08:00</published><updated>2023-09-27T22:47:33+08:00</updated><id>/swift/2023/09/27/covariance-and-contravariance</id><content type="html" xml:base="/swift/2023/09/27/covariance-and-contravariance.html">&lt;p&gt;&lt;strong&gt;协变 - Covaiance&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;逆变 - Contravariance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们在使用泛型的时候经常会遇到这两个关键字.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__covariant&lt;/code&gt;: 用于泛型数据强转类型，可以向上强转，子类可以转成父类。
  这个比较好理解, 了解过面向对象编程的五个基本原则 SOLID 中的 L(里氏替换) 原则的话, 就不难理解子类可以在任何父类出现的地方替换父类.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__contravariant&lt;/code&gt;: 用于泛型数据强转类型，可以向下强转，父类可以转成子类. 这个就比较难理解了.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;抛开 Swift, 我们先从计算机科学层面来看一下什么是 Variance(变型, 这个是维基百科的翻译, 个人觉得不好理解, 但是我也想不出更好的翻译了, 后续就直接使用英文原词).&lt;/p&gt;

&lt;p&gt;首先, 许多编程语言是支持子类型 (subtyping) 系统的, 比如说, 类型 Cat 是 Animal 的子类型, 那么任何使用 Anmial 类型的地方都可以使用 Cat 类型来替换.&lt;/p&gt;

&lt;p&gt;Variance 就是用来描述如何根据组成复杂类型的简单类型之间的子类型关系, 来确定复杂类型之间的子类型关系的. 比如: Cat 数组和 Animal 数组之间是什么样的子类型关系? 或者, 返回 Cat 的函数和返回 Animal 的函数之间是什么样的子类型关系?&lt;/p&gt;

&lt;p&gt;根据类型构造器(type constructor) 的 Variance 不同, 复杂类型可能会保留, 反转或者忽略原来的简单类型之间的子类型关系. 举例说明, Cat 数组是 Animal 数组的子类型, 是因为数组类型构造器是协变的(Covariant). Covariant 意味着复杂类型&lt;strong&gt;保留&lt;/strong&gt;了简单类型之间的子类型关系.&lt;/p&gt;

&lt;p&gt;另一个例子, 函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal -&amp;gt; String&lt;/code&gt;(接收 Animal, 返回 String)是函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cat -&amp;gt; String&lt;/code&gt; 的子类型, 是因为函数类型构造器在参数类型上是逆变的(Contravariant). Contravariant 意味着复杂类型&lt;strong&gt;反转&lt;/strong&gt;了简单类型之间的子类型关系.&lt;/p&gt;

&lt;p&gt;编程语言的设计者在指定数组, 继承, 泛型等类型规则的时候, 必须要考虑到 Variance. 将类型构造器设计成是协变(covariant)、逆变(contravariant)而不是不变的(invariant)，可以让更多的程序具备良好的类型。&lt;/p&gt;

&lt;p&gt;对于编程者来说, 经常会感到 contravariance 是反直觉的. 为了保持类型系统简单和利于编程, 一个编程语言可能把类型构造器视为不变的，即使它被视为可变也是安全的；或是把类型构造器视为协变的，即使这样可能会违反类型安全.&lt;/p&gt;

&lt;h1 id=&quot;varinance-的正式定义&quot;&gt;Varinance 的正式定义&lt;/h1&gt;
&lt;p&gt;假定 A 和 B 是两个简单类型, T&amp;lt;U&amp;gt;表示一个类型构造器 I 应用于类型参数 U. 在编程语言的类型系统中, 一个类型构造器 T 的类型规则是:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;协变 (Covariant)&lt;/strong&gt;, 保留简单类型的关系. 如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A ≤ B&lt;/code&gt;, 那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;lt;A&amp;gt; ≤ T&amp;lt;B&amp;gt;&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;逆变 (Contravariant)&lt;/strong&gt;, 反转简单类型的关系. 如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A ≤ B&lt;/code&gt;, 那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;lt;B&amp;gt; ≤ T&amp;lt;A&amp;gt;&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;双变 (Bivariant&lt;/strong&gt;), 既协变又逆变. 如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A ≤ B&lt;/code&gt;, 那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;lt;A&amp;gt; ≡ T&amp;lt;B&amp;gt;&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Variant&lt;/strong&gt;, 如果存在上述但中变化中的任一种(Convatiant, Contravariant or Bivarant), 那么就是 Variant;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不变 (Invariant or Nonvariant)&lt;/strong&gt;, !Variant&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;swift-中的-convariance-和-contravariance&quot;&gt;Swift 中的 Convariance 和 Contravariance&lt;/h1&gt;
&lt;p&gt;下面的这段代码是会报错的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;var intHandler: (Int) -&amp;gt; Void = { (num) in 
    print(num)
}
let anyHandler: (Any) -&amp;gt; Void = intHandler **___ ERROR\!**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是反过来就不会报错&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let anyHandler: (Any) -&amp;gt; Void = { (any) in
    print(any)
}
let intHandler: (Int) -&amp;gt; Void = anyHandler ___ OK.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后, 如果是这样将 Closure 用作另一个 Closure 的参数, 再赋值, 也不会报错&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let intResolverLater: ((Int) -&amp;gt; Void) -&amp;gt; Void = { f in
    f(0)
}

var anyResolverLater: ((Any) -&amp;gt; Void) -&amp;gt; Void = intResolver ___ OK.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结合上面的 Covariant 和 Contravariant的介绍, 如果你清楚上面的代码报错和不报错的原因, 那就不需要再往下看了. 但是如果你好奇的话, 可以继续阅读.&lt;/p&gt;

&lt;p&gt;我们知道子类和用在任何父类出现的地方.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;class Animal { ... }
class Cat: Animal { ... }
let animal: Animal = Cat()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种行为叫做子类型化, Cat 是 Animal 的子类, Animal 是 Cat 的父类.&lt;/p&gt;

&lt;p&gt;简单类型的子父类关系很好判断, 现在我们想一下复杂类型的子父类关系.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Array —  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[Cat]&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[Animal]&lt;/code&gt; 的子类型不?&lt;/li&gt;
  &lt;li&gt;Generic — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PetOwner&amp;lt;Cat&amp;gt;&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PetOwner&amp;lt;Animal&amp;gt;&lt;/code&gt; 的子类型不?&lt;/li&gt;
  &lt;li&gt;Closure — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(Cat) -&amp;gt; Void&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(Animal) -&amp;gt; Void&lt;/code&gt; 的子类型不?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;答案: 第一个是, 第二个不是(这个后续在解释), 第三个不是.&lt;/p&gt;

&lt;p&gt;实际上, 第三个恰恰相反, &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(Animal) -&amp;gt; Void&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(Cat) -&amp;gt; Void&lt;/code&gt; 的子类型!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这不是语言的黑魔法, 只是语言在设计时处理它们的一个合理的选择, 我们之需要记住这种选择就可以. 这种选择就是 协变(covariance)和逆变(contravariance).&lt;/p&gt;

&lt;h1 id=&quot;什么是协变-covariance&quot;&gt;什么是协变 Covariance&lt;/h1&gt;
&lt;p&gt;仔细分析一下为什么&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[Cat]&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[Animal]&lt;/code&gt;的子类型.&lt;br /&gt;
我们使用箭头指向表示 Cat 是 Animal 的子类型:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;Cat → Animal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;认真思考一下, [Animal] 中的元素既可以是 Animal, 也可以是 Cat. 所以, 语言的设计者就可以决定将 [Cat] 视为 [Animal] 的子类型. 用箭头表示子类型关系就是:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Cat] → [Animal]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[Cat] 和 [Animal] 之间的子类型关系的方向是和组成它们的简单类型 Cat 以及 Animal 之间的子类型关系的方向相同的. 这种使用和简单类型(或者叫原始类型)类型关系相同的决定叫做协变(covariance).&lt;/p&gt;

&lt;p&gt;协变(covariance)的另一个例子是闭包的返回类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let intBuilder: () -&amp;gt; Int = {
    return 5
}
let anyBuilder: () -&amp;gt; Any = intBuilder ___ OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; 的子类型, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;() -&amp;gt; Int&lt;/code&gt; 同样是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;() -&amp;gt; Any&lt;/code&gt; 的子类型. 所以, 闭包的返回类型在 Swift 中是协变的(covariant).&lt;/p&gt;

&lt;h1 id=&quot;什么是逆变-contravariance-contra-是指相反的意思-这里可以理解成相反的变化&quot;&gt;什么是逆变 “Contra”variance( contra 是指相反的意思, 这里可以理解成相反的变化)&lt;/h1&gt;
&lt;p&gt;逆变(Contravariance) 就是将原始类型的子类型关系反转的一种决定.&lt;/p&gt;

&lt;p&gt;我们通过&lt;strong&gt;闭包的参数&lt;/strong&gt;来分析一下,为什么这种子类型关系的反转是合理的. 假定下面的代码可以正常运行:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let intHandler: (Int) -&amp;gt; Void = { num in
    print(num)
}
let anyHandler: (Any) -&amp;gt; Void = intHandler ___ COMPILE ERROR!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想像一下, 当执行这条语句时, 会发生什么?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;anyHandler(&quot;Some String&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intHandler&lt;/code&gt; 会接收到一个意料之外的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stirng&lt;/code&gt; 类选的参数. 当然也可能是任何除了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;类型以外的参数. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intHandler&lt;/code&gt;不知道如何处理非&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;类型以外的参数. 所以, 这段代码在编译时就会报错.&lt;/p&gt;

&lt;p&gt;现在, 我们再想想反过来会如何:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let anyHandler: (Any) -&amp;gt; Void = { (any) in
    print(any)
}
let intHandler: (Int) -&amp;gt; Void = anyHandler ___ OK.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样看起来就合理了. 因为我们只能给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intHandler&lt;/code&gt;提供一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;类型的参数, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;anyHandler&lt;/code&gt;可以处理任意类型的参数,包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;类型.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;intHandler(1001)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;anyHandler&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intHandler&lt;/code&gt; 的子类型. 这就意味着, 任何出现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;anyHandler&lt;/code&gt; 的地方都可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intHandler&lt;/code&gt;来代替.&lt;br /&gt;
这种闭包的类型方向和原始的闭包参数的类型方向相反, 叫做逆变(contravariance).&lt;/p&gt;

&lt;h1 id=&quot;接下来我们就可以来分析一下第三段代码为什么不会报错&quot;&gt;接下来,我们就可以来分析一下第三段代码为什么不会报错&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let intResolverLater: ((Int) -&amp;gt; Void) -&amp;gt; Void = { f in
    f(0)
}

var anyResolverLater: ((Any) -&amp;gt; Void) -&amp;gt; Void = intResolver ___ OK.
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;首先, 下面的这个关系, 我们已经非常熟悉了(此处省略变量名)
    &lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let Any = Int
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;然后, 对于一个函数来说, 左侧的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; 类型的参数应该是右侧 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; 类型的参数的子类型.
    &lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let (Int) -&amp;gt; Void = (Any) -&amp;gt; Void
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;可能不是很明显(逆变), 这同时也表明了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(Any) -&amp;gt; Void&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(Int) -&amp;gt; Void&lt;/code&gt; 的子类型.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;最后, 使用同样的逻辑, 左侧的参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((Any) -&amp;gt; Void)&lt;/code&gt;应该是 右侧的参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((Int) -&amp;gt; Void)&lt;/code&gt; 的子类型. 证明过程同第 2 步.(又一次逆变)
    &lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let ((Any) -&amp;gt; Void) -&amp;gt; Void = ((Int) -&amp;gt; Void) -&amp;gt; Void
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;类型关系的方向被不断的被交换.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过一个用例, 尝试来看一下这段代码是怎么正确执行的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let intResolverLater: ((Int) -&amp;gt; Void) -&amp;gt; Void = { (f) in
   // Use f to handle some Int
   f(1000)
}
let anyResolverLater: ((Any) -&amp;gt; Void) -&amp;gt; Void = intResolverLater
// anyResolver must be able to handle Any (can possibly be Int)
let anyResolver: (Any) -&amp;gt; Void = { (any) in
   switch any {
   case num as Int:
      print(&quot;Got an int! \(num)&quot;)
   ...handle other cases
   }
}
// anyResolver can be used to handle Any (or Int) safely later!
anyResolverLater(anyResolver)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;一个可视的帮助判断的方法&quot;&gt;一个可视的帮助判断的方法&lt;/h1&gt;

&lt;p&gt;我们可以把闭包和函数的子类化行为想像成一根水管. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f: (A) -&amp;gt; B&lt;/code&gt; 是一根水管, 它的输入是 A, 输出是 B, 两端和系统的其它部分是相匹配的, 这样里面的水可以顺利的流过.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pipe-1.webp&quot; alt=&quot;f: (A) — &amp;gt; B&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果想要在保证水能安全的流过的前提下来替换这根水管, 那么新的水管就比要有更大的进水口(A 的父类型)和更小的出水口(B 的子类型).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pipe-2.webp&quot; alt=&quot;f: (A) — &amp;gt; B&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示, 新水管 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f′&lt;/code&gt; 可以用在任何原来的水管 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 使用的地方, 但是反过来不行. 所以, 闭包 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f′&lt;/code&gt; 是闭包 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 的子类型.&lt;/p&gt;

&lt;h1 id=&quot;不变性不相关性-invariance&quot;&gt;不变性,不相关性 (Invariance)&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; 是不相关的(invariance). 它们的了类型不兼容. 互相之间不能替换.&lt;br /&gt;
Swift 中的泛型 (Generic) 是不变性 (invariance). 这意味着 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PetOwner&amp;lt;Cat&amp;gt;&lt;/code&gt; 不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PetOwner&amp;lt;Animal&amp;gt;&lt;/code&gt; 的子类型. 它们之间互相没有关系…&lt;/p&gt;

&lt;h1 id=&quot;最后&quot;&gt;最后&lt;/h1&gt;
&lt;p&gt;最后, 让我们用一个小坑来结束. 为什么 Swift 标准库中的泛型, 比如说 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array&amp;lt;Animal&amp;gt;&lt;/code&gt; 是协变的(convatiant) 但是, 我们自己定义的泛型, (比如说&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PetOwner&amp;lt;Animal&amp;gt;&lt;/code&gt;) 确是 不变性(invariant) 的?&lt;/p&gt;

&lt;p&gt;这么看来, 这背后应该是有一些神奇的魔法. &lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-11-20-covariance-and-contravariance.html#comment-e1defaef8e71a2dcc471b51f67725737&quot;&gt;Rick&lt;/a&gt;是这样说的:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“Swift generics are normally invariant, but the Swift standard library collection types — even though those types appear to be regular generic types — use some sort of magic inaccessible to mere mortals that lets them be covariant.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;WIKIPEDIA-Convariance and Contravariance&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@aunnnn/covariance-and-contravariance-in-swift-32f3be8610b9&quot;&gt;Convariance and Contravariance in Swift&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-11-20-covariance-and-contravariance.html&quot;&gt;Friday Q&amp;amp;A 2015-11-20: Covariance and Contravariance
by Mike Ash &lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Swift" /><summary type="html">协变 - Covaiance 逆变 - Contravariance</summary></entry><entry><title type="html">Octopress 2.0 到 3.0 的迁移</title><link href="/octopress/2023/09/26/migrating-from-octopress-2-to-3.html" rel="alternate" type="text/html" title="Octopress 2.0 到 3.0 的迁移" /><published>2023-09-26T23:58:10+08:00</published><updated>2023-09-26T23:58:10+08:00</updated><id>/octopress/2023/09/26/migrating-from-octopress-2-to-3</id><content type="html" xml:base="/octopress/2023/09/26/migrating-from-octopress-2-to-3.html">&lt;p&gt;Octorpess 3.0 相比 Octopress 2.0 而言，有着不同的分发方式和维护方式。本文主要记录了我在从 Octopress 2.0 迁移到 3.0 时的过程和遇到的一些问题。&lt;/p&gt;

&lt;p&gt;迁移方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;建立一个新的 Octopress 3.0 博客项目&lt;/li&gt;
  &lt;li&gt;将旧的 Octopress 3.0 Blog 中的文章和配置移到 3.0 中&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;1-建立一个新的-octopress-30-博客项目&quot;&gt;1. 建立一个新的 Octopress 3.0 博客项目&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;a.安装最新版本的 Octopress&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;octorpess
 gem update octopress &lt;span class=&quot;c&quot;&gt;# 之前有过安装，可以更新 octopress 到最新版本&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里如果遇到了 write permission 的问题，可以使用 rbenv 来安装一个新的 ruby 版本，然后使用这个版本来安装 gem。具体可以参考 &lt;a href=&quot;https://douxinchun.github.io/2023/09/26/rbenv-notes.html&quot;&gt;rbenv notes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b.创建 Octopress 3.0 项目&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; octopress new Blog &lt;span class=&quot;c&quot;&gt;# 因为 octopress 不是安装在 macOS 内置的 ruby 版本中，所以指定此命令前，需要使用 rbenv 来指定 ruby 版本&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的目录就是 Octopress 3.0 初始化的目录结构。看起来和 2.0 中的 source 文件夹下的目录结构非常类似。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; .
├── 404.html
├── Gemfile
├── Gemfile.lock
├── README.md
├── _config.yml
├── _deploy.yml
├── _posts
│   ├── 2023-09-25-welcome-to-jekyll.markdown
├── _site
├── _templates
│   ├── draft
│   ├── page
│   └── post
├── about.markdown
└── index.markdown
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;c.查看 Hello world&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;，然后在浏览器中打开 http://localhost:4000/，可以看到 &lt;a href=&quot;https://douxinchun.github.io/jekyll/update/2023/09/25/welcome-to-jekyll.html&quot;&gt;Welcome to Jekyll!&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;Blog
jekyll serve &lt;span class=&quot;c&quot;&gt;# 按照提示可能需要加上前缀 bundle exec&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-迁移文章和图片&quot;&gt;2. 迁移文章和图片&lt;/h1&gt;

&lt;p&gt;a. 文章迁移&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; .../old_blog/source/_posts ./_posts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;b. 图片迁移&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; .../old_blog/source/images ./images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-配置插件&quot;&gt;3. 配置插件&lt;/h1&gt;

&lt;p&gt;Jekyll 有多种的添加插件的方式. &lt;a href=&quot;https://jekyllrb.com/docs/plugins/&quot;&gt;Plugins Installaton&lt;/a&gt;.&lt;br /&gt;
a. 将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.rb&lt;/code&gt; 文件放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_plugins&lt;/code&gt; 目录下&lt;br /&gt;
b. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 中添加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plugins&lt;/code&gt; 配置项&lt;br /&gt;
c. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt; 中添加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gem&lt;/code&gt; 依赖&lt;/p&gt;

&lt;p&gt;我这里选择了在 Gemfile 中添加依赖的方式, 这里添加时可以去除后面的版本号, 交由 bundle 来解决依赖版本冲突的问题.&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# If you have any plugins, put them here!&lt;/span&gt;
group :jekyll_plugins &lt;span class=&quot;k&quot;&gt;do
  &lt;/span&gt;gem &lt;span class=&quot;s2&quot;&gt;&quot;jekyll-feed&quot;&lt;/span&gt;
  gem &lt;span class=&quot;s2&quot;&gt;&quot;octopress&quot;&lt;/span&gt;
  gem &lt;span class=&quot;s2&quot;&gt;&quot;octopress-image-tag&quot;&lt;/span&gt;
  gem &lt;span class=&quot;s2&quot;&gt;&quot;kramdown-parser-gfm&quot;&lt;/span&gt;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-部署&quot;&gt;4. 部署&lt;/h1&gt;

&lt;p&gt;Octopress 2.0 时是使用 master 分支来发布 Blog, source 分支来管理 Blog. Octorpess 3.0 可以做到发布和管理的分离.&lt;br /&gt;
我采用的方式是, 使用一个单独的 Blog git 仓库来管理 Blog, 然后使用另外的 GitHub User Pages 仓库来发布 Blog.&lt;/p&gt;

&lt;p&gt;Octorpess 3.0 可以通过 S3, Rsync 或 GitHub pages 来进行部署发布.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopres deploy init git # 创建一个通过 GitHub Pages 来部署的配置文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行后, 会在项目的根目录下生成一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_deploy.yml&lt;/code&gt; 文件, 用来配置发布的相关信息.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
``` yml
method: git                               # How do you want to deploy? git, rsync or s3.
site_dir: _site                           # Location of your static site files.
git_url: git@github.com:xxxx/xxx.github.io.git  # remote repository url, e.g. git@github.com:username/repo_name
# Note on git_branch:
# If using GitHub project pages, set the branch to &apos;gh-pages&apos;.
# For GitHub user/organization pages or Heroku, set the branch to &apos;master&apos;.
#
git_branch: master                     # Git branch where static site files are commited
# remote_path:                            # Destination directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_deploy.yml&lt;/code&gt; 文件配置好以后, 执行&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build
octopress deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘.deploy’ 文件夹下的内容就是被自动部署到 GitHub Users Pages 仓库中.&lt;/p&gt;

&lt;p&gt;可以创建多个 deploy 配置文件, 然后再部署发布时通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-c&lt;/code&gt; 选项来指定配置文件.&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopress deploy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;your_deploy_config_file]
&lt;span class=&quot;c&quot;&gt;# -c, --config FILE  The path to your config file (default: _deploy.yml)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;github-userorganization-pages-和-project-pages-的区别&quot;&gt;Github User/Organization Pages 和 Project Pages 的区别&lt;/h2&gt;
&lt;h3 id=&quot;user-pages用户页面&quot;&gt;User Pages（用户页面）：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用途：User Pages 通常用于个人或组织的用户主页。每个 GitHub 用户都可以创建一个 User Page，它位于 https://username.github.io, 这个页面通常用于展示个人信息、作品、博客等内容.&lt;/li&gt;
  &lt;li&gt;存储库要求：为了创建 User Page，您需要创建一个名为 &lt;username&gt;.github.io 的公共存储库，并将网站内容提交到该存储库的 main 分支（以前是 master 分支）或 docs 文件夹。&lt;/username&gt;&lt;/li&gt;
  &lt;li&gt;自定义域名：User Pages 支持自定义域名，您可以将自己的域名绑定到 User Page 上(CNAME).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;project-pages项目页面&quot;&gt;Project Pages（项目页面）：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用途：Project Pages 用于特定 GitHub 存储库的项目文档、演示、站点或文档。每个存储库都可以启用 Project Pages 来托管与该存储库相关的网站。&lt;/li&gt;
  &lt;li&gt;存储库要求：要启用 Project Pages，您需要在存储库的设置中选择一个分支（通常是 gh-pages 分支）作为网站的源，并将网站内容提交到该分支。网站将位于 https://username.github.io/repository-name。&lt;/li&gt;
  &lt;li&gt;多个项目页面：对于每个 GitHub 存储库，您可以启用多个 Project Pages，每个页面可以使用不同的分支或路径来托管不同的网站。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-gitignore&quot;&gt;5. gitignore&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_site&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.deploy&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code-highlighter-cache&lt;/code&gt; (如果安装了 code-highlight 插件)都是生成的目录, 均可以放在 gitignore 中.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# .gitignore file content
_site
.code-highlighter-cache
.deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Octopress" /><summary type="html">Octorpess 3.0 相比 Octopress 2.0 而言，有着不同的分发方式和维护方式。本文主要记录了我在从 Octopress 2.0 迁移到 3.0 时的过程和遇到的一些问题。</summary></entry><entry><title type="html">rbenv 笔记</title><link href="/2023/09/26/rbenv-notes.html" rel="alternate" type="text/html" title="rbenv 笔记" /><published>2023-09-26T12:51:24+08:00</published><updated>2023-09-26T12:51:24+08:00</updated><id>/2023/09/26/rbenv-notes</id><content type="html" xml:base="/2023/09/26/rbenv-notes.html">&lt;h1 id=&quot;context&quot;&gt;Context&lt;/h1&gt;
&lt;p&gt;在 macOS 下使用 gem 安装 ruby 工具的时候，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gem install octopress&lt;/code&gt;，可能会遇到没有写权限的问题:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You don&apos;t have write permissions for the /Library/Ruby/Gems/x.x.x directory.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这是因为默认情况下使用的 ruby 是macOS内置的。macOS不允许用户修改系统内置的ruby。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;!!!强烈不建议通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chmod&lt;/code&gt; 的方式来强行修改系统文件和目录写入权限。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正确解决方法是使用ruby的版本管理工具(例如: rbenv)安装一个新的ruby版本，然后使用这个版本来安装gem。&lt;/p&gt;

&lt;h1 id=&quot;ruby-版本管理工具对比&quot;&gt;Ruby 版本管理工具对比&lt;/h1&gt;

&lt;p&gt;我用过的ruby版本管理工具有&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rbenv/rbenv&quot;&gt;rbenv&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://rvm.io/rvm/install&quot;&gt;rvm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两者相比，rbenv 有 global 和 local 的概念，可以设定全局的 ruby 版本（global）和在不同的项目下使用不同版本的 ruby（local）。 RVM 是在每次使用前手动的切换版本来使用不同的 ruby。&lt;/p&gt;

&lt;h1 id=&quot;install&quot;&gt;Install&lt;/h1&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;rbenv ruby-build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbenv init&lt;/code&gt;，按照提示，将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval &quot;$(rbenv init - zsh)&quot;&lt;/code&gt;添加到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;中。&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ rbenv init
&lt;span class=&quot;c&quot;&gt;# Load rbenv automatically by appending&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# the following to ~/.zshrc:&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;rbenv init - zsh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;usage&quot;&gt;Usage&lt;/h1&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ rbenv &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 列出最新的的稳定版本的 ruby， install 命令是由 ruby-build 来提供的。&lt;/span&gt;
➜ rbenv &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;3.2.2 &lt;span class=&quot;c&quot;&gt;# 安装指定版本的 Ruby &lt;/span&gt;
➜ rbenv versions &lt;span class=&quot;c&quot;&gt;# 查看所有已安装的版本&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 查看和设定全局ruby版本&lt;/span&gt;
➜ rbenv global
system
➜ rbenv global x.x.x

&lt;span class=&quot;c&quot;&gt;# 查看和设定本地ruby版本, 存在本地 ruby 版本的项目会在项目根目录下生成一个 .ruby-version 文件&lt;/span&gt;
➜ rbenv &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;3.2.2
➜ rbenv &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;3.2.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;rbenv-工作原理&quot;&gt;rbenv 工作原理&lt;/h1&gt;
&lt;p&gt;rbenv 利用 $PATH 来劫持了 ruby 命令，然后根据当前目录下是否存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.ruby-version 文件来决定使用哪个 ruby 版本&lt;/code&gt;。如果找不到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.ruby-version&lt;/code&gt;，则会使用 global 版本。&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ which ruby
/Users/&amp;lt;username&amp;gt;/.rbenv/shims/ruby
➜ &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;
/Users/&amp;lt;username&amp;gt;/.rbenv/shims:/opt/homebrew/bin:...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">Context 在 macOS 下使用 gem 安装 ruby 工具的时候，例如gem install octopress，可能会遇到没有写权限的问题: You don&apos;t have write permissions for the /Library/Ruby/Gems/x.x.x directory. 这是因为默认情况下使用的 ruby 是macOS内置的。macOS不允许用户修改系统内置的ruby。</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="/jekyll/update/2023/09/25/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2023-09-25T20:47:59+08:00</published><updated>2023-09-25T20:47:59+08:00</updated><id>/jekyll/update/2023/09/25/welcome-to-jekyll</id><content type="html" xml:base="/jekyll/update/2023/09/25/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MONTH&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &apos;Hi, Tom&apos; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">OpenWRT下安装和配置shadowsocks</title><link href="/openwrt/shadowsocks/2021/03/02/install-shadowsocks-on-openwrt.html" rel="alternate" type="text/html" title="OpenWRT下安装和配置shadowsocks" /><published>2021-03-02T01:21:57+08:00</published><updated>2021-03-02T01:21:57+08:00</updated><id>/openwrt/shadowsocks/2021/03/02/install-shadowsocks-on-openwrt</id><content type="html" xml:base="/openwrt/shadowsocks/2021/03/02/install-shadowsocks-on-openwrt.html">&lt;p&gt;本文主要记录在openWRT下安装和配置shadowsocks的简要过程，便于日后查找和备忘。成功安装后可以实现透明代理，分流和防DNS污染。&lt;/p&gt;

&lt;h2 id=&quot;environment&quot;&gt;Environment&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;路由器型号：YouHua WR1200JS&lt;/li&gt;
  &lt;li&gt;固件版本：OpenWrt 19.07.4 r11208-ce6496d796 / LuCI openwrt-19.07 branch git-21.054.03371-3b137b5&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;拓扑图工作原理&quot;&gt;拓扑图+工作原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/blog_reference_image/2021/3/openwrt-shadowsocks-arch.png&quot; alt=&quot;topology map&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;dnsmasq是openwrt自带的一个软件，提供dns缓存，dhcp等功能。dnsmasq会将dns查询数据包转发给chinadns。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chinadns的上游DNS服务器有两个，一个是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;国内DNS&lt;/code&gt;，一个是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;（国外DNS）。&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;chinadns会同时向上游的DNS发送请求&lt;/li&gt;
      &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;先返回, 则直接采用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;的结果&lt;/li&gt;
      &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;国内DNS&lt;/code&gt;先返回, 分两种情况: 如果返回的结果是国内IP,则采用;否则丢弃并等待采用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;的结果&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.dns-forwarder 支持DNS TCP查询, 如果ISP的UDP不稳定, 丢包严重,可以使用dns-forwarder来代替&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ss-tunnel&lt;/code&gt;来进行DNS查询.&lt;/p&gt;

&lt;p&gt;4.shadowsocks 用于转发数据包, 科学上网. 关于shadowsocks的科普文章可查看这里: https://www.css3er.com/p/107.html&lt;/p&gt;

&lt;h2 id=&quot;相关的ipk软件包下载地址&quot;&gt;相关的ipk软件包下载地址&lt;/h2&gt;
&lt;p&gt;ipk软件包集合, 不同的CPU架构需要使用不同的软件包, CPU架构是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mipsel_24kc&lt;/code&gt;的话, 可以集中从这里下载.&lt;br /&gt;
链接: https://pan.baidu.com/s/14QDoTLqw-SEBZvQVQeVgvA 提取码: ugsc&lt;br /&gt;
其它的CPU架构, 可以去GitHub主页 -&amp;gt; Releases下载别人已经编译好的软件包, 如果没有, 只能自己下载openWRT的SDK, 自己进行编译.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shadowsocks-libev_3.3.5-1_mipsel_24kc.ipk&lt;/li&gt;
  &lt;li&gt;shadowsocks-libev-server_3.3.5-1_mipsel_24kc.ipk&lt;/li&gt;
  &lt;li&gt;ChinaDNS_1.3.3-1_mipsel_24kc.ipk&lt;/li&gt;
  &lt;li&gt;dns-forwarder_1.2.1-2_mipsel_24kc.ipk&lt;/li&gt;
  &lt;li&gt;luci-compat&lt;/li&gt;
  &lt;li&gt;luci-app-shadowsocks-without-ipset_1.9.1-1_all.ipk&lt;/li&gt;
  &lt;li&gt;luci-app-chinadns_1.6.2-1_all.ipk&lt;/li&gt;
  &lt;li&gt;luci-app-dns-forwarder_1.6.2-1_all.ipk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;链接: https://pan.baidu.com/s/14QDoTLqw-SEBZvQVQeVgvA 提取码: ugsc&lt;/p&gt;
&lt;h3 id=&quot;openwrt-shadowsocks&quot;&gt;openwrt-shadowsocks&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;: https://github.com/shadowsocks/openwrt-shadowsocks  &lt;br /&gt;
&lt;strong&gt;luci-app-shadowsocks&lt;/strong&gt;: https://github.com/shadowsocks/luci-app-shadowsocks&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;shadowsocks-libev&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 客户端/
 └── usr/
     └── bin/
         ├── ss-local       // 提供 SOCKS 正向代理, 在透明代理工作模式下用不到这个.
         ├── ss-redir       // 提供透明代理, 从 v2.2.0 开始支持 UDP
         └── ss-tunnel      // 提供端口转发, 可用于 DNS 查询
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;shadowsocks-libev-server&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;服务端/
└── usr/
    └── bin/
        └── ss-server      // 服务端可执行文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chinadns&quot;&gt;ChinaDNS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;: https://github.com/aa65535/openwrt-chinadns&lt;br /&gt;
&lt;strong&gt;原版ChinaDNS地址, 被请喝茶后已不再维护&lt;/strong&gt;:https://github.com/shadowsocks/ChinaDNS&lt;br /&gt;
&lt;strong&gt;luci-app-chinadns&lt;/strong&gt;: https://github.com/aa65535/openwrt-dist-luci&lt;/p&gt;

&lt;p&gt;更新 /etc/chinadns_chnroute.txt&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; wget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\| &apos;/CN\|ipv4/ { printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) }&apos; &amp;gt; /etc/chinadns_chnroute.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;###dns-forwarder
&lt;strong&gt;GitHub&lt;/strong&gt;: https://github.com/aa65535/openwrt-dns-forwarder&lt;br /&gt;
&lt;strong&gt;luci-app-dns-forwarder&lt;/strong&gt;: https://github.com/aa65535/openwrt-dist-luci&lt;/p&gt;

&lt;h3 id=&quot;dnsmasq&quot;&gt;dnsmasq&lt;/h3&gt;
&lt;p&gt;openWRT自带, 无需自行下载安装.&lt;br /&gt;
&lt;strong&gt;GitHub&lt;/strong&gt;: https://github.com/aa65535/openwrt-dnsmasq&lt;/p&gt;

&lt;h2 id=&quot;install&quot;&gt;Install&lt;/h2&gt;

&lt;p&gt;去软件项目的GitHub主页 -&amp;gt; Releases下面下载编译好的ipk, 如果没有符合的自己CPU架构的包, 则需要自己下载openWRT的SDK进行编译, 具体的教程各个主页上有.&lt;br /&gt;
查看CPU架构的命令 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opkg print-architecture&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# opkg print-architecture
&lt;span class=&quot;nb&quot;&gt;arch &lt;/span&gt;all 1
&lt;span class=&quot;nb&quot;&gt;arch &lt;/span&gt;noarch 1
&lt;span class=&quot;nb&quot;&gt;arch &lt;/span&gt;mipsel_24kc 10
root@OpenWrt:~#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下载完成有两种方式安装&lt;br /&gt;
方式一(建议): 通过web使用luci安装:
路径: 系统 -&amp;gt; Software -&amp;gt; Upload Package… -&amp;gt; Install&lt;/p&gt;

&lt;p&gt;方式二: 直接在线通过opkg命令来安装(注意使用方式需要提前更新好软件源, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opkg update&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;opkg install luci-compat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;config&quot;&gt;Config&lt;/h2&gt;

&lt;h3 id=&quot;方式一-使用luci来配置&quot;&gt;方式一, 使用luci来配置&lt;/h3&gt;
&lt;p&gt;登录luci.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;配置ss-server &lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;影梭&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务器管理&lt;/code&gt;, 添加自己的shadowsocks server&lt;/li&gt;
  &lt;li&gt;配置dnsmasq
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;网络&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DHCP/DNS&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;常规设置&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;本地服务器&lt;/code&gt;, 设置为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1#5353&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;网络&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DHCP/DNS&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HOSTS和解析文件&lt;/code&gt;, 勾选: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;忽略解析文件&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置ChinaDNS&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChinaDNS&lt;/code&gt;&lt;br /&gt;
 监听端口: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5353&lt;/code&gt;&lt;br /&gt;
 上游服务器修改为: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;114.114.114.114,127.0.0.1#5300&lt;/code&gt;&lt;br /&gt;
 这样&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;国内DNS&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;114.114.114.114&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1#5353&lt;/code&gt;, 勾选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;启用&lt;/code&gt;, 保存设置&lt;/li&gt;
  &lt;li&gt;配置dns-forwarder&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DNS转发&lt;/code&gt;&lt;br /&gt;
 监听端口: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5300&lt;/code&gt; 
 监听地址: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.0.0.0&lt;/code&gt;&lt;br /&gt;
 上游 DNS: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8.8.8.8 &lt;/code&gt;
 勾选, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;启用&lt;/code&gt; 保存&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置shadowsocks 透明代理 + 访问控制&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;影梭&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;常规设置&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;透明代理&lt;/code&gt;&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;主服务器&lt;/code&gt;, 选择setp1中配置的ss-server, 保存.&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt;-&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;影梭&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;常规设置&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;访问控制&lt;/code&gt;-&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;外网区域 &lt;/code&gt; &lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;被忽略IP列表&lt;/code&gt;, 选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChinaDNS路由表&lt;/code&gt;, 保存设置.  注意这里的优先级: (走代理IP列表 = 强制走代理IP) &amp;gt; (额外被忽略IP = 被忽略IP列表)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;保存并应用&lt;/code&gt; 所有配置, reboot openWRT&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;方式二-直接编辑etcconfig目录下的文件&quot;&gt;方式二, 直接编辑/etc/config目录下的文件&lt;/h3&gt;
&lt;p&gt;课外阅读: UCI System
&lt;a href=&quot;https://oldwiki.archive.openwrt.org/doc/uci&quot;&gt;UCI system&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The abbreviation UCI stands for Unified Configuration Interface and is intended to centralize the configuration of OpenWrt.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;etcconfigshadowsocks&quot;&gt;/etc/config/shadowsocks&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# cat /etc/config/shadowsocks

config general
	option startup_delay &apos;0&apos;

config transparent_proxy
	option udp_relay_server &apos;nil&apos;
	option local_port &apos;1234&apos;
	option mtu &apos;1492&apos;
	list main_server &apos;cfg054a8f&apos;

config socks5_proxy
	option local_port &apos;1080&apos;
	option mtu &apos;1492&apos;
	list server &apos;nil&apos;

config port_forward
	option local_port &apos;5300&apos;
	option mtu &apos;1492&apos;
	option destination &apos;8.8.8.8:53&apos;
	list server &apos;nil&apos;

config servers
	option fast_open &apos;0&apos;
	option no_delay &apos;0&apos;
	option timeout &apos;60&apos;
	option server &apos;服务器地址,注意luci下这里只能是ip&apos;
	option server_port &apos;端口&apos;
	option password &apos;密码&apos;
	option encrypt_method &apos;加密方式&apos;
	option alias &apos;ss服务别名&apos;

config access_control
	option self_proxy &apos;1&apos;
	option lan_target &apos;SS_SPEC_WAN_AC&apos;
	option wan_bp_list &apos;/etc/chinadns_chnroute.txt&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;etcconfigdhcp&quot;&gt;/etc/config/dhcp&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# cat /etc/config/dhcp

config dnsmasq
	option domainneeded &apos;1&apos;
	option localise_queries &apos;1&apos;
	option rebind_protection &apos;1&apos;
	option rebind_localhost &apos;1&apos;
	option domain &apos;lan&apos;
	option expandhosts &apos;1&apos;
	option authoritative &apos;1&apos;
	option readethers &apos;1&apos;
	option leasefile &apos;/tmp/dhcp.leases&apos;
	option localservice &apos;1&apos;
	option local &apos;127.0.0.1#5353&apos;
	option noresolv &apos;1&apos;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;etcconfigchinadns&quot;&gt;/etc/config/chinadns&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# cat /etc/config/chinadns

config chinadns
	option chnroute &apos;/etc/chinadns_chnroute.txt&apos;
	option addr &apos;0.0.0.0&apos;
	option port &apos;5353&apos;
	option bidirectional &apos;1&apos;
	option server &apos;114.114.114.114,127.0.0.1#5300&apos;
	option enable &apos;1&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;etcconfigdns-forwarder&quot;&gt;/etc/config/dns-forwarder&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# cat /etc/config/dns-forwarder

config dns-forwarder
	option listen_addr &apos;0.0.0.0&apos;
	option listen_port &apos;5300&apos;
	option enable &apos;1&apos;
	option dns_servers &apos;8.8.8.8&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;验证配置是否生效&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# netstat &lt;span class=&quot;nt&quot;&gt;-lpn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;ss
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:1234            0.0.0.0:&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;               LISTEN      13469/ss-redir
root@OpenWrt:~# netstat &lt;span class=&quot;nt&quot;&gt;-lpn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;5353
udp        0      0 0.0.0.0:5353            0.0.0.0:&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                           1438/chinadns
root@OpenWrt:~# netstat &lt;span class=&quot;nt&quot;&gt;-lpn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;5300
udp        0      0 0.0.0.0:5300            0.0.0.0:&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                           12993/dns-forwarder
root@OpenWrt:~# netstat &lt;span class=&quot;nt&quot;&gt;-lpn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;53
tcp        0      0 127.0.0.1:53            0.0.0.0:&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;               LISTEN      2254/dnsmasq
...

root@OpenWrt:~# nslookup google.com 127.0.0.1#5353
Server:		127.0.0.1
Address:	127.0.0.1#5353

Name:      google.com
Address 1: 142.250.72.238
Address 2: 2607:f8b0:4007:80d::200e
root@OpenWrt:~#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;issues&quot;&gt;Issues&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;luci-app-shadowsocks 不支持domain的方式配置ss-server, 需要使用IP地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Link
https://www.youtube.com/watch?v=2SPQYsMmltE&amp;amp;t=317s - 十年老程 openwrt shadowsocks安装配置对应的视频教程
http://snlcw.com/305.html - 上述教程对应的blog地址. 
https://www.youtube.com/channel/UCgo7XWK6MQBgKt0gBI6x3CA/videos - 十年老程的Youtube专栏，里面有各种科学上网的视频教程. 
https://openwrt.org/docs/guide-user/base-system/dhcp_configuration&lt;/p&gt;</content><author><name></name></author><category term="openwrt" /><category term="shadowsocks" /><summary type="html">本文主要记录在openWRT下安装和配置shadowsocks的简要过程，便于日后查找和备忘。成功安装后可以实现透明代理，分流和防DNS污染。</summary></entry><entry><title type="html">gitignore 文件屏蔽规则</title><link href="/git/2019/01/31/rule-of-gitignore-file.html" rel="alternate" type="text/html" title="gitignore 文件屏蔽规则" /><published>2019-01-31T18:10:28+08:00</published><updated>2019-01-31T18:10:28+08:00</updated><id>/git/2019/01/31/rule-of-gitignore-file</id><content type="html" xml:base="/git/2019/01/31/rule-of-gitignore-file.html">&lt;p&gt;文件名： &lt;strong&gt;.gitignore&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;位置：&lt;/p&gt;

&lt;p&gt;global 当前用户的主目录下 ~  一般是自己使用不和别人share 该设置对所有的本地仓库都起作用&lt;/p&gt;

&lt;p&gt;local 当前仓库的主目录下 一般需要加入到git库的版本控制中，需要和别人share&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git config&lt;/strong&gt; 中的 &lt;strong&gt;core.excludesfile&lt;/strong&gt; 可以指定 .gitignore 文件&lt;/p&gt;

&lt;p&gt;格式规范如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有空行和#开头的行都会被忽略&lt;/li&gt;
  &lt;li&gt;文件或者目录前加 / 表示仓库根目录下的对应文件，子目录下的同名文件不忽略&lt;/li&gt;
  &lt;li&gt;文件或者目录后加 / 表示要忽略的是目录，不加 / 表示文件和目录都忽略&lt;/li&gt;
  &lt;li&gt;所有模式取反可以在最前面加 ！&lt;/li&gt;
  &lt;li&gt;可以使用标准的 &lt;strong&gt;glob&lt;/strong&gt; 模式匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;glob 模式是一种简化了的正则表达式，使用于shell&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;* 匹配零个或者多个任意字符&lt;/li&gt;
  &lt;li&gt;？匹配任意一个字符&lt;/li&gt;
  &lt;li&gt;[abc] 匹配任意一个方括号中的字符&lt;/li&gt;
  &lt;li&gt;[0-9] 短线表示范围，表示匹配任意一个0到9的数字&lt;/li&gt;
  &lt;li&gt;{string1,string2} 大括号代表可选的字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;匹配时，下面的条目可以覆盖上&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;readme.md       &lt;span class=&quot;c&quot;&gt;# 屏蔽仓库中所有名为 readme.md 的文件&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;/readme.md     &lt;span class=&quot;c&quot;&gt;# 在上一条屏蔽规则的条件下，不屏蔽仓库根目录下的 readme.md 文件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;link&quot;&gt;Link&lt;/h2&gt;
&lt;p&gt;https://www.jianshu.com/p/13612fb4b224
https://www.cnblogs.com/qwertWZ/archive/2013/03/26/2982231.html&lt;/p&gt;</content><author><name></name></author><category term="git" /><summary type="html">文件名： .gitignore</summary></entry><entry><title type="html">C 语言函数指针小测试</title><link href="/function%20pointer/c/2018/09/28/function-pointer-test.html" rel="alternate" type="text/html" title="C 语言函数指针小测试" /><published>2018-09-28T15:10:54+08:00</published><updated>2018-09-28T15:10:54+08:00</updated><id>/function%20pointer/c/2018/09/28/function-pointer-test</id><content type="html" xml:base="/function%20pointer/c/2018/09/28/function-pointer-test.html">&lt;p&gt;首先看一道趣味题,来源:https://www.v2ex.com/t/492705&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
[] 
printf(&quot;%p\n&quot;, **********************p);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 [] 标记内加入一条语句，使得：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;程序编译通过，无错误（警告随意）；链接通过，无错误（警告随意）&lt;/li&gt;
  &lt;li&gt;程序能够运行，无崩溃和运行时错误&lt;/li&gt;
  &lt;li&gt;源代码为.c 文件&lt;/li&gt;
  &lt;li&gt;如果用 vs，则使用 Release 配置；用 gcc 也行&lt;/li&gt;
  &lt;li&gt;加入的语句不能忽略分号&lt;/li&gt;
  &lt;li&gt;printf 一句必须能够正常输出内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;答案如下表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;int(*p)();&lt;/th&gt;
      &lt;th&gt;10个字符&lt;/th&gt;
      &lt;th&gt;兼容 gcc、g++、vs&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;int p(){}&lt;/td&gt;
      &lt;td&gt;9个字符&lt;/td&gt;
      &lt;td&gt;兼容 gcc，不兼容 g++、vs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;p();}p(){&lt;/td&gt;
      &lt;td&gt;9个字符&lt;/td&gt;
      &lt;td&gt;兼容 gcc、g++、vs&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;本文主要针对第一种答案来说明一下为什么函数指针可以被无线次解引用.&lt;/p&gt;

&lt;h2 id=&quot;-&quot;&gt;&amp;amp; *&lt;/h2&gt;

&lt;p&gt;说到指针,首先就一定要介绍两个操作符.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;amp; 地址操作符(address operators) 单目前缀操作符,操作数为跟在后面的表达式. eg:&amp;amp;a,表示取操作数a的地址,也可以理解为取对象a的地址,或者取变量a的地址等等.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 在64处理器的系统模式下,地址的长度为8个字节
int a;
printf(&quot;sizeof(&amp;amp;a)=%d\n&quot;,sizeof(&amp;amp;a));

**********result**********
sizeof(&amp;amp;a)=8
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;* 间接操作符 (indirection operators) 单目前缀操作数,同样也是跟在后面的表达式为操作数,可以使用间接操作符通过指针对象间接地访问它所指向对象的值. eg: *a,表示取&lt;strong&gt;指针对象&lt;/strong&gt;a中存的地址所指向的值. (这里的表达非常绕,下面举个例子,请自行脑补)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*a的举例: 超市的储物柜,每个格子都有一个唯一对应的条形码,我们认为这就是每个格子的地址,格子本身就是实实在在的三维空间,是可以放物品的.现在有两个格子a格和b格,我们把背包放进了b格,然后把印有b格条码的纸条放进了a格, 那么,a格就相当于一个指针变量, b格就相当于一个普通的变量. *a的意思就是 分两步,第一步找到a格,取出a格中存放的条码,第二步,按照条码找到b格,取出b格中的背包.  最终简化一下, *a就是背包.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;int b = 666;
int *a;
a = &amp;amp;b;
printf(&quot;*a=%d sizeof(*a)=%d\n&quot;,*a,sizeof(*a));

**********result**********
*a=666 sizeof(*a)=4
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于间接操作符,需要特别注意的有两点:&lt;/p&gt;

  &lt;p&gt;第一,间接操作符(*)与用来声明之神类别对象的”*“不属于同种功能,虽然它们两者确实是同一个字符,unicode码点都是 \u002a&lt;/p&gt;

  &lt;p&gt;第二,间接操作符只作用于指针类型的对象,也就是说简介操作符的的操作数必须是一个指针类型的对象.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;取地址与解引用&quot;&gt;“取地址”与”解引用”&lt;/h2&gt;

&lt;p&gt;通俗的讲,对一个变量的 &amp;amp; 操作称为”取地址”&lt;/p&gt;

&lt;p&gt;对一个指针变量的 * 操作称作”解引用”.&lt;/p&gt;

&lt;p&gt;换一种角度去理解解引用，”*“的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。这个值可以是另一个地址。&lt;/p&gt;

&lt;h2 id=&quot;多级指针&quot;&gt;多级指针.&lt;/h2&gt;

&lt;p&gt;如果一个指针变量存的是一个普通变量的地址,比如 int *a,只能存放一个整型变量的地址,那么这个指针叫做一级指针;如果一个指针变量存放的是另一个指针变量的地址,比如 int **, 里面存放的是一个(int *a)类型的指针变量的地址,那么这个指针变量叫二级指针,依次往下推,可以有三级指针,四级指针….直到多级指针.&lt;/p&gt;

&lt;h2 id=&quot;函数指针&quot;&gt;函数指针&lt;/h2&gt;

&lt;p&gt;简单理解就是指向函数地址的指针。比如我们声明的一个C函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void func(void);
//函数调用
func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么对于函数调用表达式 func() 而言， func后缀表达式就已经表示了一个指向返回类型为void，且参数列表为空的函数的指针：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;void (*) (void)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;函数指针的通用表达形式为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;返回类型 （* cv限定符 ）（形参列表）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，cv限定符为可选项。&lt;/p&gt;

&lt;p&gt;直接上code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void (*p)();
p=&amp;amp;func;

printf(&quot;sizeof(func)= %d\n&quot;,sizeof(func));
printf(&quot;sizeof(p)= %d\n&quot;,sizeof(p));

printf(&quot;func\t %p = %p\n&quot;,&amp;amp;func,func);
printf(&quot;p *p\t %p = %p = %p\n&quot;,&amp;amp;p,p,*p);

printf(&quot;p多次解引用 %p\n&quot;, **********************p);

void (*pNull)();
printf(&quot;pNull *p\t %p = %p = %p\n&quot;,&amp;amp;pNull,pNull,*pNull);
printf(&quot;pNull多次解引用 %p\n&quot;, **********************p);

**********result**********
sizeof(func)= 1
sizeof(p)= 8
func	 0x100000df0 = 0x100000df0
p *p	 0x7ffeefbff568 = 0x100000df0 = 0x100000df0
p多次解引用 0x100000df0
pNull *p	 0x7ffeefbff560 = 0x0 = 0x0
pNull多次解引用 0x0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;函数指针变量在64位系统下的大小是8，函数指针常量的大小是1。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数指针常量中存储的内容是自身的地址（这是为什么函数指针可以被无限次解引用的关键，因为解到最后一层以后，继续解就陷入了”自己找自己“的循环）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;未赋值的函数指针变量默认指向的是地址是0x0，对存储在该地址的指针对象解引用的结果依旧是0x0，所以可以认为0x0地址的内存单元中存的是地址0x0（此处上可能有误，尚需以后讨论）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="function pointer" /><category term="c" /><summary type="html">首先看一道趣味题,来源:https://www.v2ex.com/t/492705</summary></entry><entry><title type="html">Chrome中使用英文关键词搜索中文结果</title><link href="/google/2018/09/20/tips-of-google-search.html" rel="alternate" type="text/html" title="Chrome中使用英文关键词搜索中文结果" /><published>2018-09-20T17:28:46+08:00</published><updated>2018-09-20T17:28:46+08:00</updated><id>/google/2018/09/20/tips-of-google-search</id><content type="html" xml:base="/google/2018/09/20/tips-of-google-search.html">&lt;p&gt;在国内,访问Google需要用一点小技巧.有时候,我们使用英文的关键词,但是搜索结果想要查看中文的.由于的这点小技巧的原因,导致Google不能够正确的识别国家和地区的设置.&lt;/p&gt;

&lt;p&gt;知乎中有一篇帖子介绍了几个修改的方法: &lt;a href=&quot;https://www.zhihu.com/question/37498305&quot;&gt;如何修改Chrome里Google搜索的国家和地区设置？&lt;/a&gt; 这里我采取另外的一种方法来实现.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;chrome地址栏中输入 chrome://settings/searchEngines 打开chrome中的管理搜索引擎&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;复制默认搜索引擎的查询网址:   {google:baseURL}search?q=%s&amp;amp;{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQueryStats}{google:searchFieldtrialParameter}{google:iOSSearchLanguage}{google:searchClient}{google:sourceId}{google:contextualSearchVersion}ie={inputEncoding}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在上面的String后面追加 &amp;amp;lr=lang_zh-CN, 然后添加一个搜索引擎, 
名字:  Google 中文
关键词: cn
查询网址:  {google:baseURL}search?q=%s&amp;amp;{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQueryStats}{google:searchFieldtrialParameter}{google:iOSSearchLanguage}{google:searchClient}{google:sourceId}{google:contextualSearchVersion}ie={inputEncoding}&amp;amp;lr=lang_zh-CN&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://p64xrfkn6.bkt.clouddn.com/blog_reference_image/2018/9/1-1.png&quot; alt=&quot;增加搜索引擎&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.保存后,在地址栏中输入 cn+空格 ,然后再输入搜索关键字,OK,展示的搜索结果已经变成中文结果了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p64xrfkn6.bkt.clouddn.com/blog_reference_image/2018/9/1-2.png&quot; alt=&quot;使用介绍&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="google" /><summary type="html">在国内,访问Google需要用一点小技巧.有时候,我们使用英文的关键词,但是搜索结果想要查看中文的.由于的这点小技巧的原因,导致Google不能够正确的识别国家和地区的设置.</summary></entry><entry><title type="html">Xcode 使用技巧</title><link href="/xcode/2018/09/18/tips-of-xcode.html" rel="alternate" type="text/html" title="Xcode 使用技巧" /><published>2018-09-18T17:03:09+08:00</published><updated>2018-09-18T17:03:09+08:00</updated><id>/xcode/2018/09/18/tips-of-xcode</id><content type="html" xml:base="/xcode/2018/09/18/tips-of-xcode.html">&lt;h2 id=&quot;alcatraz&quot;&gt;Alcatraz&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/alcatraz/Alcatraz&quot;&gt;Alcatraz&lt;/a&gt;是一款开源的用于Xcode7的插件管理工具.Xcode8以及以后版本需要配合下面的工具来使用.&lt;/p&gt;

&lt;h2 id=&quot;update_xcode_plugins&quot;&gt;update_xcode_plugins&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/inket/update_xcode_plugins&quot;&gt;update_xcode_plugins&lt;/a&gt;可以为Xcode中安装的插件添加UUID, 同时还能够 为Xcode8以及以上的版本解除签名,这样就可以随心所欲的使用各种Xcode插件了.&lt;/p&gt;

&lt;h2 id=&quot;reset-xcodes-load-bundles-warning&quot;&gt;Reset Xcode’s “Load Bundles” warning&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-10.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行该命令,重启Xcode,可以使Xcode弹出”Load Bundles”的提示,可以重新load所有的插件.注意command末尾处的Xcode的版本号.&lt;/p&gt;

&lt;h2 id=&quot;添加删除行-快捷键-optd&quot;&gt;添加删除行 快捷键 Opt+D&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;修改配置文件(plist)权限&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ba&amp;#39;sh&quot;&gt;sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist
sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开plist文件进行修改&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;找到&lt;strong&gt;root&lt;/strong&gt;下的&lt;strong&gt;Deletions&lt;/strong&gt;,在&lt;strong&gt;Deletions&lt;/strong&gt;下添加一个Key: &lt;strong&gt;Delete Current Line&lt;/strong&gt; 值为&lt;strong&gt;deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启Xcode,设置快捷键&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Preference&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Key Bindings&lt;/strong&gt; ,找到 &lt;strong&gt;Delete Current Line&lt;/strong&gt; 选项,设置快捷键为 &lt;strong&gt;Opt+D&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;xcode-release-build-版本号自动增加&quot;&gt;Xcode Release Build 版本号自动增加&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$CONFIGURATION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; Release &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Bumping build number...&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;plist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PROJECT_DIR&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;INFOPLIST_FILE&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;buildnum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;/usr/libexec/PlistBuddy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Print CFBundleVersion&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;plist&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;buildnum&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;No build number in &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$plist&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;2
&lt;span class=&quot;k&quot;&gt;fi
 
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;buildnum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;expr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$buildnum&lt;/span&gt; + 1&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
/usr/libexec/Plistbuddy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Set CFBundleVersion &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$buildnum&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;plist&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Bumped build number to &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$buildnum&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;else
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$CONFIGURATION&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; build - Not bumping build number.&quot;&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用方法 Xcode–&amp;gt;Projet–&amp;gt;Target–&amp;gt;Build Phases–&amp;gt;”+”–&amp;gt;New Run Script Phase. 顺序放在Target Dependencies之后即可,尽量靠前.&lt;/p&gt;

&lt;p&gt;过程, 查找 Info.plist 文件的位置,使用工具 /usr/libexec/PlistBuddy 读取 CFBundleVersion 的值,+1后再写会 Info.plist 文件.&lt;/p&gt;</content><author><name></name></author><category term="Xcode" /><summary type="html">Alcatraz</summary></entry><entry><title type="html">lipo 使用简介</title><link href="/terminal/lipo/static%20library/2018/07/25/introduction-to-lipo.html" rel="alternate" type="text/html" title="lipo 使用简介" /><published>2018-07-25T17:25:25+08:00</published><updated>2018-07-25T17:25:25+08:00</updated><id>/terminal/lipo/static%20library/2018/07/25/introduction-to-lipo</id><content type="html" xml:base="/terminal/lipo/static%20library/2018/07/25/introduction-to-lipo.html">&lt;p&gt;最近在开发iOS SDK, 需要使用到lipo命令, 在此简单做一下记录:&lt;/p&gt;

&lt;p&gt;lipo的使用手册&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~  man lipo

LIPO&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                                                                     LIPO&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;



NAME
       lipo - create or operate on universal files

SYNOPSIS
       lipo   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-detailed_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-arch&lt;/span&gt;   arch_type  input_file]  ...   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
       input_file]  ...   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-arch_blank&lt;/span&gt;  arch_type]  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-thin&lt;/span&gt;   arch_type]
       &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-replace&lt;/span&gt;  arch_type  filename]  ...   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-remove&lt;/span&gt;  arch_type]  ...lio   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-extract&lt;/span&gt;
       arch_type] ...  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-extract_family&lt;/span&gt;  arch_type]  ...   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-verify_arch&lt;/span&gt;  arch_type
       ...]  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-output&lt;/span&gt; output_file] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-segalign&lt;/span&gt; arch_type value] ...

DESCRIPTION
       The  lipo  &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;creates or operates on &lt;span class=&quot;sb&quot;&gt;``&lt;/span&gt;universal&lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;multi-architecture&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
       files.  It only ever produces one output file, and never  alters  the  input
       file.  The operations that lipo performs are: listing the architecture types
       &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;a universal file&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; creating a single universal file from one or more input
       files&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  thinning  out  a single universal file to one specified architecture
       &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; and extracting, replacing, and/or removing  architectures  types  from
       the input file to create a single new universal output file.

       Only  one option can be specified, with the exception of &lt;span class=&quot;nt&quot;&gt;-arch&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;-arch_blank&lt;/span&gt;,
       &lt;span class=&quot;nt&quot;&gt;-output&lt;/span&gt;, and &lt;span class=&quot;nt&quot;&gt;-segalign&lt;/span&gt;, which are used &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;combination  with  other  options.
       The input_file argument is required, and only the &lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; option allows more
       than one input_file to be specified.  The &lt;span class=&quot;nt&quot;&gt;-output&lt;/span&gt; flag must be used,  except
       with the &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; and &lt;span class=&quot;nt&quot;&gt;-detailed_info&lt;/span&gt; flags.

       The  arch_type  arguments  may  be  any  of the supported architecture names
       listed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the man page &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单说,lipo就是用来操作universal file的命令,也可以说成是 fat file(因为这种文件确实比较大).在iOS中其实就是用来操作静态链接库(以.a为后缀的文件 )的命令.&lt;/p&gt;

&lt;p&gt;fat file一般是指包含两种及以上CPU架构的静态链接库&lt;/p&gt;

&lt;p&gt;lipo命令的功能:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;列举 .a文件 支持的architecture types.(架构类型,eg: armv7, armv7s, i386, x86_64, arm64)&lt;/li&gt;
  &lt;li&gt;合并多个 .a文件为一个.a文件&lt;/li&gt;
  &lt;li&gt;给一个 .a文件 瘦身.(剔除某一项CPU的架构类型)&lt;/li&gt;
  &lt;li&gt;提取, 替换或者移除 .a文件 文件中的某种架构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用lipo命令的注意事项&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除了 -arch, -arch_black, -output, -segalign选项外,其余的选项只能指定一个. 这几个选选项需要和其它的选项混合使用&lt;/li&gt;
  &lt;li&gt;除了 -create 选项外, 其余的选项只能指定一个input file作为参数&lt;/li&gt;
  &lt;li&gt;除了 -info 和 - detailed_info 选项外, 其余的选项必须指定 -output, 可以简写为 -o&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lipo命令的使用eg以wechatsdk-182作为举例对象&quot;&gt;lipo命令的使用eg,以WechatSDK 1.8.2作为举例对象&lt;/h3&gt;

&lt;h4 id=&quot;1查看a文件支持的cpu架构&quot;&gt;1.查看.a文件支持的CPU架构&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;lipo -info &lt;em&gt;input_file&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;lipo -detailed_info &lt;em&gt;input_file&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; libWeChatSDK.a 
Architectures &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the .a文件: libWeChatSDK.a are: i386 armv7 armv7s x86_64 arm64 

➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-detailed_info&lt;/span&gt; libWeChatSDK.a
Fat header &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;: libWeChatSDK.a
fat_magic 0xcafebabe
nfat_arch 5
architecture i386
    cputype CPU_TYPE_I386
    cpusubtype CPU_SUBTYPE_I386_ALL
    offset 108
    size 3247680
    align 2^2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
architecture armv7
    cputype CPU_TYPE_ARM
    cpusubtype CPU_SUBTYPE_ARM_V7
    offset 3247788
    size 3256064
    align 2^2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
architecture armv7s
    cputype CPU_TYPE_ARM
    cpusubtype CPU_SUBTYPE_ARM_V7S
    offset 6503852
    size 3255048
    align 2^2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
architecture x86_64
    cputype CPU_TYPE_X86_64
    cpusubtype CPU_SUBTYPE_X86_64_ALL
    offset 9758904
    size 3363856
    align 2^3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
architecture arm64
    cputype CPU_TYPE_ARM64
    cpusubtype CPU_SUBTYPE_ARM64_ALL
    offset 13122760
    size 3704912
    align 2^3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
➜  workspace 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2a文件-cpu架构拆分&quot;&gt;2..a文件 CPU架构拆分&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;lipo 静态库源文件路径 -thin CPU架构名称 -output 拆分后文件存放路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; libWeChatSDK-armv7 
input file libWeChatSDK-armv7 is not a fat file
Non-fat file: libWeChatSDK-armv7 is architecture: armv7

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3合并两个-a文件s&quot;&gt;3.合并两个 .a文件s&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;lipo -create 静态库存放路径1  静态库存放路径2 …  -output 整合后存放的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; libWeChatSDK-armv7 libWeChatSDK-i386 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; libWeChatSDK-i386+armv7
➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; libWeChatSDK-i386+armv7 
Architectures &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the fat file: libWeChatSDK-i386+armv7 are: armv7 i386 
➜  workspace 

➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; libWeChatSDK.a TYRZSD.a &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; combine-library.a
fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: libWeChatSDK.a and TYRZSD.a have the same architectures &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;i386&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; and can&lt;span class=&quot;s1&quot;&gt;&apos;t be in the same fat output file
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里需要注意一下,如果要合并的两个.a 文件含有相同的架构的话,会报如上的错误. 这种情况下怎么合并,可参照下一个章节&lt;/p&gt;

&lt;h4 id=&quot;4用-lipo-删除某些平台&quot;&gt;4.用 lipo 删除某些平台&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ lipo input_file -remove i386 -output output_file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo libWeChatSDK.a &lt;span class=&quot;nt&quot;&gt;-remove&lt;/span&gt; i386 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; libWeChatSDK-noi386
➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; libWeChatSDK-noi386 
Architectures &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the fat file: libWeChatSDK-noi386 are: armv7 armv7s x86_64 arm64 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;lipo命令合并a文件-detail&quot;&gt;lipo命令合并.a文件, detail&lt;/h3&gt;

&lt;h4 id=&quot;1分离出上述不同-a-文件单独支持的架构版本比如上述-libwechatsdka-和-tyrzsda-支持-armv7-armv7s-i386-x86_64-arm64那么就需要分离出单独支持armv7-armv7s-i386-x86_64-arm64的-a-文件&quot;&gt;1.分离出上述不同 .a 文件单独支持的架构版本，比如上述 libWeChatSDK.a 和 TYRZSD.a 支持 armv7 armv7s i386 x86_64 arm64，那么就需要分离出单独支持armv7 armv7s i386 x86_64 arm64的 .a 文件&lt;/h4&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo libWeChatSDK.a &lt;span class=&quot;nt&quot;&gt;-thin&lt;/span&gt; armv7 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; libWeChatSDK-armv7
➜  workspace lipo TYRZSD.a &lt;span class=&quot;nt&quot;&gt;-thin&lt;/span&gt; armv7 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; TYRZSD-armv7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2分离出a库的目标文件o&quot;&gt;2.分离出.a库的目标文件（.o)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt; ar -x 静态链接库&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为 .a 库分离出来的目标文件 .o  会很多, 所以, 最好是在工作空间根据不同的CPU建立不同的文件夹&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace &lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;armv7
➜  workspace &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;armv7 
➜  armv7 
➜  armv7 ar &lt;span class=&quot;nt&quot;&gt;-x&lt;/span&gt; ../libWeChatSDK-armv7 
➜  armv7 &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;AppCommunicate.o          MTAPlugin.o               OpenUDID.o
AppCommunicateData.o      MTAPluginIDFA.o           WXApi.o
GCDAsyncSocket.o          MTAPluginInstall.o        WXApiObject.o
MTA.o                     MTAPluginNotify.o         WXLogUtil.o
MTABaseFunction.o         MTAReachability.o         WapAuthHandler.o
MTAConfig.o               MTASendItem.o             WeChatApiUtil.o
MTADataConfigHolder.o     MTASocket.o               WeChatRegister.o
MTAEnv.o                  MTASpeedTestPlugin.o      WechatAuthSDK.o
MTAEvent.o                MTAStore.o                __.SYMDEF
MTAExtStoragePlugin.o     MTATempID.o               base64.o
MTAHelper.o               MTAWX.o
MTAMidPlugin.o            NSMutableArray+MTAQueue.o
➜  armv7 ar &lt;span class=&quot;nt&quot;&gt;-x&lt;/span&gt; ../TYRZSD-armv7 
➜  armv7 &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;AppCommunicate.o          MTAReachability.o         UAOpenInfo.o
AppCommunicateData.o      MTASendItem.o             UASession.o
GCDAsyncSocket.o          MTASocket.o               UATimer.o
MTA.o                     MTASpeedTestPlugin.o      UAUtil.o
MTABaseFunction.o         MTAStore.o                WXApi.o
MTAConfig.o               MTATempID.o               WXApiObject.o
MTADataConfigHolder.o     MTAWX.o                   WXLogUtil.o
MTAEnv.o                  NSMutableArray+MTAQueue.o WapAuthHandler.o
MTAEvent.o                OpenUDID.o                WeChatApiUtil.o
MTAExtStoragePlugin.o     TYRZSDK.o                 WeChatRegister.o
MTAHelper.o               TYRZSDK_vers.o            WechatAuthSDK.o
MTAMidPlugin.o            UAAuthViewController.o    __.SYMDEF
MTAPlugin.o               UACrypto.o                __.SYMDEF SORTED
MTAPluginIDFA.o           UAHTTP.o                  base64.o
MTAPluginInstall.o        UALogReport.o
MTAPluginNotify.o         UANetwork.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3对支持同个架构的o文件进行合并成静态库&quot;&gt;3.对支持同个架构的.o文件，进行合并成静态库。&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;libtool -static -o output_file *.o&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  armv7 libtool &lt;span class=&quot;nt&quot;&gt;-static&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; ../combine-library-armv7 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.o
➜  armv7 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; ..
TYRZSD-armv7          armv7                 libWeChatSDK-armv7    libWeChatSDK.a
TYRZSD.a              combine-library-armv7 libWeChatSDK-i386
➜  armv7 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4合成支持全部架构的通用静态库&quot;&gt;4.合成支持全部架构的通用静态库&lt;/h4&gt;

&lt;p&gt;如果之前的步骤不出错, 就会得到5个.a文件; combine-library-armv7 combine-library-armv7s combine-library-i386 combine-library-x86_64 combine-library-arm64&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; combine-library-armv7 combine-library-armv7s combine-library-i386 combine-library-x86_64 combine-library-arm64 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; combine-library
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​    combine-library 就是最终需要的 .a 库&lt;/p&gt;

&lt;h3 id=&quot;参考链接&quot;&gt;参考链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_26968709/article/details/51164104&quot;&gt;合并多个.a文件&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="terminal" /><category term="lipo" /><category term="static library" /><summary type="html">最近在开发iOS SDK, 需要使用到lipo命令, 在此简单做一下记录:</summary></entry></feed>