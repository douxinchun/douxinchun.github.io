<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-09-27T01:43:29+08:00</updated><id>/feed.xml</id><title type="html">Spring Notes</title><subtitle>Dying is the day worth living for</subtitle><entry><title type="html">Octopress 2.0 到 3.0 的迁移</title><link href="/octopress/2023/09/26/migrating-from-octopress-2-to-3.html" rel="alternate" type="text/html" title="Octopress 2.0 到 3.0 的迁移" /><published>2023-09-26T23:58:10+08:00</published><updated>2023-09-26T23:58:10+08:00</updated><id>/octopress/2023/09/26/migrating-from-octopress-2-to-3</id><content type="html" xml:base="/octopress/2023/09/26/migrating-from-octopress-2-to-3.html">&lt;p&gt;Octorpess 3.0 相比 Octopress 2.0 而言，有着不同的分发方式和维护方式。本文主要记录了我在从 Octopress 2.0 迁移到 3.0 时的过程和遇到的一些问题。&lt;/p&gt;

&lt;p&gt;迁移方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;建立一个新的 Octopress 3.0 博客项目&lt;/li&gt;
  &lt;li&gt;将旧的 Octopress 3.0 Blog 中的文章和配置移到 3.0 中&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;1-建立一个新的-octopress-30-博客项目&quot;&gt;1. 建立一个新的 Octopress 3.0 博客项目&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;a.安装最新版本的 Octopress&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;octorpess
 gem update octopress &lt;span class=&quot;c&quot;&gt;# 之前有过安装，可以更新 octopress 到最新版本&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里如果遇到了 write permission 的问题，可以使用 rbenv 来安装一个新的 ruby 版本，然后使用这个版本来安装 gem。具体可以参考 &lt;a href=&quot;https://douxinchun.github.io/2023/09/26/rbenv-notes.html&quot;&gt;rbenv notes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b.创建 Octopress 3.0 项目&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; octopress new Blog &lt;span class=&quot;c&quot;&gt;# 因为 octopress 不是安装在 macOS 内置的 ruby 版本中，所以指定此命令前，需要使用 rbenv 来指定 ruby 版本&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的目录就是 Octopress 3.0 初始化的目录结构。看起来和 2.0 中的 source 文件夹下的目录结构非常类似。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; .
├── 404.html
├── Gemfile
├── Gemfile.lock
├── README.md
├── _config.yml
├── _deploy.yml
├── _posts
│   ├── 2023-09-25-welcome-to-jekyll.markdown
├── _site
├── _templates
│   ├── draft
│   ├── page
│   └── post
├── about.markdown
└── index.markdown
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;c.查看 Hello world&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;，然后在浏览器中打开 http://localhost:4000/，可以看到 &lt;a href=&quot;https://douxinchun.github.io/jekyll/update/2023/09/25/welcome-to-jekyll.html&quot;&gt;Welcome to Jekyll!&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;Blog
jekyll serve &lt;span class=&quot;c&quot;&gt;# 按照提示可能需要加上前缀 bundle exec&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-迁移文章和图片&quot;&gt;2. 迁移文章和图片&lt;/h1&gt;

&lt;p&gt;a. 文章迁移&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; .../old_blog/source/_posts ./_posts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;b. 图片迁移&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; .../old_blog/source/images ./images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-配置插件&quot;&gt;3. 配置插件&lt;/h1&gt;

&lt;p&gt;Jekyll 有多种的添加插件的方式. &lt;a href=&quot;https://jekyllrb.com/docs/plugins/&quot;&gt;Plugins Installaton&lt;/a&gt;.&lt;br /&gt;
a. 将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.rb&lt;/code&gt; 文件放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_plugins&lt;/code&gt; 目录下&lt;br /&gt;
b. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 中添加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plugins&lt;/code&gt; 配置项&lt;br /&gt;
c. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt; 中添加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gem&lt;/code&gt; 依赖&lt;/p&gt;

&lt;p&gt;我这里选择了在 Gemfile 中添加依赖的方式, 这里添加时可以去除后面的版本号, 交由 bundle 来解决依赖版本冲突的问题.&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# If you have any plugins, put them here!&lt;/span&gt;
group :jekyll_plugins &lt;span class=&quot;k&quot;&gt;do
  &lt;/span&gt;gem &lt;span class=&quot;s2&quot;&gt;&quot;jekyll-feed&quot;&lt;/span&gt;
  gem &lt;span class=&quot;s2&quot;&gt;&quot;octopress&quot;&lt;/span&gt;
  gem &lt;span class=&quot;s2&quot;&gt;&quot;octopress-image-tag&quot;&lt;/span&gt;
  gem &lt;span class=&quot;s2&quot;&gt;&quot;kramdown-parser-gfm&quot;&lt;/span&gt;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-部署&quot;&gt;4. 部署&lt;/h1&gt;

&lt;p&gt;Octopress 2.0 时是使用 master 分支来发布 Blog, source 分支来管理 Blog. Octorpess 3.0 可以做到发布和管理的分离.&lt;br /&gt;
我采用的方式是, 使用一个单独的 Blog git 仓库来管理 Blog, 然后使用另外的 GitHub User Pages 仓库来发布 Blog.&lt;/p&gt;

&lt;p&gt;Octorpess 3.0 可以通过 S3, Rsync 或 GitHub pages 来进行部署发布.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopres deploy init git # 创建一个通过 GitHub Pages 来部署的配置文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行后, 会在项目的根目录下生成一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_deploy.yml&lt;/code&gt; 文件, 用来配置发布的相关信息.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
``` yml
method: git                               # How do you want to deploy? git, rsync or s3.
site_dir: _site                           # Location of your static site files.
git_url: git@github.com:xxxx/xxx.github.io.git  # remote repository url, e.g. git@github.com:username/repo_name
# Note on git_branch:
# If using GitHub project pages, set the branch to &apos;gh-pages&apos;.
# For GitHub user/organization pages or Heroku, set the branch to &apos;master&apos;.
#
git_branch: master                     # Git branch where static site files are commited
# remote_path:                            # Destination directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_deploy.yml&lt;/code&gt; 文件配置好以后, 执行&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build
octopress deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘.deploy’ 文件夹下的内容就是被自动部署到 GitHub Users Pages 仓库中.&lt;/p&gt;

&lt;p&gt;可以创建多个 deploy 配置文件, 然后再部署发布时通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-c&lt;/code&gt; 选项来指定配置文件.&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;octopress deploy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;your_deploy_config_file]
&lt;span class=&quot;c&quot;&gt;# -c, --config FILE  The path to your config file (default: _deploy.yml)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;github-userorganization-pages-和-project-pages-的区别&quot;&gt;Github User/Organization Pages 和 Project Pages 的区别&lt;/h2&gt;
&lt;h3 id=&quot;user-pages用户页面&quot;&gt;User Pages（用户页面）：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用途：User Pages 通常用于个人或组织的用户主页。每个 GitHub 用户都可以创建一个 User Page，它位于 https://username.github.io, 这个页面通常用于展示个人信息、作品、博客等内容.&lt;/li&gt;
  &lt;li&gt;存储库要求：为了创建 User Page，您需要创建一个名为 &lt;username&gt;.github.io 的公共存储库，并将网站内容提交到该存储库的 main 分支（以前是 master 分支）或 docs 文件夹。&lt;/username&gt;&lt;/li&gt;
  &lt;li&gt;自定义域名：User Pages 支持自定义域名，您可以将自己的域名绑定到 User Page 上(CNAME).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;project-pages项目页面&quot;&gt;Project Pages（项目页面）：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用途：Project Pages 用于特定 GitHub 存储库的项目文档、演示、站点或文档。每个存储库都可以启用 Project Pages 来托管与该存储库相关的网站。&lt;/li&gt;
  &lt;li&gt;存储库要求：要启用 Project Pages，您需要在存储库的设置中选择一个分支（通常是 gh-pages 分支）作为网站的源，并将网站内容提交到该分支。网站将位于 https://username.github.io/repository-name。&lt;/li&gt;
  &lt;li&gt;多个项目页面：对于每个 GitHub 存储库，您可以启用多个 Project Pages，每个页面可以使用不同的分支或路径来托管不同的网站。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-gitignore&quot;&gt;5. gitignore&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_site&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.deploy&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code-highlighter-cache&lt;/code&gt; (如果安装了 code-highlight 插件)都是生成的目录, 均可以放在 gitignore 中.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# .gitignore file content
_site
.code-highlighter-cache
.deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Octopress" /><summary type="html">Octorpess 3.0 相比 Octopress 2.0 而言，有着不同的分发方式和维护方式。本文主要记录了我在从 Octopress 2.0 迁移到 3.0 时的过程和遇到的一些问题。</summary></entry><entry><title type="html">rbenv 笔记</title><link href="/2023/09/26/rbenv-notes.html" rel="alternate" type="text/html" title="rbenv 笔记" /><published>2023-09-26T12:51:24+08:00</published><updated>2023-09-26T12:51:24+08:00</updated><id>/2023/09/26/rbenv-notes</id><content type="html" xml:base="/2023/09/26/rbenv-notes.html">&lt;h1 id=&quot;context&quot;&gt;Context&lt;/h1&gt;
&lt;p&gt;在 macOS 下使用 gem 安装 ruby 工具的时候，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gem install octopress&lt;/code&gt;，可能会遇到没有写权限的问题:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You don&apos;t have write permissions for the /Library/Ruby/Gems/x.x.x directory.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这是因为默认情况下使用的 ruby 是macOS内置的。macOS不允许用户修改系统内置的ruby。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;!!!强烈不建议通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chmod&lt;/code&gt; 的方式来强行修改系统文件和目录写入权限。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正确解决方法是使用ruby的版本管理工具(例如: rbenv)安装一个新的ruby版本，然后使用这个版本来安装gem。&lt;/p&gt;

&lt;h1 id=&quot;ruby-版本管理工具对比&quot;&gt;Ruby 版本管理工具对比&lt;/h1&gt;

&lt;p&gt;我用过的ruby版本管理工具有&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rbenv/rbenv&quot;&gt;rbenv&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://rvm.io/rvm/install&quot;&gt;rvm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两者相比，rbenv 有 global 和 local 的概念，可以设定全局的 ruby 版本（global）和在不同的项目下使用不同版本的 ruby（local）。 RVM 是在每次使用前手动的切换版本来使用不同的 ruby。&lt;/p&gt;

&lt;h1 id=&quot;install&quot;&gt;Install&lt;/h1&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;rbenv ruby-build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbenv init&lt;/code&gt;，按照提示，将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval &quot;$(rbenv init - zsh)&quot;&lt;/code&gt;添加到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;中。&lt;/p&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ rbenv init
&lt;span class=&quot;c&quot;&gt;# Load rbenv automatically by appending&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# the following to ~/.zshrc:&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;rbenv init - zsh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;usage&quot;&gt;Usage&lt;/h1&gt;
&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ rbenv &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 列出最新的的稳定版本的 ruby， install 命令是由 ruby-build 来提供的。&lt;/span&gt;
➜ rbenv &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;3.2.2 &lt;span class=&quot;c&quot;&gt;# 安装指定版本的 Ruby &lt;/span&gt;
➜ rbenv versions &lt;span class=&quot;c&quot;&gt;# 查看所有已安装的版本&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 查看和设定全局ruby版本&lt;/span&gt;
➜ rbenv global
system
➜ rbenv global x.x.x

&lt;span class=&quot;c&quot;&gt;# 查看和设定本地ruby版本, 存在本地 ruby 版本的项目会在项目根目录下生成一个 .ruby-version 文件&lt;/span&gt;
➜ rbenv &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;3.2.2
➜ rbenv &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;3.2.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;rbenv-工作原理&quot;&gt;rbenv 工作原理&lt;/h1&gt;
&lt;p&gt;rbenv 利用 $PATH 来劫持了 ruby 命令，然后根据当前目录下是否存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.ruby-version 文件来决定使用哪个 ruby 版本&lt;/code&gt;。如果找不到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.ruby-version&lt;/code&gt;，则会使用 global 版本。&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ which ruby
/Users/&amp;lt;username&amp;gt;/.rbenv/shims/ruby
➜ &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;
/Users/&amp;lt;username&amp;gt;/.rbenv/shims:/opt/homebrew/bin:...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">Context 在 macOS 下使用 gem 安装 ruby 工具的时候，例如gem install octopress，可能会遇到没有写权限的问题: You don&apos;t have write permissions for the /Library/Ruby/Gems/x.x.x directory. 这是因为默认情况下使用的 ruby 是macOS内置的。macOS不允许用户修改系统内置的ruby。</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="/jekyll/update/2023/09/25/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2023-09-25T20:47:59+08:00</published><updated>2023-09-25T20:47:59+08:00</updated><id>/jekyll/update/2023/09/25/welcome-to-jekyll</id><content type="html" xml:base="/jekyll/update/2023/09/25/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MONTH&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &apos;Hi, Tom&apos; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">OpenWRT下安装和配置shadowsocks</title><link href="/openwrt/shadowsocks/2021/03/02/install-shadowsocks-on-openwrt.html" rel="alternate" type="text/html" title="OpenWRT下安装和配置shadowsocks" /><published>2021-03-02T01:21:57+08:00</published><updated>2021-03-02T01:21:57+08:00</updated><id>/openwrt/shadowsocks/2021/03/02/install-shadowsocks-on-openwrt</id><content type="html" xml:base="/openwrt/shadowsocks/2021/03/02/install-shadowsocks-on-openwrt.html">&lt;p&gt;本文主要记录在openWRT下安装和配置shadowsocks的简要过程，便于日后查找和备忘。成功安装后可以实现透明代理，分流和防DNS污染。&lt;/p&gt;

&lt;h2 id=&quot;environment&quot;&gt;Environment&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;路由器型号：YouHua WR1200JS&lt;/li&gt;
  &lt;li&gt;固件版本：OpenWrt 19.07.4 r11208-ce6496d796 / LuCI openwrt-19.07 branch git-21.054.03371-3b137b5&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;拓扑图工作原理&quot;&gt;拓扑图+工作原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/blog_reference_image/2021/3/openwrt-shadowsocks-arch.png&quot; alt=&quot;topology map&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;dnsmasq是openwrt自带的一个软件，提供dns缓存，dhcp等功能。dnsmasq会将dns查询数据包转发给chinadns。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chinadns的上游DNS服务器有两个，一个是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;国内DNS&lt;/code&gt;，一个是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;（国外DNS）。&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;chinadns会同时向上游的DNS发送请求&lt;/li&gt;
      &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;先返回, 则直接采用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;的结果&lt;/li&gt;
      &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;国内DNS&lt;/code&gt;先返回, 分两种情况: 如果返回的结果是国内IP,则采用;否则丢弃并等待采用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;的结果&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.dns-forwarder 支持DNS TCP查询, 如果ISP的UDP不稳定, 丢包严重,可以使用dns-forwarder来代替&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ss-tunnel&lt;/code&gt;来进行DNS查询.&lt;/p&gt;

&lt;p&gt;4.shadowsocks 用于转发数据包, 科学上网. 关于shadowsocks的科普文章可查看这里: https://www.css3er.com/p/107.html&lt;/p&gt;

&lt;h2 id=&quot;相关的ipk软件包下载地址&quot;&gt;相关的ipk软件包下载地址&lt;/h2&gt;
&lt;p&gt;ipk软件包集合, 不同的CPU架构需要使用不同的软件包, CPU架构是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mipsel_24kc&lt;/code&gt;的话, 可以集中从这里下载.&lt;br /&gt;
链接: https://pan.baidu.com/s/14QDoTLqw-SEBZvQVQeVgvA 提取码: ugsc&lt;br /&gt;
其它的CPU架构, 可以去GitHub主页 -&amp;gt; Releases下载别人已经编译好的软件包, 如果没有, 只能自己下载openWRT的SDK, 自己进行编译.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shadowsocks-libev_3.3.5-1_mipsel_24kc.ipk&lt;/li&gt;
  &lt;li&gt;shadowsocks-libev-server_3.3.5-1_mipsel_24kc.ipk&lt;/li&gt;
  &lt;li&gt;ChinaDNS_1.3.3-1_mipsel_24kc.ipk&lt;/li&gt;
  &lt;li&gt;dns-forwarder_1.2.1-2_mipsel_24kc.ipk&lt;/li&gt;
  &lt;li&gt;luci-compat&lt;/li&gt;
  &lt;li&gt;luci-app-shadowsocks-without-ipset_1.9.1-1_all.ipk&lt;/li&gt;
  &lt;li&gt;luci-app-chinadns_1.6.2-1_all.ipk&lt;/li&gt;
  &lt;li&gt;luci-app-dns-forwarder_1.6.2-1_all.ipk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;链接: https://pan.baidu.com/s/14QDoTLqw-SEBZvQVQeVgvA 提取码: ugsc&lt;/p&gt;
&lt;h3 id=&quot;openwrt-shadowsocks&quot;&gt;openwrt-shadowsocks&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;: https://github.com/shadowsocks/openwrt-shadowsocks  &lt;br /&gt;
&lt;strong&gt;luci-app-shadowsocks&lt;/strong&gt;: https://github.com/shadowsocks/luci-app-shadowsocks&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;shadowsocks-libev&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 客户端/
 └── usr/
     └── bin/
         ├── ss-local       // 提供 SOCKS 正向代理, 在透明代理工作模式下用不到这个.
         ├── ss-redir       // 提供透明代理, 从 v2.2.0 开始支持 UDP
         └── ss-tunnel      // 提供端口转发, 可用于 DNS 查询
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;shadowsocks-libev-server&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;服务端/
└── usr/
    └── bin/
        └── ss-server      // 服务端可执行文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chinadns&quot;&gt;ChinaDNS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;: https://github.com/aa65535/openwrt-chinadns&lt;br /&gt;
&lt;strong&gt;原版ChinaDNS地址, 被请喝茶后已不再维护&lt;/strong&gt;:https://github.com/shadowsocks/ChinaDNS&lt;br /&gt;
&lt;strong&gt;luci-app-chinadns&lt;/strong&gt;: https://github.com/aa65535/openwrt-dist-luci&lt;/p&gt;

&lt;p&gt;更新 /etc/chinadns_chnroute.txt&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; wget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\| &apos;/CN\|ipv4/ { printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) }&apos; &amp;gt; /etc/chinadns_chnroute.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;###dns-forwarder
&lt;strong&gt;GitHub&lt;/strong&gt;: https://github.com/aa65535/openwrt-dns-forwarder&lt;br /&gt;
&lt;strong&gt;luci-app-dns-forwarder&lt;/strong&gt;: https://github.com/aa65535/openwrt-dist-luci&lt;/p&gt;

&lt;h3 id=&quot;dnsmasq&quot;&gt;dnsmasq&lt;/h3&gt;
&lt;p&gt;openWRT自带, 无需自行下载安装.&lt;br /&gt;
&lt;strong&gt;GitHub&lt;/strong&gt;: https://github.com/aa65535/openwrt-dnsmasq&lt;/p&gt;

&lt;h2 id=&quot;install&quot;&gt;Install&lt;/h2&gt;

&lt;p&gt;去软件项目的GitHub主页 -&amp;gt; Releases下面下载编译好的ipk, 如果没有符合的自己CPU架构的包, 则需要自己下载openWRT的SDK进行编译, 具体的教程各个主页上有.&lt;br /&gt;
查看CPU架构的命令 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opkg print-architecture&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# opkg print-architecture
&lt;span class=&quot;nb&quot;&gt;arch &lt;/span&gt;all 1
&lt;span class=&quot;nb&quot;&gt;arch &lt;/span&gt;noarch 1
&lt;span class=&quot;nb&quot;&gt;arch &lt;/span&gt;mipsel_24kc 10
root@OpenWrt:~#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下载完成有两种方式安装&lt;br /&gt;
方式一(建议): 通过web使用luci安装:
路径: 系统 -&amp;gt; Software -&amp;gt; Upload Package… -&amp;gt; Install&lt;/p&gt;

&lt;p&gt;方式二: 直接在线通过opkg命令来安装(注意使用方式需要提前更新好软件源, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opkg update&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;opkg install luci-compat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;config&quot;&gt;Config&lt;/h2&gt;

&lt;h3 id=&quot;方式一-使用luci来配置&quot;&gt;方式一, 使用luci来配置&lt;/h3&gt;
&lt;p&gt;登录luci.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;配置ss-server &lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;影梭&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务器管理&lt;/code&gt;, 添加自己的shadowsocks server&lt;/li&gt;
  &lt;li&gt;配置dnsmasq
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;网络&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DHCP/DNS&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;常规设置&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;本地服务器&lt;/code&gt;, 设置为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1#5353&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;网络&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DHCP/DNS&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HOSTS和解析文件&lt;/code&gt;, 勾选: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;忽略解析文件&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置ChinaDNS&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChinaDNS&lt;/code&gt;&lt;br /&gt;
 监听端口: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5353&lt;/code&gt;&lt;br /&gt;
 上游服务器修改为: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;114.114.114.114,127.0.0.1#5300&lt;/code&gt;&lt;br /&gt;
 这样&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;国内DNS&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;114.114.114.114&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可信DNS&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1#5353&lt;/code&gt;, 勾选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;启用&lt;/code&gt;, 保存设置&lt;/li&gt;
  &lt;li&gt;配置dns-forwarder&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DNS转发&lt;/code&gt;&lt;br /&gt;
 监听端口: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5300&lt;/code&gt; 
 监听地址: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.0.0.0&lt;/code&gt;&lt;br /&gt;
 上游 DNS: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8.8.8.8 &lt;/code&gt;
 勾选, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;启用&lt;/code&gt; 保存&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置shadowsocks 透明代理 + 访问控制&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;影梭&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;常规设置&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;透明代理&lt;/code&gt;&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;主服务器&lt;/code&gt;, 选择setp1中配置的ss-server, 保存.&lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务&lt;/code&gt;-&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;影梭&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;常规设置&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;访问控制&lt;/code&gt;-&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;外网区域 &lt;/code&gt; &lt;br /&gt;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;被忽略IP列表&lt;/code&gt;, 选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChinaDNS路由表&lt;/code&gt;, 保存设置.  注意这里的优先级: (走代理IP列表 = 强制走代理IP) &amp;gt; (额外被忽略IP = 被忽略IP列表)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;保存并应用&lt;/code&gt; 所有配置, reboot openWRT&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;方式二-直接编辑etcconfig目录下的文件&quot;&gt;方式二, 直接编辑/etc/config目录下的文件&lt;/h3&gt;
&lt;p&gt;课外阅读: UCI System
&lt;a href=&quot;https://oldwiki.archive.openwrt.org/doc/uci&quot;&gt;UCI system&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The abbreviation UCI stands for Unified Configuration Interface and is intended to centralize the configuration of OpenWrt.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;etcconfigshadowsocks&quot;&gt;/etc/config/shadowsocks&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# cat /etc/config/shadowsocks

config general
	option startup_delay &apos;0&apos;

config transparent_proxy
	option udp_relay_server &apos;nil&apos;
	option local_port &apos;1234&apos;
	option mtu &apos;1492&apos;
	list main_server &apos;cfg054a8f&apos;

config socks5_proxy
	option local_port &apos;1080&apos;
	option mtu &apos;1492&apos;
	list server &apos;nil&apos;

config port_forward
	option local_port &apos;5300&apos;
	option mtu &apos;1492&apos;
	option destination &apos;8.8.8.8:53&apos;
	list server &apos;nil&apos;

config servers
	option fast_open &apos;0&apos;
	option no_delay &apos;0&apos;
	option timeout &apos;60&apos;
	option server &apos;服务器地址,注意luci下这里只能是ip&apos;
	option server_port &apos;端口&apos;
	option password &apos;密码&apos;
	option encrypt_method &apos;加密方式&apos;
	option alias &apos;ss服务别名&apos;

config access_control
	option self_proxy &apos;1&apos;
	option lan_target &apos;SS_SPEC_WAN_AC&apos;
	option wan_bp_list &apos;/etc/chinadns_chnroute.txt&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;etcconfigdhcp&quot;&gt;/etc/config/dhcp&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# cat /etc/config/dhcp

config dnsmasq
	option domainneeded &apos;1&apos;
	option localise_queries &apos;1&apos;
	option rebind_protection &apos;1&apos;
	option rebind_localhost &apos;1&apos;
	option domain &apos;lan&apos;
	option expandhosts &apos;1&apos;
	option authoritative &apos;1&apos;
	option readethers &apos;1&apos;
	option leasefile &apos;/tmp/dhcp.leases&apos;
	option localservice &apos;1&apos;
	option local &apos;127.0.0.1#5353&apos;
	option noresolv &apos;1&apos;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;etcconfigchinadns&quot;&gt;/etc/config/chinadns&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# cat /etc/config/chinadns

config chinadns
	option chnroute &apos;/etc/chinadns_chnroute.txt&apos;
	option addr &apos;0.0.0.0&apos;
	option port &apos;5353&apos;
	option bidirectional &apos;1&apos;
	option server &apos;114.114.114.114,127.0.0.1#5300&apos;
	option enable &apos;1&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;etcconfigdns-forwarder&quot;&gt;/etc/config/dns-forwarder&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# cat /etc/config/dns-forwarder

config dns-forwarder
	option listen_addr &apos;0.0.0.0&apos;
	option listen_port &apos;5300&apos;
	option enable &apos;1&apos;
	option dns_servers &apos;8.8.8.8&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;验证配置是否生效&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# netstat &lt;span class=&quot;nt&quot;&gt;-lpn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;ss
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:1234            0.0.0.0:&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;               LISTEN      13469/ss-redir
root@OpenWrt:~# netstat &lt;span class=&quot;nt&quot;&gt;-lpn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;5353
udp        0      0 0.0.0.0:5353            0.0.0.0:&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                           1438/chinadns
root@OpenWrt:~# netstat &lt;span class=&quot;nt&quot;&gt;-lpn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;5300
udp        0      0 0.0.0.0:5300            0.0.0.0:&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                           12993/dns-forwarder
root@OpenWrt:~# netstat &lt;span class=&quot;nt&quot;&gt;-lpn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;53
tcp        0      0 127.0.0.1:53            0.0.0.0:&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;               LISTEN      2254/dnsmasq
...

root@OpenWrt:~# nslookup google.com 127.0.0.1#5353
Server:		127.0.0.1
Address:	127.0.0.1#5353

Name:      google.com
Address 1: 142.250.72.238
Address 2: 2607:f8b0:4007:80d::200e
root@OpenWrt:~#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;issues&quot;&gt;Issues&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;luci-app-shadowsocks 不支持domain的方式配置ss-server, 需要使用IP地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Link
https://www.youtube.com/watch?v=2SPQYsMmltE&amp;amp;t=317s - 十年老程 openwrt shadowsocks安装配置对应的视频教程
http://snlcw.com/305.html - 上述教程对应的blog地址. 
https://www.youtube.com/channel/UCgo7XWK6MQBgKt0gBI6x3CA/videos - 十年老程的Youtube专栏，里面有各种科学上网的视频教程. 
https://openwrt.org/docs/guide-user/base-system/dhcp_configuration&lt;/p&gt;</content><author><name></name></author><category term="openwrt" /><category term="shadowsocks" /><summary type="html">本文主要记录在openWRT下安装和配置shadowsocks的简要过程，便于日后查找和备忘。成功安装后可以实现透明代理，分流和防DNS污染。</summary></entry><entry><title type="html">gitignore 文件屏蔽规则</title><link href="/git/2019/01/31/rule-of-gitignore-file.html" rel="alternate" type="text/html" title="gitignore 文件屏蔽规则" /><published>2019-01-31T18:10:28+08:00</published><updated>2019-01-31T18:10:28+08:00</updated><id>/git/2019/01/31/rule-of-gitignore-file</id><content type="html" xml:base="/git/2019/01/31/rule-of-gitignore-file.html">&lt;p&gt;文件名： &lt;strong&gt;.gitignore&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;位置：&lt;/p&gt;

&lt;p&gt;global 当前用户的主目录下 ~  一般是自己使用不和别人share 该设置对所有的本地仓库都起作用&lt;/p&gt;

&lt;p&gt;local 当前仓库的主目录下 一般需要加入到git库的版本控制中，需要和别人share&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git config&lt;/strong&gt; 中的 &lt;strong&gt;core.excludesfile&lt;/strong&gt; 可以指定 .gitignore 文件&lt;/p&gt;

&lt;p&gt;格式规范如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有空行和#开头的行都会被忽略&lt;/li&gt;
  &lt;li&gt;文件或者目录前加 / 表示仓库根目录下的对应文件，子目录下的同名文件不忽略&lt;/li&gt;
  &lt;li&gt;文件或者目录后加 / 表示要忽略的是目录，不加 / 表示文件和目录都忽略&lt;/li&gt;
  &lt;li&gt;所有模式取反可以在最前面加 ！&lt;/li&gt;
  &lt;li&gt;可以使用标准的 &lt;strong&gt;glob&lt;/strong&gt; 模式匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;glob 模式是一种简化了的正则表达式，使用于shell&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;* 匹配零个或者多个任意字符&lt;/li&gt;
  &lt;li&gt;？匹配任意一个字符&lt;/li&gt;
  &lt;li&gt;[abc] 匹配任意一个方括号中的字符&lt;/li&gt;
  &lt;li&gt;[0-9] 短线表示范围，表示匹配任意一个0到9的数字&lt;/li&gt;
  &lt;li&gt;{string1,string2} 大括号代表可选的字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;匹配时，下面的条目可以覆盖上&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;readme.md       &lt;span class=&quot;c&quot;&gt;# 屏蔽仓库中所有名为 readme.md 的文件&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;/readme.md     &lt;span class=&quot;c&quot;&gt;# 在上一条屏蔽规则的条件下，不屏蔽仓库根目录下的 readme.md 文件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;link&quot;&gt;Link&lt;/h2&gt;
&lt;p&gt;https://www.jianshu.com/p/13612fb4b224
https://www.cnblogs.com/qwertWZ/archive/2013/03/26/2982231.html&lt;/p&gt;</content><author><name></name></author><category term="git" /><summary type="html">文件名： .gitignore</summary></entry><entry><title type="html">C 语言函数指针小测试</title><link href="/function%20pointer/c/2018/09/28/function-pointer-test.html" rel="alternate" type="text/html" title="C 语言函数指针小测试" /><published>2018-09-28T15:10:54+08:00</published><updated>2018-09-28T15:10:54+08:00</updated><id>/function%20pointer/c/2018/09/28/function-pointer-test</id><content type="html" xml:base="/function%20pointer/c/2018/09/28/function-pointer-test.html">&lt;p&gt;首先看一道趣味题,来源:https://www.v2ex.com/t/492705&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
[] 
printf(&quot;%p\n&quot;, **********************p);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 [] 标记内加入一条语句，使得：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;程序编译通过，无错误（警告随意）；链接通过，无错误（警告随意）&lt;/li&gt;
  &lt;li&gt;程序能够运行，无崩溃和运行时错误&lt;/li&gt;
  &lt;li&gt;源代码为.c 文件&lt;/li&gt;
  &lt;li&gt;如果用 vs，则使用 Release 配置；用 gcc 也行&lt;/li&gt;
  &lt;li&gt;加入的语句不能忽略分号&lt;/li&gt;
  &lt;li&gt;printf 一句必须能够正常输出内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;答案如下表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;int(*p)();&lt;/th&gt;
      &lt;th&gt;10个字符&lt;/th&gt;
      &lt;th&gt;兼容 gcc、g++、vs&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;int p(){}&lt;/td&gt;
      &lt;td&gt;9个字符&lt;/td&gt;
      &lt;td&gt;兼容 gcc，不兼容 g++、vs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;p();}p(){&lt;/td&gt;
      &lt;td&gt;9个字符&lt;/td&gt;
      &lt;td&gt;兼容 gcc、g++、vs&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;本文主要针对第一种答案来说明一下为什么函数指针可以被无线次解引用.&lt;/p&gt;

&lt;h2 id=&quot;-&quot;&gt;&amp;amp; *&lt;/h2&gt;

&lt;p&gt;说到指针,首先就一定要介绍两个操作符.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;amp; 地址操作符(address operators) 单目前缀操作符,操作数为跟在后面的表达式. eg:&amp;amp;a,表示取操作数a的地址,也可以理解为取对象a的地址,或者取变量a的地址等等.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 在64处理器的系统模式下,地址的长度为8个字节
int a;
printf(&quot;sizeof(&amp;amp;a)=%d\n&quot;,sizeof(&amp;amp;a));

**********result**********
sizeof(&amp;amp;a)=8
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;* 间接操作符 (indirection operators) 单目前缀操作数,同样也是跟在后面的表达式为操作数,可以使用间接操作符通过指针对象间接地访问它所指向对象的值. eg: *a,表示取&lt;strong&gt;指针对象&lt;/strong&gt;a中存的地址所指向的值. (这里的表达非常绕,下面举个例子,请自行脑补)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*a的举例: 超市的储物柜,每个格子都有一个唯一对应的条形码,我们认为这就是每个格子的地址,格子本身就是实实在在的三维空间,是可以放物品的.现在有两个格子a格和b格,我们把背包放进了b格,然后把印有b格条码的纸条放进了a格, 那么,a格就相当于一个指针变量, b格就相当于一个普通的变量. *a的意思就是 分两步,第一步找到a格,取出a格中存放的条码,第二步,按照条码找到b格,取出b格中的背包.  最终简化一下, *a就是背包.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;int b = 666;
int *a;
a = &amp;amp;b;
printf(&quot;*a=%d sizeof(*a)=%d\n&quot;,*a,sizeof(*a));

**********result**********
*a=666 sizeof(*a)=4
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于间接操作符,需要特别注意的有两点:&lt;/p&gt;

  &lt;p&gt;第一,间接操作符(*)与用来声明之神类别对象的”*“不属于同种功能,虽然它们两者确实是同一个字符,unicode码点都是 \u002a&lt;/p&gt;

  &lt;p&gt;第二,间接操作符只作用于指针类型的对象,也就是说简介操作符的的操作数必须是一个指针类型的对象.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;取地址与解引用&quot;&gt;“取地址”与”解引用”&lt;/h2&gt;

&lt;p&gt;通俗的讲,对一个变量的 &amp;amp; 操作称为”取地址”&lt;/p&gt;

&lt;p&gt;对一个指针变量的 * 操作称作”解引用”.&lt;/p&gt;

&lt;p&gt;换一种角度去理解解引用，”*“的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。这个值可以是另一个地址。&lt;/p&gt;

&lt;h2 id=&quot;多级指针&quot;&gt;多级指针.&lt;/h2&gt;

&lt;p&gt;如果一个指针变量存的是一个普通变量的地址,比如 int *a,只能存放一个整型变量的地址,那么这个指针叫做一级指针;如果一个指针变量存放的是另一个指针变量的地址,比如 int **, 里面存放的是一个(int *a)类型的指针变量的地址,那么这个指针变量叫二级指针,依次往下推,可以有三级指针,四级指针….直到多级指针.&lt;/p&gt;

&lt;h2 id=&quot;函数指针&quot;&gt;函数指针&lt;/h2&gt;

&lt;p&gt;简单理解就是指向函数地址的指针。比如我们声明的一个C函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void func(void);
//函数调用
func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么对于函数调用表达式 func() 而言， func后缀表达式就已经表示了一个指向返回类型为void，且参数列表为空的函数的指针：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;void (*) (void)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;函数指针的通用表达形式为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;返回类型 （* cv限定符 ）（形参列表）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，cv限定符为可选项。&lt;/p&gt;

&lt;p&gt;直接上code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void (*p)();
p=&amp;amp;func;

printf(&quot;sizeof(func)= %d\n&quot;,sizeof(func));
printf(&quot;sizeof(p)= %d\n&quot;,sizeof(p));

printf(&quot;func\t %p = %p\n&quot;,&amp;amp;func,func);
printf(&quot;p *p\t %p = %p = %p\n&quot;,&amp;amp;p,p,*p);

printf(&quot;p多次解引用 %p\n&quot;, **********************p);

void (*pNull)();
printf(&quot;pNull *p\t %p = %p = %p\n&quot;,&amp;amp;pNull,pNull,*pNull);
printf(&quot;pNull多次解引用 %p\n&quot;, **********************p);

**********result**********
sizeof(func)= 1
sizeof(p)= 8
func	 0x100000df0 = 0x100000df0
p *p	 0x7ffeefbff568 = 0x100000df0 = 0x100000df0
p多次解引用 0x100000df0
pNull *p	 0x7ffeefbff560 = 0x0 = 0x0
pNull多次解引用 0x0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;函数指针变量在64位系统下的大小是8，函数指针常量的大小是1。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数指针常量中存储的内容是自身的地址（这是为什么函数指针可以被无限次解引用的关键，因为解到最后一层以后，继续解就陷入了”自己找自己“的循环）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;未赋值的函数指针变量默认指向的是地址是0x0，对存储在该地址的指针对象解引用的结果依旧是0x0，所以可以认为0x0地址的内存单元中存的是地址0x0（此处上可能有误，尚需以后讨论）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="function pointer" /><category term="c" /><summary type="html">首先看一道趣味题,来源:https://www.v2ex.com/t/492705</summary></entry><entry><title type="html">Chrome中使用英文关键词搜索中文结果</title><link href="/google/2018/09/20/tips-of-google-search.html" rel="alternate" type="text/html" title="Chrome中使用英文关键词搜索中文结果" /><published>2018-09-20T17:28:46+08:00</published><updated>2018-09-20T17:28:46+08:00</updated><id>/google/2018/09/20/tips-of-google-search</id><content type="html" xml:base="/google/2018/09/20/tips-of-google-search.html">&lt;p&gt;在国内,访问Google需要用一点小技巧.有时候,我们使用英文的关键词,但是搜索结果想要查看中文的.由于的这点小技巧的原因,导致Google不能够正确的识别国家和地区的设置.&lt;/p&gt;

&lt;p&gt;知乎中有一篇帖子介绍了几个修改的方法: &lt;a href=&quot;https://www.zhihu.com/question/37498305&quot;&gt;如何修改Chrome里Google搜索的国家和地区设置？&lt;/a&gt; 这里我采取另外的一种方法来实现.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;chrome地址栏中输入 chrome://settings/searchEngines 打开chrome中的管理搜索引擎&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;复制默认搜索引擎的查询网址:   {google:baseURL}search?q=%s&amp;amp;{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQueryStats}{google:searchFieldtrialParameter}{google:iOSSearchLanguage}{google:searchClient}{google:sourceId}{google:contextualSearchVersion}ie={inputEncoding}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在上面的String后面追加 &amp;amp;lr=lang_zh-CN, 然后添加一个搜索引擎, 
名字:  Google 中文
关键词: cn
查询网址:  {google:baseURL}search?q=%s&amp;amp;{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQueryStats}{google:searchFieldtrialParameter}{google:iOSSearchLanguage}{google:searchClient}{google:sourceId}{google:contextualSearchVersion}ie={inputEncoding}&amp;amp;lr=lang_zh-CN&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://p64xrfkn6.bkt.clouddn.com/blog_reference_image/2018/9/1-1.png&quot; alt=&quot;增加搜索引擎&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.保存后,在地址栏中输入 cn+空格 ,然后再输入搜索关键字,OK,展示的搜索结果已经变成中文结果了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p64xrfkn6.bkt.clouddn.com/blog_reference_image/2018/9/1-2.png&quot; alt=&quot;使用介绍&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="google" /><summary type="html">在国内,访问Google需要用一点小技巧.有时候,我们使用英文的关键词,但是搜索结果想要查看中文的.由于的这点小技巧的原因,导致Google不能够正确的识别国家和地区的设置.</summary></entry><entry><title type="html">Xcode 使用技巧</title><link href="/xcode/2018/09/18/tips-of-xcode.html" rel="alternate" type="text/html" title="Xcode 使用技巧" /><published>2018-09-18T17:03:09+08:00</published><updated>2018-09-18T17:03:09+08:00</updated><id>/xcode/2018/09/18/tips-of-xcode</id><content type="html" xml:base="/xcode/2018/09/18/tips-of-xcode.html">&lt;h2 id=&quot;alcatraz&quot;&gt;Alcatraz&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/alcatraz/Alcatraz&quot;&gt;Alcatraz&lt;/a&gt;是一款开源的用于Xcode7的插件管理工具.Xcode8以及以后版本需要配合下面的工具来使用.&lt;/p&gt;

&lt;h2 id=&quot;update_xcode_plugins&quot;&gt;update_xcode_plugins&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/inket/update_xcode_plugins&quot;&gt;update_xcode_plugins&lt;/a&gt;可以为Xcode中安装的插件添加UUID, 同时还能够 为Xcode8以及以上的版本解除签名,这样就可以随心所欲的使用各种Xcode插件了.&lt;/p&gt;

&lt;h2 id=&quot;reset-xcodes-load-bundles-warning&quot;&gt;Reset Xcode’s “Load Bundles” warning&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-10.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行该命令,重启Xcode,可以使Xcode弹出”Load Bundles”的提示,可以重新load所有的插件.注意command末尾处的Xcode的版本号.&lt;/p&gt;

&lt;h2 id=&quot;添加删除行-快捷键-optd&quot;&gt;添加删除行 快捷键 Opt+D&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;修改配置文件(plist)权限&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ba&amp;#39;sh&quot;&gt;sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist
sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开plist文件进行修改&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;找到&lt;strong&gt;root&lt;/strong&gt;下的&lt;strong&gt;Deletions&lt;/strong&gt;,在&lt;strong&gt;Deletions&lt;/strong&gt;下添加一个Key: &lt;strong&gt;Delete Current Line&lt;/strong&gt; 值为&lt;strong&gt;deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启Xcode,设置快捷键&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Preference&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Key Bindings&lt;/strong&gt; ,找到 &lt;strong&gt;Delete Current Line&lt;/strong&gt; 选项,设置快捷键为 &lt;strong&gt;Opt+D&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;xcode-release-build-版本号自动增加&quot;&gt;Xcode Release Build 版本号自动增加&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$CONFIGURATION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; Release &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Bumping build number...&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;plist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PROJECT_DIR&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;INFOPLIST_FILE&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;buildnum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;/usr/libexec/PlistBuddy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Print CFBundleVersion&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;plist&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;buildnum&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;No build number in &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$plist&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;2
&lt;span class=&quot;k&quot;&gt;fi
 
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;buildnum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;expr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$buildnum&lt;/span&gt; + 1&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
/usr/libexec/Plistbuddy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Set CFBundleVersion &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$buildnum&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;plist&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Bumped build number to &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$buildnum&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;else
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$CONFIGURATION&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; build - Not bumping build number.&quot;&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用方法 Xcode–&amp;gt;Projet–&amp;gt;Target–&amp;gt;Build Phases–&amp;gt;”+”–&amp;gt;New Run Script Phase. 顺序放在Target Dependencies之后即可,尽量靠前.&lt;/p&gt;

&lt;p&gt;过程, 查找 Info.plist 文件的位置,使用工具 /usr/libexec/PlistBuddy 读取 CFBundleVersion 的值,+1后再写会 Info.plist 文件.&lt;/p&gt;</content><author><name></name></author><category term="Xcode" /><summary type="html">Alcatraz</summary></entry><entry><title type="html">lipo 使用简介</title><link href="/terminal/lipo/static%20library/2018/07/25/introduction-to-lipo.html" rel="alternate" type="text/html" title="lipo 使用简介" /><published>2018-07-25T17:25:25+08:00</published><updated>2018-07-25T17:25:25+08:00</updated><id>/terminal/lipo/static%20library/2018/07/25/introduction-to-lipo</id><content type="html" xml:base="/terminal/lipo/static%20library/2018/07/25/introduction-to-lipo.html">&lt;p&gt;最近在开发iOS SDK, 需要使用到lipo命令, 在此简单做一下记录:&lt;/p&gt;

&lt;p&gt;lipo的使用手册&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~  man lipo

LIPO&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                                                                     LIPO&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;



NAME
       lipo - create or operate on universal files

SYNOPSIS
       lipo   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-detailed_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-arch&lt;/span&gt;   arch_type  input_file]  ...   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
       input_file]  ...   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-arch_blank&lt;/span&gt;  arch_type]  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-thin&lt;/span&gt;   arch_type]
       &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-replace&lt;/span&gt;  arch_type  filename]  ...   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-remove&lt;/span&gt;  arch_type]  ...lio   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-extract&lt;/span&gt;
       arch_type] ...  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-extract_family&lt;/span&gt;  arch_type]  ...   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-verify_arch&lt;/span&gt;  arch_type
       ...]  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-output&lt;/span&gt; output_file] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-segalign&lt;/span&gt; arch_type value] ...

DESCRIPTION
       The  lipo  &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;creates or operates on &lt;span class=&quot;sb&quot;&gt;``&lt;/span&gt;universal&lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;multi-architecture&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
       files.  It only ever produces one output file, and never  alters  the  input
       file.  The operations that lipo performs are: listing the architecture types
       &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;a universal file&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; creating a single universal file from one or more input
       files&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  thinning  out  a single universal file to one specified architecture
       &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; and extracting, replacing, and/or removing  architectures  types  from
       the input file to create a single new universal output file.

       Only  one option can be specified, with the exception of &lt;span class=&quot;nt&quot;&gt;-arch&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;-arch_blank&lt;/span&gt;,
       &lt;span class=&quot;nt&quot;&gt;-output&lt;/span&gt;, and &lt;span class=&quot;nt&quot;&gt;-segalign&lt;/span&gt;, which are used &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;combination  with  other  options.
       The input_file argument is required, and only the &lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; option allows more
       than one input_file to be specified.  The &lt;span class=&quot;nt&quot;&gt;-output&lt;/span&gt; flag must be used,  except
       with the &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; and &lt;span class=&quot;nt&quot;&gt;-detailed_info&lt;/span&gt; flags.

       The  arch_type  arguments  may  be  any  of the supported architecture names
       listed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the man page &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单说,lipo就是用来操作universal file的命令,也可以说成是 fat file(因为这种文件确实比较大).在iOS中其实就是用来操作静态链接库(以.a为后缀的文件 )的命令.&lt;/p&gt;

&lt;p&gt;fat file一般是指包含两种及以上CPU架构的静态链接库&lt;/p&gt;

&lt;p&gt;lipo命令的功能:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;列举 .a文件 支持的architecture types.(架构类型,eg: armv7, armv7s, i386, x86_64, arm64)&lt;/li&gt;
  &lt;li&gt;合并多个 .a文件为一个.a文件&lt;/li&gt;
  &lt;li&gt;给一个 .a文件 瘦身.(剔除某一项CPU的架构类型)&lt;/li&gt;
  &lt;li&gt;提取, 替换或者移除 .a文件 文件中的某种架构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用lipo命令的注意事项&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除了 -arch, -arch_black, -output, -segalign选项外,其余的选项只能指定一个. 这几个选选项需要和其它的选项混合使用&lt;/li&gt;
  &lt;li&gt;除了 -create 选项外, 其余的选项只能指定一个input file作为参数&lt;/li&gt;
  &lt;li&gt;除了 -info 和 - detailed_info 选项外, 其余的选项必须指定 -output, 可以简写为 -o&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lipo命令的使用eg以wechatsdk-182作为举例对象&quot;&gt;lipo命令的使用eg,以WechatSDK 1.8.2作为举例对象&lt;/h3&gt;

&lt;h4 id=&quot;1查看a文件支持的cpu架构&quot;&gt;1.查看.a文件支持的CPU架构&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;lipo -info &lt;em&gt;input_file&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;lipo -detailed_info &lt;em&gt;input_file&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; libWeChatSDK.a 
Architectures &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the .a文件: libWeChatSDK.a are: i386 armv7 armv7s x86_64 arm64 

➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-detailed_info&lt;/span&gt; libWeChatSDK.a
Fat header &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;: libWeChatSDK.a
fat_magic 0xcafebabe
nfat_arch 5
architecture i386
    cputype CPU_TYPE_I386
    cpusubtype CPU_SUBTYPE_I386_ALL
    offset 108
    size 3247680
    align 2^2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
architecture armv7
    cputype CPU_TYPE_ARM
    cpusubtype CPU_SUBTYPE_ARM_V7
    offset 3247788
    size 3256064
    align 2^2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
architecture armv7s
    cputype CPU_TYPE_ARM
    cpusubtype CPU_SUBTYPE_ARM_V7S
    offset 6503852
    size 3255048
    align 2^2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
architecture x86_64
    cputype CPU_TYPE_X86_64
    cpusubtype CPU_SUBTYPE_X86_64_ALL
    offset 9758904
    size 3363856
    align 2^3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
architecture arm64
    cputype CPU_TYPE_ARM64
    cpusubtype CPU_SUBTYPE_ARM64_ALL
    offset 13122760
    size 3704912
    align 2^3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
➜  workspace 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2a文件-cpu架构拆分&quot;&gt;2..a文件 CPU架构拆分&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;lipo 静态库源文件路径 -thin CPU架构名称 -output 拆分后文件存放路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; libWeChatSDK-armv7 
input file libWeChatSDK-armv7 is not a fat file
Non-fat file: libWeChatSDK-armv7 is architecture: armv7

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3合并两个-a文件s&quot;&gt;3.合并两个 .a文件s&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;lipo -create 静态库存放路径1  静态库存放路径2 …  -output 整合后存放的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; libWeChatSDK-armv7 libWeChatSDK-i386 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; libWeChatSDK-i386+armv7
➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; libWeChatSDK-i386+armv7 
Architectures &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the fat file: libWeChatSDK-i386+armv7 are: armv7 i386 
➜  workspace 

➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; libWeChatSDK.a TYRZSD.a &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; combine-library.a
fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: libWeChatSDK.a and TYRZSD.a have the same architectures &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;i386&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; and can&lt;span class=&quot;s1&quot;&gt;&apos;t be in the same fat output file
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里需要注意一下,如果要合并的两个.a 文件含有相同的架构的话,会报如上的错误. 这种情况下怎么合并,可参照下一个章节&lt;/p&gt;

&lt;h4 id=&quot;4用-lipo-删除某些平台&quot;&gt;4.用 lipo 删除某些平台&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ lipo input_file -remove i386 -output output_file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo libWeChatSDK.a &lt;span class=&quot;nt&quot;&gt;-remove&lt;/span&gt; i386 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; libWeChatSDK-noi386
➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; libWeChatSDK-noi386 
Architectures &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the fat file: libWeChatSDK-noi386 are: armv7 armv7s x86_64 arm64 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;lipo命令合并a文件-detail&quot;&gt;lipo命令合并.a文件, detail&lt;/h3&gt;

&lt;h4 id=&quot;1分离出上述不同-a-文件单独支持的架构版本比如上述-libwechatsdka-和-tyrzsda-支持-armv7-armv7s-i386-x86_64-arm64那么就需要分离出单独支持armv7-armv7s-i386-x86_64-arm64的-a-文件&quot;&gt;1.分离出上述不同 .a 文件单独支持的架构版本，比如上述 libWeChatSDK.a 和 TYRZSD.a 支持 armv7 armv7s i386 x86_64 arm64，那么就需要分离出单独支持armv7 armv7s i386 x86_64 arm64的 .a 文件&lt;/h4&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo libWeChatSDK.a &lt;span class=&quot;nt&quot;&gt;-thin&lt;/span&gt; armv7 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; libWeChatSDK-armv7
➜  workspace lipo TYRZSD.a &lt;span class=&quot;nt&quot;&gt;-thin&lt;/span&gt; armv7 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; TYRZSD-armv7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2分离出a库的目标文件o&quot;&gt;2.分离出.a库的目标文件（.o)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt; ar -x 静态链接库&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为 .a 库分离出来的目标文件 .o  会很多, 所以, 最好是在工作空间根据不同的CPU建立不同的文件夹&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace &lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;armv7
➜  workspace &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;armv7 
➜  armv7 
➜  armv7 ar &lt;span class=&quot;nt&quot;&gt;-x&lt;/span&gt; ../libWeChatSDK-armv7 
➜  armv7 &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;AppCommunicate.o          MTAPlugin.o               OpenUDID.o
AppCommunicateData.o      MTAPluginIDFA.o           WXApi.o
GCDAsyncSocket.o          MTAPluginInstall.o        WXApiObject.o
MTA.o                     MTAPluginNotify.o         WXLogUtil.o
MTABaseFunction.o         MTAReachability.o         WapAuthHandler.o
MTAConfig.o               MTASendItem.o             WeChatApiUtil.o
MTADataConfigHolder.o     MTASocket.o               WeChatRegister.o
MTAEnv.o                  MTASpeedTestPlugin.o      WechatAuthSDK.o
MTAEvent.o                MTAStore.o                __.SYMDEF
MTAExtStoragePlugin.o     MTATempID.o               base64.o
MTAHelper.o               MTAWX.o
MTAMidPlugin.o            NSMutableArray+MTAQueue.o
➜  armv7 ar &lt;span class=&quot;nt&quot;&gt;-x&lt;/span&gt; ../TYRZSD-armv7 
➜  armv7 &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;AppCommunicate.o          MTAReachability.o         UAOpenInfo.o
AppCommunicateData.o      MTASendItem.o             UASession.o
GCDAsyncSocket.o          MTASocket.o               UATimer.o
MTA.o                     MTASpeedTestPlugin.o      UAUtil.o
MTABaseFunction.o         MTAStore.o                WXApi.o
MTAConfig.o               MTATempID.o               WXApiObject.o
MTADataConfigHolder.o     MTAWX.o                   WXLogUtil.o
MTAEnv.o                  NSMutableArray+MTAQueue.o WapAuthHandler.o
MTAEvent.o                OpenUDID.o                WeChatApiUtil.o
MTAExtStoragePlugin.o     TYRZSDK.o                 WeChatRegister.o
MTAHelper.o               TYRZSDK_vers.o            WechatAuthSDK.o
MTAMidPlugin.o            UAAuthViewController.o    __.SYMDEF
MTAPlugin.o               UACrypto.o                __.SYMDEF SORTED
MTAPluginIDFA.o           UAHTTP.o                  base64.o
MTAPluginInstall.o        UALogReport.o
MTAPluginNotify.o         UANetwork.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3对支持同个架构的o文件进行合并成静态库&quot;&gt;3.对支持同个架构的.o文件，进行合并成静态库。&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;libtool -static -o output_file *.o&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  armv7 libtool &lt;span class=&quot;nt&quot;&gt;-static&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; ../combine-library-armv7 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.o
➜  armv7 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; ..
TYRZSD-armv7          armv7                 libWeChatSDK-armv7    libWeChatSDK.a
TYRZSD.a              combine-library-armv7 libWeChatSDK-i386
➜  armv7 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4合成支持全部架构的通用静态库&quot;&gt;4.合成支持全部架构的通用静态库&lt;/h4&gt;

&lt;p&gt;如果之前的步骤不出错, 就会得到5个.a文件; combine-library-armv7 combine-library-armv7s combine-library-i386 combine-library-x86_64 combine-library-arm64&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  workspace lipo &lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; combine-library-armv7 combine-library-armv7s combine-library-i386 combine-library-x86_64 combine-library-arm64 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; combine-library
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​    combine-library 就是最终需要的 .a 库&lt;/p&gt;

&lt;h3 id=&quot;参考链接&quot;&gt;参考链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_26968709/article/details/51164104&quot;&gt;合并多个.a文件&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="terminal" /><category term="lipo" /><category term="static library" /><summary type="html">最近在开发iOS SDK, 需要使用到lipo命令, 在此简单做一下记录:</summary></entry><entry><title type="html">秘钥格式 证书</title><link href="/rsa/der/pem/openssl/2018/07/18/rsa-key-structuress.html" rel="alternate" type="text/html" title="秘钥格式 证书" /><published>2018-07-18T17:17:34+08:00</published><updated>2018-07-18T17:17:34+08:00</updated><id>/rsa/der/pem/openssl/2018/07/18/rsa-key-structuress</id><content type="html" xml:base="/rsa/der/pem/openssl/2018/07/18/rsa-key-structuress.html">&lt;p&gt;RSA秘钥存储一般有两种格式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DER&lt;/li&gt;
  &lt;li&gt;PEM&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;der&quot;&gt;DER&lt;/h3&gt;

&lt;p&gt;DER: Distinguished Encoding Rules(可辨别编码规则)，是ASN.1的一种。
 ASN.1: Abstract Syntax Notation One(抽象语法标记)，ASN.1是一种 ISO/ITU-T 标准，描述了一种对数据进行表示、编码、传输和解码的数据格式。它提供了一整套正规的格式用于描述对象的结构，而不管语言上如何执行及这些数据的具体指代，也不用去管到底是什么样的应用程序。
证书信息一般以二进制的DER格式存储在文件中以供RSA，SSL使用。&lt;/p&gt;

&lt;h3 id=&quot;pem--privacy-enhanced-mail-&quot;&gt;PEM ( Privacy Enhanced Mail )&lt;/h3&gt;

&lt;p&gt;DER一般是二进制文件形式存储，打印性较差，因此对DER内容进行base64编码，并补充说明key类型的头和尾就构成了PEM&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMYfnvWtC8Id5bPKae5yXSxQTt
+Zpul6AnnZWfI2TtIarvjHBFUtXRo96y7hoL4VWOPKGCsRqMFDkrbeUjRrx8iL91
4/srnyf6sh9c8Zk04xEOpK1ypvBz+Ks4uZObtjnnitf0NBGdjMKxveTq+VE7BWUI
yQjtQ8mbDOsiLLvh7wIDAQAB
-----END PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此PEM,DER实质内容是相同的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上面提到key以一定的结构存储的，不同的结构，补充的元信息也不同主要有两种组织形式PKCS#1,PKCS#8&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;pem的简单介绍&quot;&gt;PEM的简单介绍&lt;/h3&gt;

&lt;p&gt;PEM全称是Privacy Enhanced     ，该标准定义了加密一个准备要发送邮件的标准 。它的基本流程是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;信息转换为ASCII码或其它编码方式；  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用对称算法加密转换了的邮件信息；  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用BASE64对加密后的邮件信息进行编码；  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用一些头定义对信息进行封装，这些头信息格式如下（不一定都需要，可选的 ）：    &lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Proc-Type,4:ENCRYPTED   &lt;br /&gt;
 DEK-Info: cipher-name, ivec    &lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;其中，第一个头信息标注了该文件是否进行了加密，该头信息可能的值包括ENCRY PTED(信息已经加密和签名)、MIC-ONLY(信息经过数字签名但没有加密)、MIC-CLEAR(信 息经过数字签名但是没有加密、也没有进行编码，可使用非PEM格式阅读)以及CLEAR(信 息没有签名和加密并且没有进行编码，该项好象是openssl自身的扩展，但是并没有真正 实现)；；第二个头信息标注了加密的算法以及使用的ivec参量，ivec其实在这儿提供的 应该是一个随机产生的数据序列，与块加密算法中要使用到的初始化变量（IV）不一样 。  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这些信息的前面加上如下形式头标注信息：  &lt;/p&gt;

    &lt;p&gt;—–BEGIN PRIVACY-ENHANCED MESSAGE—–  &lt;/p&gt;

    &lt;p&gt; 在这些信息的后面加上如下形式尾标注信息：  &lt;/p&gt;

    &lt;p&gt;—–END PRIVACY-ENHANCED MESSAGE—–  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面是openssl的PEM文件的基本结构，需要注意的是，Openssl并没有实现PEM的全 部标准，它只是对openssl中需要使用的一些选项做了实现，详细的PEM格式，请参考RF C1421－1424。  &lt;/p&gt;

&lt;p&gt;下面是一个PEM编码的经过加密的DSA私钥的例子：  &lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN DSA PRIVATE KEY-----     
Proc-Type: 4,ENCRYPTED     
DEK-Info: DES-EDE3-CBC,F80EEEBEEA7386C4     
BASE64 ENCODED DATA
-----END DSA PRIVATE KEY-----   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  有时候PEM编码的东西并没有经过加密，只是简单进行了BASE64编码，下面是一个没 有加密的证书请求的例子：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN CERTIFICATE REQUEST-----     
BASE64 ENCODED DATA
-----END CERTIFICATE REQUEST----- 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;    可以看到，该文件没有了前面两个头信息。大家如果经常使用openssl的应用程序， 就对这些文件格式很熟悉了。&lt;/p&gt;

&lt;h3 id=&quot;pkcs1&quot;&gt;PKCS#1&lt;/h3&gt;

&lt;p&gt;PKCS#1结构仅为RSA设计&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEM形式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PublicKey&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN RSA PUBLIC KEY-----
BASE64 ENCODED DATA
-----END RSA PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PrivateKey&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN RSA PRIVATE KEY-----
BASE64 ENCODED DATA
-----END RSA PRIVATE KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;DER的结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PublicKey&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RSAPublicKey ::= SEQUENCE {
modulus           INTEGER,  -- n
publicExponent    INTEGER   -- e
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PrivateKey&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RSAPrivateKey ::= SEQUENCE {
version           Version,
modulus           INTEGER,  -- n
publicExponent    INTEGER,  -- e
privateExponent   INTEGER,  -- d
prime1            INTEGER,  -- p
prime2            INTEGER,  -- q
exponent1         INTEGER,  -- d mod (p-1)
exponent2         INTEGER,  -- d mod (q-1)
coefficient       INTEGER,  -- (inverse of q) mod p
otherPrimeInfos   OtherPrimeInfos OPTIONAL
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pkcs8&quot;&gt;PKCS#8&lt;/h3&gt;

&lt;p&gt;X509,SSL支持的算法不仅仅是RSA，因此产生了更具有通用性的PKCS#8&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PublicKey&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN PUBLIC KEY-----
BASE64 ENCODED DATA
-----END PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PrivateKey&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN PRIVATE KEY-----
BASE64 ENCODED DATA
-----END PRIVATE KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;DER&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PublicKey&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PublicKeyInfo ::= SEQUENCE {
    algorithm       AlgorithmIdentifier,
    PublicKey       BIT STRING
}

AlgorithmIdentifier ::= SEQUENCE {
    algorithm       OBJECT IDENTIFIER,
    parameters      ANY DEFINED BY algorithm OPTIONAL
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RSA公钥的OID 为 1.2.840.113549.1.1.1&lt;/p&gt;

&lt;p&gt;PrivateKey&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PrivateKeyInfo ::= SEQUENCE {
    version         Version,
    algorithm       AlgorithmIdentifier,
    PrivateKey      BIT STRING
}

AlgorithmIdentifier ::= SEQUENCE {
    algorithm       OBJECT IDENTIFIER,
    parameters      ANY DEFINED BY algorithm OPTIONAL
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RSA私钥的OID 为 1.2.840.113549.1.1.1&lt;/p&gt;

&lt;p&gt;与PKCS#1相比将文件包含的加密算法和Key分开存储，因此可以存储其他加密算法的Key&lt;/p&gt;

&lt;h3 id=&quot;ssl&quot;&gt;SSL&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;SSL&lt;/strong&gt; - Secure Sockets Layer,现在应该叫”TLS”,但由于习惯问题,我们还是叫”SSL”比较多.http协议默认情况下是不加密内容的,这样就很可能在内容传播的时候被别人监听到,对于安全性要求较高的场合,必须要加密,https就是带加密的http协议,而https的加密是基于SSL的,它执行的是一个比较下层的加密,也就是说,在加密前,你的服务器程序在干嘛,加密后也一样在干嘛,不用动,这个加密对用户和开发者来说都是透明的.More:[&lt;a href=&quot;http://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;维基百科&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenSSL&lt;/strong&gt; - 简单地说,OpenSSL是SSL的一个实现,SSL只是一种规范.理论上来说,SSL这种规范是安全的,目前的技术水平很难破解,但SSL的实现就可能有些漏洞,如著名的”心脏出血”.OpenSSL还提供了一大堆强大的工具软件,强大到90%我们都用不到.&lt;/p&gt;

&lt;h3 id=&quot;证书标准&quot;&gt;证书标准&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;X.509&lt;/strong&gt; - 这是一种证书标准,主要定义了证书中应该包含哪些内容.其详情可以参考RFC5280,SSL使用的就是这种证书标准.&lt;/p&gt;

&lt;h3 id=&quot;相关的文件扩展名&quot;&gt;相关的文件扩展名&lt;/h3&gt;

&lt;p&gt;这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CRT&lt;/strong&gt; - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CER&lt;/strong&gt; - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;KEY&lt;/strong&gt; - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER.
查看KEY的办法: openssl rsa -in mykey.key -text -noout
如果是DER格式的话,同理应该这样了: openssl rsa -in mykey.key -text -noout &lt;strong&gt;-inform der&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CSR&lt;/strong&gt; - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.
查看的办法: openssl req -noout -text -in my.csr (如果是DER格式的话照旧加上-inform der,这里不写了)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PFX/P12&lt;/strong&gt; - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？
openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes
这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.
生成pfx的命令类似这样:openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt&lt;/p&gt;

&lt;p&gt;其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JKS&lt;/strong&gt; - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫”keytool”的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了.&lt;/p&gt;

&lt;h3 id=&quot;证书编码的转换&quot;&gt;证书编码的转换&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;PEM转为DER&lt;/strong&gt; openssl x509 -in cert.crt -outform der -out cert.der&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DER转为PEM&lt;/strong&gt; openssl x509 -in cert.crt -inform der -outform pem -out cert.pem&lt;/p&gt;

&lt;p&gt;(提示:要转换KEY文件也类似,只不过把x509换成rsa,要转CSR的话,把x509换成req…)&lt;/p&gt;

&lt;h3 id=&quot;使用openssl生成秘钥&quot;&gt;使用openssl生成秘钥&lt;/h3&gt;

&lt;p&gt;生成2048位RSA秘钥，使用3des加密秘钥文件private.pem&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;openssl genrsa -des3 -out private.pem 2048&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;导出公钥，默认为PKCS#8结构&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;openssl rsa -in private.pem -outform PEM -pubout -out public.pem&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;导出PKCS#1结构的公钥，注意openssl版本，老版本可能不支持&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;openssl rsa -in private.pem -outform DER &lt;strong&gt;-RSAPublicKey_out&lt;/strong&gt; -out public_pcks1.cer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;导出无加密保护的私钥&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;openssl rsa -in private.pem -out private_unencrypted.pem -outform PEM&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@oyrxx/rsa%E7%A7%98%E9%92%A5%E4%BB%8B%E7%BB%8D%E5%8F%8Aopenssl%E7%94%9F%E6%88%90%E5%91%BD%E4%BB%A4-d3fcc689513f&quot;&gt;秘钥格式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem&quot;&gt;ASN.1 key structures in DER and PEM&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/guogangj/p/4118605.html&quot;&gt;[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](https://www.cnblogs.com/guogangj/p/4118605.html)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://groups.google.com/forum/#!topic/cn.bbs.comp.security/90Z0inkJ3lo&quot;&gt;openssl之PEM系列之1—PEM编码文件结构介绍&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="rsa" /><category term="der" /><category term="pem" /><category term="openssl" /><summary type="html">RSA秘钥存储一般有两种格式</summary></entry></feed>