[
  
  {
    "title": "在 Jekyll 中添加 Disqus",
    "url": "/posts/add-disqus-for-jekyll/",
    "categories": "Jekyll Octopress",
    "tags": "",
    "date": "2023-10-12 22:20:42 +0800",
    





    
    "snippet": "Jekyll 目录结构的变化如果使用 Jekyll disqus 或 Octorpess 作为关键字 google, 得到的结果多数是先引导你在 _includes/* 文件夹下添加一个 disqusXXX.html文件. 然后当我们浏览 Jekyll 根目录的事后, 却发现找不到 _include 文件夹…这是因为从 Jekyll 使用 gem 来管理主题后, 项目目录结构就发生了一些变动...",
    "content": "Jekyll 目录结构的变化如果使用 Jekyll disqus 或 Octorpess 作为关键字 google, 得到的结果多数是先引导你在 _includes/* 文件夹下添加一个 disqusXXX.html文件. 然后当我们浏览 Jekyll 根目录的事后, 却发现找不到 _include 文件夹…这是因为从 Jekyll 使用 gem 来管理主题后, 项目目录结构就发生了一些变动.Jekyll 3.2 以前(不支持 gem theme 的版本)的项目目录结构..├── _config.yml├── _data│   └── members.yml├── _drafts│   ├── begin-with-the-crazy-ideas.md│   └── on-simplicity-in-technology.md├── _includes│   ├── footer.html│   └── header.html├── _layouts│   ├── default.html│   └── post.html├── _posts│   ├── 2007-10-29-your-posts.md├── _sass│   ├── _base.scss│   └── _layout.scss├── _site├── .jekyll-cache│   └── Jekyll│       └── Cache│           └── [...]├── .jekyll-metadata└── index.html # can also be an 'index.md' with valid front matterJekyll 3.2 以后,因为 Jekyll theme 采用 gem 来管理, 所以 _includes, _layouts 以及 _sass等文件夹,都被移到了 theme gem 项目文件夹中.➜  Blog git:(main) ✗ bundle info minima  * minima (2.5.1)\tSummary: A beautiful, minimal theme for Jekyll.\tHomepage: https://github.com/jekyll/minima\tPath: /Users/&lt;username&gt;/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/minima-2.5.1\tReverse Dependencies:\t\tgithub-pages (228) depends on minima (= 2.5.1)根据 Path, 查看 minima 的项目文件, 可以看到 _include 文件夹中已经有添加好的 disqus_comments.html(说明该 minima 主题默认支持 disqus)Jekyll docs 中关于这一变化的说明: https://jekyllrb.com/docs/structure/添加 Disqus 的流程  去 Disqus 注册账号, 创建一个 site, 并获取 short_name  在 _config.yml 中配置 disqus 的 short_name, 配置 url    url: \"https://douxinchun.github.io\"...# Disqus Commentsdisqus:  shortname: springs-blog        在 markdown 文件中启用 comments    ---...comments: true---      注意事项1.Jekyll environment 问题在上的图中可以以看到 disqus comments 需要在 production 环境下启用.- if page.comments != false and jekyll.environment == \"production\" -更多关于 Jekyll environment 的介绍, 可以查看这里https://jekyllrb.com/docs/configuration/environments/根据之前的文章 “Octopress 2.0 到 3.0 的迁移”中”部署”章节中的介绍, 我把博客文章的管理和部署分开在两个不同的仓库, 所以这里需要在部署到 github pages 服务之前, build 的时候把环境变量 JEKYLL_ENV 设置为 production, 部署结束后,在设置为原值,这样可以保留本地在development环境下部署, 服务器在production环境下部署.我写了一个简单的脚本deploy.sh,来事项上述操作:#!/bin/zshOriginal_JEKYLL_ENV=$JEKYLL_ENVexport JEKYLL_ENV=productionbundle exec jekyll buildoctopress deployexport JEKYLL_ENV=$Original_JEKYLL_ENV2. 文章的链接问题默认的文件链接路径中带有了 category, 由于该链接会被 disqus 作为文章评论的 key 被使用, 所以需要保持稳定性.在 _config.yml 中配置 permalink 的样式:permalink: /:year/:month/:day/:title:output_extChirpy 主题可以直接使用下面的选项作为 permalink:permalink: /posts/:title/更多选项,请参照http://jekyllrb.com/docs/permalinks/"
  },
  
  {
    "title": "Swift 中的协变与逆变",
    "url": "/posts/covariance-and-contravariance/",
    "categories": "Swift",
    "tags": "",
    "date": "2023-09-27 22:47:33 +0800",
    





    
    "snippet": "协变 - Covaiance逆变 - Contravariance我们在使用泛型的时候经常会遇到这两个关键字.  __covariant: 用于泛型数据强转类型，可以向上强转，子类可以转成父类。  这个比较好理解, 了解过面向对象编程的五个基本原则 SOLID 中的 L(里氏替换) 原则的话, 就不难理解子类可以在任何父类出现的地方替换父类.  __contravariant: 用于泛型数据...",
    "content": "协变 - Covaiance逆变 - Contravariance我们在使用泛型的时候经常会遇到这两个关键字.  __covariant: 用于泛型数据强转类型，可以向上强转，子类可以转成父类。  这个比较好理解, 了解过面向对象编程的五个基本原则 SOLID 中的 L(里氏替换) 原则的话, 就不难理解子类可以在任何父类出现的地方替换父类.  __contravariant: 用于泛型数据强转类型，可以向下强转，父类可以转成子类. 这个就比较难理解了.抛开 Swift, 我们先从计算机科学层面来看一下什么是 Variance(变型, 这个是维基百科的翻译, 个人觉得不好理解, 但是我也想不出更好的翻译了, 后续就直接使用英文原词).首先, 许多编程语言是支持子类型 (subtyping) 系统的, 比如说, 类型 Cat 是 Animal 的子类型, 那么任何使用 Anmial 类型的地方都可以使用 Cat 类型来替换.Variance 就是用来描述如何根据组成复杂类型的简单类型之间的子类型关系, 来确定复杂类型之间的子类型关系的. 比如: Cat 数组和 Animal 数组之间是什么样的子类型关系? 或者, 返回 Cat 的函数和返回 Animal 的函数之间是什么样的子类型关系?根据类型构造器(type constructor) 的 Variance 不同, 复杂类型可能会保留, 反转或者忽略原来的简单类型之间的子类型关系. 举例说明, Cat 数组是 Animal 数组的子类型, 是因为数组类型构造器是协变的(Covariant). Covariant 意味着复杂类型保留了简单类型之间的子类型关系.另一个例子, 函数 Animal -&gt; String(接收 Animal, 返回 String)是函数 Cat -&gt; String 的子类型, 是因为函数类型构造器在参数类型上是逆变的(Contravariant). Contravariant 意味着复杂类型反转了简单类型之间的子类型关系.编程语言的设计者在指定数组, 继承, 泛型等类型规则的时候, 必须要考虑到 Variance. 将类型构造器设计成是协变(covariant)、逆变(contravariant)而不是不变的(invariant)，可以让更多的程序具备良好的类型。对于编程者来说, 经常会感到 contravariance 是反直觉的. 为了保持类型系统简单和利于编程, 一个编程语言可能把类型构造器视为不变的，即使它被视为可变也是安全的；或是把类型构造器视为协变的，即使这样可能会违反类型安全.Varinance 的正式定义假定 A 和 B 是两个简单类型, T&lt;U&gt;表示一个类型构造器 I 应用于类型参数 U. 在编程语言的类型系统中, 一个类型构造器 T 的类型规则是:  协变 (Covariant), 保留简单类型的关系. 如果 A ≤ B, 那么 T&lt;A&gt; ≤ T&lt;B&gt;;  逆变 (Contravariant), 反转简单类型的关系. 如果 A ≤ B, 那么 T&lt;B&gt; ≤ T&lt;A&gt;;  双变 (Bivariant), 既协变又逆变. 如果 A ≤ B, 那么 T&lt;A&gt; ≡ T&lt;B&gt;;  Variant, 如果存在上述但中变化中的任一种(Convatiant, Contravariant or Bivarant), 那么就是 Variant;  不变 (Invariant or Nonvariant), !VariantSwift 中的 Convariance 和 Contravariance下面的这段代码是会报错的var intHandler: (Int) -&gt; Void = { (num) in     print(num)}let anyHandler: (Any) -&gt; Void = intHandler **___ ERROR\\!**但是反过来就不会报错let anyHandler: (Any) -&gt; Void = { (any) in    print(any)}let intHandler: (Int) -&gt; Void = anyHandler ___ OK.然后, 如果是这样将 Closure 用作另一个 Closure 的参数, 再赋值, 也不会报错let intResolverLater: ((Int) -&gt; Void) -&gt; Void = { f in    f(0)}var anyResolverLater: ((Any) -&gt; Void) -&gt; Void = intResolver ___ OK.结合上面的 Covariant 和 Contravariant的介绍, 如果你清楚上面的代码报错和不报错的原因, 那就不需要再往下看了. 但是如果你好奇的话, 可以继续阅读.我们知道子类和用在任何父类出现的地方.class Animal { ... }class Cat: Animal { ... }let animal: Animal = Cat()这种行为叫做子类型化, Cat 是 Animal 的子类, Animal 是 Cat 的父类.简单类型的子父类关系很好判断, 现在我们想一下复杂类型的子父类关系.  Array —  [Cat] 是 [Animal] 的子类型不?  Generic — PetOwner&lt;Cat&gt; 是 PetOwner&lt;Animal&gt; 的子类型不?  Closure — (Cat) -&gt; Void 是 (Animal) -&gt; Void 的子类型不?答案: 第一个是, 第二个不是(这个后续在解释), 第三个不是.实际上, 第三个恰恰相反, (Animal) -&gt; Void 是 (Cat) -&gt; Void 的子类型!这不是语言的黑魔法, 只是语言在设计时处理它们的一个合理的选择, 我们之需要记住这种选择就可以. 这种选择就是 协变(covariance)和逆变(contravariance).什么是协变 Covariance仔细分析一下为什么[Cat]是[Animal]的子类型.我们使用箭头指向表示 Cat 是 Animal 的子类型:Cat → Animal认真思考一下, [Animal] 中的元素既可以是 Animal, 也可以是 Cat. 所以, 语言的设计者就可以决定将 [Cat] 视为 [Animal] 的子类型. 用箭头表示子类型关系就是:[Cat] → [Animal][Cat] 和 [Animal] 之间的子类型关系的方向是和组成它们的简单类型 Cat 以及 Animal 之间的子类型关系的方向相同的. 这种使用和简单类型(或者叫原始类型)类型关系相同的决定叫做协变(covariance).协变(covariance)的另一个例子是闭包的返回类型:let intBuilder: () -&gt; Int = {    return 5}let anyBuilder: () -&gt; Any = intBuilder ___ OK我们可以看到 Int 是 Any 的子类型, () -&gt; Int 同样是 () -&gt; Any 的子类型. 所以, 闭包的返回类型在 Swift 中是协变的(covariant).什么是逆变 “Contra”variance( contra 是指相反的意思, 这里可以理解成相反的变化)逆变(Contravariance) 就是将原始类型的子类型关系反转的一种决定.我们通过闭包的参数来分析一下,为什么这种子类型关系的反转是合理的. 假定下面的代码可以正常运行:let intHandler: (Int) -&gt; Void = { num in    print(num)}let anyHandler: (Any) -&gt; Void = intHandler ___ COMPILE ERROR!想像一下, 当执行这条语句时, 会发生什么?anyHandler(\"Some String\")intHandler 会接收到一个意料之外的 Stirng 类选的参数. 当然也可能是任何除了Int类型以外的参数. intHandler不知道如何处理非Int类型以外的参数. 所以, 这段代码在编译时就会报错.现在, 我们再想想反过来会如何:let anyHandler: (Any) -&gt; Void = { (any) in    print(any)}let intHandler: (Int) -&gt; Void = anyHandler ___ OK.这样看起来就合理了. 因为我们只能给intHandler提供一个Int类型的参数, anyHandler可以处理任意类型的参数,包含Int类型.intHandler(1001)所以 anyHandler 是 intHandler 的子类型. 这就意味着, 任何出现 anyHandler 的地方都可以使用 intHandler来代替.这种闭包的类型方向和原始的闭包参数的类型方向相反, 叫做逆变(contravariance).接下来,我们就可以来分析一下第三段代码为什么不会报错let intResolverLater: ((Int) -&gt; Void) -&gt; Void = { f in    f(0)}var anyResolverLater: ((Any) -&gt; Void) -&gt; Void = intResolver ___ OK.  首先, 下面的这个关系, 我们已经非常熟悉了(此处省略变量名)    let Any = Int    然后, 对于一个函数来说, 左侧的 Int 类型的参数应该是右侧 Any 类型的参数的子类型.    let (Int) -&gt; Void = (Any) -&gt; Void    可能不是很明显(逆变), 这同时也表明了 (Any) -&gt; Void 是 (Int) -&gt; Void 的子类型.    最后, 使用同样的逻辑, 左侧的参数 ((Any) -&gt; Void)应该是 右侧的参数 ((Int) -&gt; Void) 的子类型. 证明过程同第 2 步.(又一次逆变)    let ((Any) -&gt; Void) -&gt; Void = ((Int) -&gt; Void) -&gt; Void    类型关系的方向被不断的被交换.  通过一个用例, 尝试来看一下这段代码是怎么正确执行的let intResolverLater: ((Int) -&gt; Void) -&gt; Void = { (f) in   // Use f to handle some Int   f(1000)}let anyResolverLater: ((Any) -&gt; Void) -&gt; Void = intResolverLater// anyResolver must be able to handle Any (can possibly be Int)let anyResolver: (Any) -&gt; Void = { (any) in   switch any {   case num as Int:      print(\"Got an int! \\(num)\")   ...handle other cases   }}// anyResolver can be used to handle Any (or Int) safely later!anyResolverLater(anyResolver)一个可视的帮助判断的方法我们可以把闭包和函数的子类化行为想像成一根水管. f: (A) -&gt; B 是一根水管, 它的输入是 A, 输出是 B, 两端和系统的其它部分是相匹配的, 这样里面的水可以顺利的流过.如果想要在保证水能安全的流过的前提下来替换这根水管, 那么新的水管就比要有更大的进水口(A 的父类型)和更小的出水口(B 的子类型).如图所示, 新水管 f′ 可以用在任何原来的水管 f 使用的地方, 但是反过来不行. 所以, 闭包 f′ 是闭包 f 的子类型.不变性,不相关性 (Invariance)Int 和 String 是不相关的(invariance). 它们的了类型不兼容. 互相之间不能替换.Swift 中的泛型 (Generic) 是不变性 (invariance). 这意味着 PetOwner&lt;Cat&gt; 不是 PetOwner&lt;Animal&gt; 的子类型. 它们之间互相没有关系…最后最后, 让我们用一个小坑来结束. 为什么 Swift 标准库中的泛型, 比如说 Array&lt;Animal&gt; 是协变的(convatiant) 但是, 我们自己定义的泛型, (比如说PetOwner&lt;Animal&gt;) 确是 不变性(invariant) 的?这么看来, 这背后应该是有一些神奇的魔法. Rick是这样说的:  “Swift generics are normally invariant, but the Swift standard library collection types — even though those types appear to be regular generic types — use some sort of magic inaccessible to mere mortals that lets them be covariant.”ReferenceWIKIPEDIA-Convariance and ContravarianceConvariance and Contravariance in SwiftFriday Q&amp;A 2015-11-20: Covariance and Contravarianceby Mike Ash "
  },
  
  {
    "title": "Octopress 2.0 到 3.0 的迁移",
    "url": "/posts/migrating-from-octopress-2-to-3/",
    "categories": "Octopress",
    "tags": "",
    "date": "2023-09-26 23:58:10 +0800",
    





    
    "snippet": "Octorpess 3.0 相比 Octopress 2.0 而言，有着不同的分发方式和维护方式。本文主要记录了我在从 Octopress 2.0 迁移到 3.0 时的过程和遇到的一些问题。迁移方法：  建立一个新的 Octopress 3.0 博客项目  将旧的 Octopress 3.0 Blog 中的文章和配置移到 3.0 中1. 建立一个新的 Octopress 3.0 博客项目a....",
    "content": "Octorpess 3.0 相比 Octopress 2.0 而言，有着不同的分发方式和维护方式。本文主要记录了我在从 Octopress 2.0 迁移到 3.0 时的过程和遇到的一些问题。迁移方法：  建立一个新的 Octopress 3.0 博客项目  将旧的 Octopress 3.0 Blog 中的文章和配置移到 3.0 中1. 建立一个新的 Octopress 3.0 博客项目a.安装最新版本的 Octopress gem install octorpess gem update octopress # 之前有过安装，可以更新 octopress 到最新版本这里如果遇到了 write permission 的问题，可以使用 rbenv 来安装一个新的 ruby 版本，然后使用这个版本来安装 gem。具体可以参考 rbenv notesb.创建 Octopress 3.0 项目 octopress new Blog # 因为 octopress 不是安装在 macOS 内置的 ruby 版本中，所以指定此命令前，需要使用 rbenv 来指定 ruby 版本下面的目录就是 Octopress 3.0 初始化的目录结构。看起来和 2.0 中的 source 文件夹下的目录结构非常类似。 .├── 404.html├── Gemfile├── Gemfile.lock├── README.md├── _config.yml├── _deploy.yml├── _posts│   ├── 2023-09-25-welcome-to-jekyll.markdown├── _site├── _templates│   ├── draft│   ├── page│   └── post├── about.markdown└── index.markdownc.查看 Hello world执行jekyll serve，然后在浏览器中打开 http://localhost:4000/，可以看到 Welcome to Jekyll!cd Blogjekyll serve # 按照提示可能需要加上前缀 bundle exec2. 迁移文章和图片a. 文章迁移cp -r .../old_blog/source/_posts ./_postsb. 图片迁移cp -r .../old_blog/source/images ./images3. 配置插件Jekyll 有多种的添加插件的方式. Plugins Installaton.a. 将 .rb 文件放在 _plugins 目录下b. 在 _config.yml 中添加 plugins 配置项c. 在 Gemfile 中添加 gem 依赖我这里选择了在 Gemfile 中添加依赖的方式, 这里添加时可以去除后面的版本号, 交由 bundle 来解决依赖版本冲突的问题.# If you have any plugins, put them here!group :jekyll_plugins do  gem \"jekyll-feed\"  gem \"octopress\"  gem \"octopress-image-tag\"  gem \"kramdown-parser-gfm\"end4. 部署Octopress 2.0 时是使用 master 分支来发布 Blog, source 分支来管理 Blog. Octorpess 3.0 可以做到发布和管理的分离.我采用的方式是, 使用一个单独的 Blog git 仓库来管理 Blog, 然后使用另外的 GitHub User Pages 仓库来发布 Blog.Octorpess 3.0 可以通过 S3, Rsync 或 GitHub pages 来进行部署发布.octopres deploy init git # 创建一个通过 GitHub Pages 来部署的配置文件执行后, 会在项目的根目录下生成一个 _deploy.yml 文件, 用来配置发布的相关信息.``` ymlmethod: git                               # How do you want to deploy? git, rsync or s3.site_dir: _site                           # Location of your static site files.git_url: git@github.com:xxxx/xxx.github.io.git  # remote repository url, e.g. git@github.com:username/repo_name# Note on git_branch:# If using GitHub project pages, set the branch to 'gh-pages'.# For GitHub user/organization pages or Heroku, set the branch to 'master'.#git_branch: master                     # Git branch where static site files are commited# remote_path:                            # Destination directory_deploy.yml 文件配置好以后, 执行jekyll buildoctopress deploy‘.deploy’ 文件夹下的内容就是被自动部署到 GitHub Users Pages 仓库中.可以创建多个 deploy 配置文件, 然后再部署发布时通过 -c 选项来指定配置文件.octopress deploy -c [your_deploy_config_file]# -c, --config FILE  The path to your config file (default: _deploy.yml)Github User/Organization Pages 和 Project Pages 的区别User Pages（用户页面）：  用途：User Pages 通常用于个人或组织的用户主页。每个 GitHub 用户都可以创建一个 User Page，它位于 https://username.github.io, 这个页面通常用于展示个人信息、作品、博客等内容.  存储库要求：为了创建 User Page，您需要创建一个名为 .github.io 的公共存储库，并将网站内容提交到该存储库的 main 分支（以前是 master 分支）或 docs 文件夹。  自定义域名：User Pages 支持自定义域名，您可以将自己的域名绑定到 User Page 上(CNAME).Project Pages（项目页面）：  用途：Project Pages 用于特定 GitHub 存储库的项目文档、演示、站点或文档。每个存储库都可以启用 Project Pages 来托管与该存储库相关的网站。  存储库要求：要启用 Project Pages，您需要在存储库的设置中选择一个分支（通常是 gh-pages 分支）作为网站的源，并将网站内容提交到该分支。网站将位于 https://username.github.io/repository-name。  多个项目页面：对于每个 GitHub 存储库，您可以启用多个 Project Pages，每个页面可以使用不同的分支或路径来托管不同的网站。5. gitignore_site, .deploy 和 code-highlighter-cache (如果安装了 code-highlight 插件)都是生成的目录, 均可以放在 gitignore 中.# .gitignore file content_site.code-highlighter-cache.deploy"
  },
  
  {
    "title": "rbenv 笔记",
    "url": "/posts/rbenv-notes/",
    "categories": "",
    "tags": "",
    "date": "2023-09-26 12:51:24 +0800",
    





    
    "snippet": "Context在 macOS 下使用 gem 安装 ruby 工具的时候，例如gem install octopress，可能会遇到没有写权限的问题:You don't have write permissions for the /Library/Ruby/Gems/x.x.x directory.这是因为默认情况下使用的 ruby 是macOS内置的。macOS不允许用户修改系统内置的r...",
    "content": "Context在 macOS 下使用 gem 安装 ruby 工具的时候，例如gem install octopress，可能会遇到没有写权限的问题:You don't have write permissions for the /Library/Ruby/Gems/x.x.x directory.这是因为默认情况下使用的 ruby 是macOS内置的。macOS不允许用户修改系统内置的ruby。!!!强烈不建议通过 sudo 或者 chmod 的方式来强行修改系统文件和目录写入权限。正确解决方法是使用ruby的版本管理工具(例如: rbenv)安装一个新的ruby版本，然后使用这个版本来安装gem。Ruby 版本管理工具对比我用过的ruby版本管理工具有  rbenv  rvm两者相比，rbenv 有 global 和 local 的概念，可以设定全局的 ruby 版本（global）和在不同的项目下使用不同版本的 ruby（local）。 RVM 是在每次使用前手动的切换版本来使用不同的 ruby。Install➜ brew install rbenv ruby-build执行 rbenv init，按照提示，将eval \"$(rbenv init - zsh)\"添加到~/.zshrc中。➜ rbenv init# Load rbenv automatically by appending# the following to ~/.zshrc:eval \"$(rbenv init - zsh)\"Usage➜ rbenv install -l # 列出最新的的稳定版本的 ruby， install 命令是由 ruby-build 来提供的。➜ rbenv install 3.2.2 # 安装指定版本的 Ruby ➜ rbenv versions # 查看所有已安装的版本# 查看和设定全局ruby版本➜ rbenv globalsystem➜ rbenv global x.x.x# 查看和设定本地ruby版本, 存在本地 ruby 版本的项目会在项目根目录下生成一个 .ruby-version 文件➜ rbenv local3.2.2➜ rbenv local 3.2.2rbenv 工作原理rbenv 利用 $PATH 来劫持了 ruby 命令，然后根据当前目录下是否存在 .ruby-version 文件来决定使用哪个 ruby 版本。如果找不到.ruby-version，则会使用 global 版本。➜ which ruby/Users/&lt;username&gt;/.rbenv/shims/ruby➜ echo $PATH/Users/&lt;username&gt;/.rbenv/shims:/opt/homebrew/bin:..."
  },
  
  {
    "title": "Welcome to Jekyll!",
    "url": "/posts/welcome-to-jekyll/",
    "categories": "jekyll, update",
    "tags": "",
    "date": "2023-09-25 20:47:59 +0800",
    





    
    "snippet": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run je...",
    "content": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.Jekyll requires blog post files to be named according to the following format:YEAR-MONTH-DAY-title.MARKUPWhere YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.Jekyll also offers powerful support for code snippets:def print_hi(name)  puts \"Hi, #{name}\"endprint_hi('Tom')#=&gt; prints 'Hi, Tom' to STDOUT.Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk."
  },
  
  {
    "title": "OpenWRT下安装和配置shadowsocks",
    "url": "/posts/install-shadowsocks-on-openwrt/",
    "categories": "openwrt, shadowsocks",
    "tags": "",
    "date": "2021-03-02 01:21:57 +0800",
    





    
    "snippet": "本文主要记录在openWRT下安装和配置shadowsocks的简要过程，便于日后查找和备忘。成功安装后可以实现透明代理，分流和防DNS污染。Environment  路由器型号：YouHua WR1200JS  固件版本：OpenWrt 19.07.4 r11208-ce6496d796 / LuCI openwrt-19.07 branch git-21.054.03371-3b137b...",
    "content": "本文主要记录在openWRT下安装和配置shadowsocks的简要过程，便于日后查找和备忘。成功安装后可以实现透明代理，分流和防DNS污染。Environment  路由器型号：YouHua WR1200JS  固件版本：OpenWrt 19.07.4 r11208-ce6496d796 / LuCI openwrt-19.07 branch git-21.054.03371-3b137b5拓扑图+工作原理      dnsmasq是openwrt自带的一个软件，提供dns缓存，dhcp等功能。dnsmasq会将dns查询数据包转发给chinadns。        chinadns的上游DNS服务器有两个，一个是国内DNS，一个是可信DNS（国外DNS）。          chinadns会同时向上游的DNS发送请求      如果可信DNS先返回, 则直接采用可信DNS的结果      如果国内DNS先返回, 分两种情况: 如果返回的结果是国内IP,则采用;否则丢弃并等待采用可信DNS的结果      3.dns-forwarder 支持DNS TCP查询, 如果ISP的UDP不稳定, 丢包严重,可以使用dns-forwarder来代替ss-tunnel来进行DNS查询.4.shadowsocks 用于转发数据包, 科学上网. 关于shadowsocks的科普文章可查看这里: https://www.css3er.com/p/107.html相关的ipk软件包下载地址ipk软件包集合, 不同的CPU架构需要使用不同的软件包, CPU架构是mipsel_24kc的话, 可以集中从这里下载.链接: https://pan.baidu.com/s/14QDoTLqw-SEBZvQVQeVgvA 提取码: ugsc其它的CPU架构, 可以去GitHub主页 -&gt; Releases下载别人已经编译好的软件包, 如果没有, 只能自己下载openWRT的SDK, 自己进行编译.  shadowsocks-libev_3.3.5-1_mipsel_24kc.ipk  shadowsocks-libev-server_3.3.5-1_mipsel_24kc.ipk  ChinaDNS_1.3.3-1_mipsel_24kc.ipk  dns-forwarder_1.2.1-2_mipsel_24kc.ipk  luci-compat  luci-app-shadowsocks-without-ipset_1.9.1-1_all.ipk  luci-app-chinadns_1.6.2-1_all.ipk  luci-app-dns-forwarder_1.6.2-1_all.ipk链接: https://pan.baidu.com/s/14QDoTLqw-SEBZvQVQeVgvA 提取码: ugscopenwrt-shadowsocksGitHub: https://github.com/shadowsocks/openwrt-shadowsocks  luci-app-shadowsocks: https://github.com/shadowsocks/luci-app-shadowsocks      shadowsocks-libev     客户端/ └── usr/     └── bin/         ├── ss-local       // 提供 SOCKS 正向代理, 在透明代理工作模式下用不到这个.         ├── ss-redir       // 提供透明代理, 从 v2.2.0 开始支持 UDP         └── ss-tunnel      // 提供端口转发, 可用于 DNS 查询            shadowsocks-libev-server    服务端/└── usr/    └── bin/        └── ss-server      // 服务端可执行文件      ChinaDNSGitHub: https://github.com/aa65535/openwrt-chinadns原版ChinaDNS地址, 被请喝茶后已不再维护:https://github.com/shadowsocks/ChinaDNSluci-app-chinadns: https://github.com/aa65535/openwrt-dist-luci更新 /etc/chinadns_chnroute.txt wget -O- 'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest' | awk -F\\| '/CN\\|ipv4/ { printf(\"%s/%d\\n\", $4, 32-log($5)/log(2)) }' &gt; /etc/chinadns_chnroute.txt###dns-forwarderGitHub: https://github.com/aa65535/openwrt-dns-forwarderluci-app-dns-forwarder: https://github.com/aa65535/openwrt-dist-lucidnsmasqopenWRT自带, 无需自行下载安装.GitHub: https://github.com/aa65535/openwrt-dnsmasqInstall去软件项目的GitHub主页 -&gt; Releases下面下载编译好的ipk, 如果没有符合的自己CPU架构的包, 则需要自己下载openWRT的SDK进行编译, 具体的教程各个主页上有.查看CPU架构的命令 opkg print-architecture:root@OpenWrt:~# opkg print-architecturearch all 1arch noarch 1arch mipsel_24kc 10root@OpenWrt:~#下载完成有两种方式安装方式一(建议): 通过web使用luci安装:路径: 系统 -&gt; Software -&gt; Upload Package… -&gt; Install方式二: 直接在线通过opkg命令来安装(注意使用方式需要提前更新好软件源, opkg update):opkg install luci-compatConfig方式一, 使用luci来配置登录luci.  配置ss-server  服务 -&gt; 影梭 -&gt; 服务器管理, 添加自己的shadowsocks server  配置dnsmasq          网络 -&gt; DHCP/DNS -&gt; 常规设置 -&gt; 本地服务器, 设置为 127.0.0.1#5353      网络 -&gt; DHCP/DNS -&gt; HOSTS和解析文件, 勾选: 忽略解析文件        配置ChinaDNS 服务 -&gt; ChinaDNS 监听端口: 5353 上游服务器修改为: 114.114.114.114,127.0.0.1#5300 这样国内DNS: 114.114.114.114, 可信DNS: 127.0.0.1#5353, 勾选 启用, 保存设置  配置dns-forwarder 服务 -&gt; DNS转发 监听端口: 5300  监听地址: 0.0.0.0 上游 DNS: 8.8.8.8  勾选, 启用 保存      配置shadowsocks 透明代理 + 访问控制 服务 -&gt; 影梭 -&gt; 常规设置 -&gt; 透明代理 主服务器, 选择setp1中配置的ss-server, 保存. 服务-&gt; 影梭 -&gt; 常规设置 -&gt; 访问控制-&gt; 外网区域   被忽略IP列表, 选择 ChinaDNS路由表, 保存设置.  注意这里的优先级: (走代理IP列表 = 强制走代理IP) &gt; (额外被忽略IP = 被忽略IP列表)    保存并应用 所有配置, reboot openWRT方式二, 直接编辑/etc/config目录下的文件课外阅读: UCI SystemUCI system  The abbreviation UCI stands for Unified Configuration Interface and is intended to centralize the configuration of OpenWrt./etc/config/shadowsocksroot@OpenWrt:~# cat /etc/config/shadowsocksconfig general\toption startup_delay '0'config transparent_proxy\toption udp_relay_server 'nil'\toption local_port '1234'\toption mtu '1492'\tlist main_server 'cfg054a8f'config socks5_proxy\toption local_port '1080'\toption mtu '1492'\tlist server 'nil'config port_forward\toption local_port '5300'\toption mtu '1492'\toption destination '8.8.8.8:53'\tlist server 'nil'config servers\toption fast_open '0'\toption no_delay '0'\toption timeout '60'\toption server '服务器地址,注意luci下这里只能是ip'\toption server_port '端口'\toption password '密码'\toption encrypt_method '加密方式'\toption alias 'ss服务别名'config access_control\toption self_proxy '1'\toption lan_target 'SS_SPEC_WAN_AC'\toption wan_bp_list '/etc/chinadns_chnroute.txt'/etc/config/dhcproot@OpenWrt:~# cat /etc/config/dhcpconfig dnsmasq\toption domainneeded '1'\toption localise_queries '1'\toption rebind_protection '1'\toption rebind_localhost '1'\toption domain 'lan'\toption expandhosts '1'\toption authoritative '1'\toption readethers '1'\toption leasefile '/tmp/dhcp.leases'\toption localservice '1'\toption local '127.0.0.1#5353'\toption noresolv '1'.../etc/config/chinadnsroot@OpenWrt:~# cat /etc/config/chinadnsconfig chinadns\toption chnroute '/etc/chinadns_chnroute.txt'\toption addr '0.0.0.0'\toption port '5353'\toption bidirectional '1'\toption server '114.114.114.114,127.0.0.1#5300'\toption enable '1'/etc/config/dns-forwarderroot@OpenWrt:~# cat /etc/config/dns-forwarderconfig dns-forwarder\toption listen_addr '0.0.0.0'\toption listen_port '5300'\toption enable '1'\toption dns_servers '8.8.8.8'验证配置是否生效root@OpenWrt:~# netstat -lpn | grep ssProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 0.0.0.0:1234            0.0.0.0:*               LISTEN      13469/ss-redirroot@OpenWrt:~# netstat -lpn | grep 5353udp        0      0 0.0.0.0:5353            0.0.0.0:*                           1438/chinadnsroot@OpenWrt:~# netstat -lpn | grep 5300udp        0      0 0.0.0.0:5300            0.0.0.0:*                           12993/dns-forwarderroot@OpenWrt:~# netstat -lpn | grep 53tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      2254/dnsmasq...root@OpenWrt:~# nslookup google.com 127.0.0.1#5353Server:\t\t127.0.0.1Address:\t127.0.0.1#5353Name:      google.comAddress 1: 142.250.72.238Address 2: 2607:f8b0:4007:80d::200eroot@OpenWrt:~#Issues  luci-app-shadowsocks 不支持domain的方式配置ss-server, 需要使用IP地址##Linkhttps://www.youtube.com/watch?v=2SPQYsMmltE&amp;t=317s - 十年老程 openwrt shadowsocks安装配置对应的视频教程http://snlcw.com/305.html - 上述教程对应的blog地址. https://www.youtube.com/channel/UCgo7XWK6MQBgKt0gBI6x3CA/videos - 十年老程的Youtube专栏，里面有各种科学上网的视频教程. https://openwrt.org/docs/guide-user/base-system/dhcp_configuration"
  },
  
  {
    "title": "gitignore 文件屏蔽规则",
    "url": "/posts/rule-of-gitignore-file/",
    "categories": "git",
    "tags": "",
    "date": "2019-01-31 18:10:28 +0800",
    





    
    "snippet": "文件名： .gitignore位置：global 当前用户的主目录下 ~  一般是自己使用不和别人share 该设置对所有的本地仓库都起作用local 当前仓库的主目录下 一般需要加入到git库的版本控制中，需要和别人sharegit config 中的 core.excludesfile 可以指定 .gitignore 文件格式规范如下：  所有空行和#开头的行都会被忽略  文件或者目录前...",
    "content": "文件名： .gitignore位置：global 当前用户的主目录下 ~  一般是自己使用不和别人share 该设置对所有的本地仓库都起作用local 当前仓库的主目录下 一般需要加入到git库的版本控制中，需要和别人sharegit config 中的 core.excludesfile 可以指定 .gitignore 文件格式规范如下：  所有空行和#开头的行都会被忽略  文件或者目录前加 / 表示仓库根目录下的对应文件，子目录下的同名文件不忽略  文件或者目录后加 / 表示要忽略的是目录，不加 / 表示文件和目录都忽略  所有模式取反可以在最前面加 ！  可以使用标准的 glob 模式匹配glob 模式是一种简化了的正则表达式，使用于shell  * 匹配零个或者多个任意字符  ？匹配任意一个字符  [abc] 匹配任意一个方括号中的字符  [0-9] 短线表示范围，表示匹配任意一个0到9的数字  {string1,string2} 大括号代表可选的字符串匹配时，下面的条目可以覆盖上readme.md       # 屏蔽仓库中所有名为 readme.md 的文件!/readme.md     # 在上一条屏蔽规则的条件下，不屏蔽仓库根目录下的 readme.md 文件Linkhttps://www.jianshu.com/p/13612fb4b224https://www.cnblogs.com/qwertWZ/archive/2013/03/26/2982231.html"
  },
  
  {
    "title": "C 语言函数指针小测试",
    "url": "/posts/function-pointer-test/",
    "categories": "function pointer, c",
    "tags": "",
    "date": "2018-09-28 15:10:54 +0800",
    





    
    "snippet": "首先看一道趣味题,来源:https://www.v2ex.com/t/492705#include &lt;stdio.h&gt;int main() {[] printf(\"%p\\n\", **********************p);return 0;}在 [] 标记内加入一条语句，使得：  程序编译通过，无错误（警告随意）；链接通过，无错误（警告随意）  程序能够运行，无崩溃和运行时...",
    "content": "首先看一道趣味题,来源:https://www.v2ex.com/t/492705#include &lt;stdio.h&gt;int main() {[] printf(\"%p\\n\", **********************p);return 0;}在 [] 标记内加入一条语句，使得：  程序编译通过，无错误（警告随意）；链接通过，无错误（警告随意）  程序能够运行，无崩溃和运行时错误  源代码为.c 文件  如果用 vs，则使用 Release 配置；用 gcc 也行  加入的语句不能忽略分号  printf 一句必须能够正常输出内容答案如下表            int(*p)();      10个字符      兼容 gcc、g++、vs                  int p(){}      9个字符      兼容 gcc，不兼容 g++、vs              p();}p(){      9个字符      兼容 gcc、g++、vs      本文主要针对第一种答案来说明一下为什么函数指针可以被无线次解引用.&amp; *说到指针,首先就一定要介绍两个操作符.  &amp; 地址操作符(address operators) 单目前缀操作符,操作数为跟在后面的表达式. eg:&amp;a,表示取操作数a的地址,也可以理解为取对象a的地址,或者取变量a的地址等等.// 在64处理器的系统模式下,地址的长度为8个字节int a;printf(\"sizeof(&amp;a)=%d\\n\",sizeof(&amp;a));**********result**********sizeof(&amp;a)=8  * 间接操作符 (indirection operators) 单目前缀操作数,同样也是跟在后面的表达式为操作数,可以使用间接操作符通过指针对象间接地访问它所指向对象的值. eg: *a,表示取指针对象a中存的地址所指向的值. (这里的表达非常绕,下面举个例子,请自行脑补)*a的举例: 超市的储物柜,每个格子都有一个唯一对应的条形码,我们认为这就是每个格子的地址,格子本身就是实实在在的三维空间,是可以放物品的.现在有两个格子a格和b格,我们把背包放进了b格,然后把印有b格条码的纸条放进了a格, 那么,a格就相当于一个指针变量, b格就相当于一个普通的变量. *a的意思就是 分两步,第一步找到a格,取出a格中存放的条码,第二步,按照条码找到b格,取出b格中的背包.  最终简化一下, *a就是背包.int b = 666;int *a;a = &amp;b;printf(\"*a=%d sizeof(*a)=%d\\n\",*a,sizeof(*a));**********result***********a=666 sizeof(*a)=4  对于间接操作符,需要特别注意的有两点:  第一,间接操作符(*)与用来声明之神类别对象的”*“不属于同种功能,虽然它们两者确实是同一个字符,unicode码点都是 \\u002a  第二,间接操作符只作用于指针类型的对象,也就是说简介操作符的的操作数必须是一个指针类型的对象.“取地址”与”解引用”通俗的讲,对一个变量的 &amp; 操作称为”取地址”对一个指针变量的 * 操作称作”解引用”.换一种角度去理解解引用，”*“的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。这个值可以是另一个地址。多级指针.如果一个指针变量存的是一个普通变量的地址,比如 int *a,只能存放一个整型变量的地址,那么这个指针叫做一级指针;如果一个指针变量存放的是另一个指针变量的地址,比如 int **, 里面存放的是一个(int *a)类型的指针变量的地址,那么这个指针变量叫二级指针,依次往下推,可以有三级指针,四级指针….直到多级指针.函数指针简单理解就是指向函数地址的指针。比如我们声明的一个C函数void func(void);//函数调用func()那么对于函数调用表达式 func() 而言， func后缀表达式就已经表示了一个指向返回类型为void，且参数列表为空的函数的指针：  void (*) (void)函数指针的通用表达形式为：  返回类型 （* cv限定符 ）（形参列表）其中，cv限定符为可选项。直接上codevoid (*p)();p=&amp;func;printf(\"sizeof(func)= %d\\n\",sizeof(func));printf(\"sizeof(p)= %d\\n\",sizeof(p));printf(\"func\\t %p = %p\\n\",&amp;func,func);printf(\"p *p\\t %p = %p = %p\\n\",&amp;p,p,*p);printf(\"p多次解引用 %p\\n\", **********************p);void (*pNull)();printf(\"pNull *p\\t %p = %p = %p\\n\",&amp;pNull,pNull,*pNull);printf(\"pNull多次解引用 %p\\n\", **********************p);**********result**********sizeof(func)= 1sizeof(p)= 8func\t 0x100000df0 = 0x100000df0p *p\t 0x7ffeefbff568 = 0x100000df0 = 0x100000df0p多次解引用 0x100000df0pNull *p\t 0x7ffeefbff560 = 0x0 = 0x0pNull多次解引用 0x0可以看出：      函数指针变量在64位系统下的大小是8，函数指针常量的大小是1。        函数指针常量中存储的内容是自身的地址（这是为什么函数指针可以被无限次解引用的关键，因为解到最后一层以后，继续解就陷入了”自己找自己“的循环）。        未赋值的函数指针变量默认指向的是地址是0x0，对存储在该地址的指针对象解引用的结果依旧是0x0，所以可以认为0x0地址的内存单元中存的是地址0x0（此处上可能有误，尚需以后讨论）。  "
  },
  
  {
    "title": "Chrome中使用英文关键词搜索中文结果",
    "url": "/posts/tips-of-google-search/",
    "categories": "google",
    "tags": "",
    "date": "2018-09-20 17:28:46 +0800",
    





    
    "snippet": "在国内,访问Google需要用一点小技巧.有时候,我们使用英文的关键词,但是搜索结果想要查看中文的.由于的这点小技巧的原因,导致Google不能够正确的识别国家和地区的设置.知乎中有一篇帖子介绍了几个修改的方法: 如何修改Chrome里Google搜索的国家和地区设置？ 这里我采取另外的一种方法来实现.      chrome地址栏中输入 chrome://settings/searchEn...",
    "content": "在国内,访问Google需要用一点小技巧.有时候,我们使用英文的关键词,但是搜索结果想要查看中文的.由于的这点小技巧的原因,导致Google不能够正确的识别国家和地区的设置.知乎中有一篇帖子介绍了几个修改的方法: 如何修改Chrome里Google搜索的国家和地区设置？ 这里我采取另外的一种方法来实现.      chrome地址栏中输入 chrome://settings/searchEngines 打开chrome中的管理搜索引擎        复制默认搜索引擎的查询网址:   {google:baseURL}search?q=%s&amp;{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQueryStats}{google:searchFieldtrialParameter}{google:iOSSearchLanguage}{google:searchClient}{google:sourceId}{google:contextualSearchVersion}ie={inputEncoding}        在上面的String后面追加 &amp;lr=lang_zh-CN, 然后添加一个搜索引擎, 名字:  Google 中文关键词: cn查询网址:  {google:baseURL}search?q=%s&amp;{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQueryStats}{google:searchFieldtrialParameter}{google:iOSSearchLanguage}{google:searchClient}{google:sourceId}{google:contextualSearchVersion}ie={inputEncoding}&amp;lr=lang_zh-CN  4.保存后,在地址栏中输入 cn+空格 ,然后再输入搜索关键字,OK,展示的搜索结果已经变成中文结果了."
  },
  
  {
    "title": "Xcode 使用技巧",
    "url": "/posts/tips-of-xcode/",
    "categories": "Xcode",
    "tags": "",
    "date": "2018-09-18 17:03:09 +0800",
    





    
    "snippet": "AlcatrazAlcatraz是一款开源的用于Xcode7的插件管理工具.Xcode8以及以后版本需要配合下面的工具来使用.update_xcode_pluginsupdate_xcode_plugins可以为Xcode中安装的插件添加UUID, 同时还能够 为Xcode8以及以上的版本解除签名,这样就可以随心所欲的使用各种Xcode插件了.Reset Xcode’s “Load Bund...",
    "content": "AlcatrazAlcatraz是一款开源的用于Xcode7的插件管理工具.Xcode8以及以后版本需要配合下面的工具来使用.update_xcode_pluginsupdate_xcode_plugins可以为Xcode中安装的插件添加UUID, 同时还能够 为Xcode8以及以上的版本解除签名,这样就可以随心所欲的使用各种Xcode插件了.Reset Xcode’s “Load Bundles” warningdefaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-10.0执行该命令,重启Xcode,可以使Xcode弹出”Load Bundles”的提示,可以重新load所有的插件.注意command末尾处的Xcode的版本号.添加删除行 快捷键 Opt+D      修改配置文件(plist)权限    sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plistsudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/        打开plist文件进行修改    open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist        找到root下的Deletions,在Deletions下添加一个Key: Delete Current Line 值为deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:        重启Xcode,设置快捷键  Preference -&gt; Key Bindings ,找到 Delete Current Line 选项,设置快捷键为 Opt+DXcode Release Build 版本号自动增加if [ $CONFIGURATION == Release ]; thenecho \"Bumping build number...\"plist=${PROJECT_DIR}/${INFOPLIST_FILE}buildnum=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"${plist}\")if [[ \"${buildnum}\" == \"\" ]]; thenecho \"No build number in $plist\"exit 2fi buildnum=$(expr $buildnum + 1)/usr/libexec/Plistbuddy -c \"Set CFBundleVersion $buildnum\" \"${plist}\"echo \"Bumped build number to $buildnum\"elseecho $CONFIGURATION \" build - Not bumping build number.\" fi使用方法 Xcode–&gt;Projet–&gt;Target–&gt;Build Phases–&gt;”+”–&gt;New Run Script Phase. 顺序放在Target Dependencies之后即可,尽量靠前.过程, 查找 Info.plist 文件的位置,使用工具 /usr/libexec/PlistBuddy 读取 CFBundleVersion 的值,+1后再写会 Info.plist 文件."
  },
  
  {
    "title": "lipo 使用简介",
    "url": "/posts/introduction-to-lipo/",
    "categories": "terminal, lipo, static library",
    "tags": "",
    "date": "2018-07-25 17:25:25 +0800",
    





    
    "snippet": "最近在开发iOS SDK, 需要使用到lipo命令, 在此简单做一下记录:lipo的使用手册➜  ~  man lipoLIPO(1)                                                                     LIPO(1)NAME       lipo - create or operate on universal files...",
    "content": "最近在开发iOS SDK, 需要使用到lipo命令, 在此简单做一下记录:lipo的使用手册➜  ~  man lipoLIPO(1)                                                                     LIPO(1)NAME       lipo - create or operate on universal filesSYNOPSIS       lipo   [-info]   [-detailed_info]   [-arch   arch_type  input_file]  ...   [       input_file]  ...   [-arch_blank  arch_type]  [-create]   [-thin   arch_type]       [-replace  arch_type  filename]  ...   [-remove  arch_type]  ...lio   [-extract       arch_type] ...  [-extract_family  arch_type]  ...   [-verify_arch  arch_type       ...]  [-output output_file] [-segalign arch_type value] ...DESCRIPTION       The  lipo  command creates or operates on ``universal'' (multi-architecture)       files.  It only ever produces one output file, and never  alters  the  input       file.  The operations that lipo performs are: listing the architecture types       in a universal file; creating a single universal file from one or more input       files;  thinning  out  a single universal file to one specified architecture       type; and extracting, replacing, and/or removing  architectures  types  from       the input file to create a single new universal output file.       Only  one option can be specified, with the exception of -arch, -arch_blank,       -output, and -segalign, which are used in combination  with  other  options.       The input_file argument is required, and only the -create option allows more       than one input_file to be specified.  The -output flag must be used,  except       with the -info and -detailed_info flags.       The  arch_type  arguments  may  be  any  of the supported architecture names       listed in the man page arch(3).简单说,lipo就是用来操作universal file的命令,也可以说成是 fat file(因为这种文件确实比较大).在iOS中其实就是用来操作静态链接库(以.a为后缀的文件 )的命令.fat file一般是指包含两种及以上CPU架构的静态链接库lipo命令的功能:  列举 .a文件 支持的architecture types.(架构类型,eg: armv7, armv7s, i386, x86_64, arm64)  合并多个 .a文件为一个.a文件  给一个 .a文件 瘦身.(剔除某一项CPU的架构类型)  提取, 替换或者移除 .a文件 文件中的某种架构使用lipo命令的注意事项  除了 -arch, -arch_black, -output, -segalign选项外,其余的选项只能指定一个. 这几个选选项需要和其它的选项混合使用  除了 -create 选项外, 其余的选项只能指定一个input file作为参数  除了 -info 和 - detailed_info 选项外, 其余的选项必须指定 -output, 可以简写为 -olipo命令的使用eg,以WechatSDK 1.8.2作为举例对象1.查看.a文件支持的CPU架构  lipo -info input_file  lipo -detailed_info input_file➜  workspace lipo -info libWeChatSDK.a Architectures in the .a文件: libWeChatSDK.a are: i386 armv7 armv7s x86_64 arm64 ➜  workspace lipo -detailed_info libWeChatSDK.aFat header in: libWeChatSDK.afat_magic 0xcafebabenfat_arch 5architecture i386    cputype CPU_TYPE_I386    cpusubtype CPU_SUBTYPE_I386_ALL    offset 108    size 3247680    align 2^2 (4)architecture armv7    cputype CPU_TYPE_ARM    cpusubtype CPU_SUBTYPE_ARM_V7    offset 3247788    size 3256064    align 2^2 (4)architecture armv7s    cputype CPU_TYPE_ARM    cpusubtype CPU_SUBTYPE_ARM_V7S    offset 6503852    size 3255048    align 2^2 (4)architecture x86_64    cputype CPU_TYPE_X86_64    cpusubtype CPU_SUBTYPE_X86_64_ALL    offset 9758904    size 3363856    align 2^3 (8)architecture arm64    cputype CPU_TYPE_ARM64    cpusubtype CPU_SUBTYPE_ARM64_ALL    offset 13122760    size 3704912    align 2^3 (8)➜  workspace 2..a文件 CPU架构拆分  lipo 静态库源文件路径 -thin CPU架构名称 -output 拆分后文件存放路径➜  workspace lipo -info libWeChatSDK-armv7 input file libWeChatSDK-armv7 is not a fat fileNon-fat file: libWeChatSDK-armv7 is architecture: armv73.合并两个 .a文件s  lipo -create 静态库存放路径1  静态库存放路径2 …  -output 整合后存放的路径➜  workspace lipo -create libWeChatSDK-armv7 libWeChatSDK-i386 -o libWeChatSDK-i386+armv7➜  workspace lipo -info libWeChatSDK-i386+armv7 Architectures in the fat file: libWeChatSDK-i386+armv7 are: armv7 i386 ➜  workspace ➜  workspace lipo -create libWeChatSDK.a TYRZSD.a -o combine-library.afatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: libWeChatSDK.a and TYRZSD.a have the same architectures (i386) and can't be in the same fat output file这里需要注意一下,如果要合并的两个.a 文件含有相同的架构的话,会报如上的错误. 这种情况下怎么合并,可参照下一个章节4.用 lipo 删除某些平台  $ lipo input_file -remove i386 -output output_file➜  workspace lipo libWeChatSDK.a -remove i386 -o libWeChatSDK-noi386➜  workspace lipo -info libWeChatSDK-noi386 Architectures in the fat file: libWeChatSDK-noi386 are: armv7 armv7s x86_64 arm64 lipo命令合并.a文件, detail1.分离出上述不同 .a 文件单独支持的架构版本，比如上述 libWeChatSDK.a 和 TYRZSD.a 支持 armv7 armv7s i386 x86_64 arm64，那么就需要分离出单独支持armv7 armv7s i386 x86_64 arm64的 .a 文件➜  workspace lipo libWeChatSDK.a -thin armv7 -o libWeChatSDK-armv7➜  workspace lipo TYRZSD.a -thin armv7 -o TYRZSD-armv72.分离出.a库的目标文件（.o)   ar -x 静态链接库因为 .a 库分离出来的目标文件 .o  会很多, 所以, 最好是在工作空间根据不同的CPU建立不同的文件夹➜  workspace mkdir armv7➜  workspace cd armv7 ➜  armv7 ➜  armv7 ar -x ../libWeChatSDK-armv7 ➜  armv7 lsAppCommunicate.o          MTAPlugin.o               OpenUDID.oAppCommunicateData.o      MTAPluginIDFA.o           WXApi.oGCDAsyncSocket.o          MTAPluginInstall.o        WXApiObject.oMTA.o                     MTAPluginNotify.o         WXLogUtil.oMTABaseFunction.o         MTAReachability.o         WapAuthHandler.oMTAConfig.o               MTASendItem.o             WeChatApiUtil.oMTADataConfigHolder.o     MTASocket.o               WeChatRegister.oMTAEnv.o                  MTASpeedTestPlugin.o      WechatAuthSDK.oMTAEvent.o                MTAStore.o                __.SYMDEFMTAExtStoragePlugin.o     MTATempID.o               base64.oMTAHelper.o               MTAWX.oMTAMidPlugin.o            NSMutableArray+MTAQueue.o➜  armv7 ar -x ../TYRZSD-armv7 ➜  armv7 lsAppCommunicate.o          MTAReachability.o         UAOpenInfo.oAppCommunicateData.o      MTASendItem.o             UASession.oGCDAsyncSocket.o          MTASocket.o               UATimer.oMTA.o                     MTASpeedTestPlugin.o      UAUtil.oMTABaseFunction.o         MTAStore.o                WXApi.oMTAConfig.o               MTATempID.o               WXApiObject.oMTADataConfigHolder.o     MTAWX.o                   WXLogUtil.oMTAEnv.o                  NSMutableArray+MTAQueue.o WapAuthHandler.oMTAEvent.o                OpenUDID.o                WeChatApiUtil.oMTAExtStoragePlugin.o     TYRZSDK.o                 WeChatRegister.oMTAHelper.o               TYRZSDK_vers.o            WechatAuthSDK.oMTAMidPlugin.o            UAAuthViewController.o    __.SYMDEFMTAPlugin.o               UACrypto.o                __.SYMDEF SORTEDMTAPluginIDFA.o           UAHTTP.o                  base64.oMTAPluginInstall.o        UALogReport.oMTAPluginNotify.o         UANetwork.o3.对支持同个架构的.o文件，进行合并成静态库。  libtool -static -o output_file *.o➜  armv7 libtool -static -o ../combine-library-armv7 *.o➜  armv7 ls ..TYRZSD-armv7          armv7                 libWeChatSDK-armv7    libWeChatSDK.aTYRZSD.a              combine-library-armv7 libWeChatSDK-i386➜  armv7 4.合成支持全部架构的通用静态库如果之前的步骤不出错, 就会得到5个.a文件; combine-library-armv7 combine-library-armv7s combine-library-i386 combine-library-x86_64 combine-library-arm64➜  workspace lipo -create combine-library-armv7 combine-library-armv7s combine-library-i386 combine-library-x86_64 combine-library-arm64 -o combine-library​    combine-library 就是最终需要的 .a 库参考链接合并多个.a文件"
  },
  
  {
    "title": "秘钥格式 证书",
    "url": "/posts/rsa-key-structuress/",
    "categories": "rsa, der, pem, openssl",
    "tags": "",
    "date": "2018-07-18 17:17:34 +0800",
    





    
    "snippet": "RSA秘钥存储一般有两种格式  DER  PEMDERDER: Distinguished Encoding Rules(可辨别编码规则)，是ASN.1的一种。 ASN.1: Abstract Syntax Notation One(抽象语法标记)，ASN.1是一种 ISO/ITU-T 标准，描述了一种对数据进行表示、编码、传输和解码的数据格式。它提供了一整套正规的格式用于描述对象的结构，而...",
    "content": "RSA秘钥存储一般有两种格式  DER  PEMDERDER: Distinguished Encoding Rules(可辨别编码规则)，是ASN.1的一种。 ASN.1: Abstract Syntax Notation One(抽象语法标记)，ASN.1是一种 ISO/ITU-T 标准，描述了一种对数据进行表示、编码、传输和解码的数据格式。它提供了一整套正规的格式用于描述对象的结构，而不管语言上如何执行及这些数据的具体指代，也不用去管到底是什么样的应用程序。证书信息一般以二进制的DER格式存储在文件中以供RSA，SSL使用。PEM ( Privacy Enhanced Mail )DER一般是二进制文件形式存储，打印性较差，因此对DER内容进行base64编码，并补充说明key类型的头和尾就构成了PEM-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMYfnvWtC8Id5bPKae5yXSxQTt+Zpul6AnnZWfI2TtIarvjHBFUtXRo96y7hoL4VWOPKGCsRqMFDkrbeUjRrx8iL914/srnyf6sh9c8Zk04xEOpK1ypvBz+Ks4uZObtjnnitf0NBGdjMKxveTq+VE7BWUIyQjtQ8mbDOsiLLvh7wIDAQAB-----END PUBLIC KEY-----因此PEM,DER实质内容是相同的。  上面提到key以一定的结构存储的，不同的结构，补充的元信息也不同主要有两种组织形式PKCS#1,PKCS#8PEM的简单介绍PEM全称是Privacy Enhanced     ，该标准定义了加密一个准备要发送邮件的标准 。它的基本流程是这样的：      信息转换为ASCII码或其它编码方式；          使用对称算法加密转换了的邮件信息；          使用BASE64对加密后的邮件信息进行编码；          使用一些头定义对信息进行封装，这些头信息格式如下（不一定都需要，可选的 ）：              Proc-Type,4:ENCRYPTED    DEK-Info: cipher-name, ivec            其中，第一个头信息标注了该文件是否进行了加密，该头信息可能的值包括ENCRY PTED(信息已经加密和签名)、MIC-ONLY(信息经过数字签名但没有加密)、MIC-CLEAR(信 息经过数字签名但是没有加密、也没有进行编码，可使用非PEM格式阅读)以及CLEAR(信 息没有签名和加密并且没有进行编码，该项好象是openssl自身的扩展，但是并没有真正 实现)；；第二个头信息标注了加密的算法以及使用的ivec参量，ivec其实在这儿提供的 应该是一个随机产生的数据序列，与块加密算法中要使用到的初始化变量（IV）不一样 。          在这些信息的前面加上如下形式头标注信息：      —–BEGIN PRIVACY-ENHANCED MESSAGE—–       在这些信息的后面加上如下形式尾标注信息：      —–END PRIVACY-ENHANCED MESSAGE—–    上面是openssl的PEM文件的基本结构，需要注意的是，Openssl并没有实现PEM的全 部标准，它只是对openssl中需要使用的一些选项做了实现，详细的PEM格式，请参考RF C1421－1424。  下面是一个PEM编码的经过加密的DSA私钥的例子：  -----BEGIN DSA PRIVATE KEY-----     Proc-Type: 4,ENCRYPTED     DEK-Info: DES-EDE3-CBC,F80EEEBEEA7386C4     BASE64 ENCODED DATA-----END DSA PRIVATE KEY-----     有时候PEM编码的东西并没有经过加密，只是简单进行了BASE64编码，下面是一个没 有加密的证书请求的例子：-----BEGIN CERTIFICATE REQUEST-----     BASE64 ENCODED DATA-----END CERTIFICATE REQUEST-----     可以看到，该文件没有了前面两个头信息。大家如果经常使用openssl的应用程序， 就对这些文件格式很熟悉了。PKCS#1PKCS#1结构仅为RSA设计  PEM形式PublicKey-----BEGIN RSA PUBLIC KEY-----BASE64 ENCODED DATA-----END RSA PUBLIC KEY-----PrivateKey-----BEGIN RSA PRIVATE KEY-----BASE64 ENCODED DATA-----END RSA PRIVATE KEY-----  DER的结构PublicKeyRSAPublicKey ::= SEQUENCE {modulus           INTEGER,  -- npublicExponent    INTEGER   -- e}PrivateKeyRSAPrivateKey ::= SEQUENCE {version           Version,modulus           INTEGER,  -- npublicExponent    INTEGER,  -- eprivateExponent   INTEGER,  -- dprime1            INTEGER,  -- pprime2            INTEGER,  -- qexponent1         INTEGER,  -- d mod (p-1)exponent2         INTEGER,  -- d mod (q-1)coefficient       INTEGER,  -- (inverse of q) mod potherPrimeInfos   OtherPrimeInfos OPTIONAL}PKCS#8X509,SSL支持的算法不仅仅是RSA，因此产生了更具有通用性的PKCS#8  PEMPublicKey-----BEGIN PUBLIC KEY-----BASE64 ENCODED DATA-----END PUBLIC KEY-----PrivateKey-----BEGIN PRIVATE KEY-----BASE64 ENCODED DATA-----END PRIVATE KEY-----  DERPublicKeyPublicKeyInfo ::= SEQUENCE {    algorithm       AlgorithmIdentifier,    PublicKey       BIT STRING}AlgorithmIdentifier ::= SEQUENCE {    algorithm       OBJECT IDENTIFIER,    parameters      ANY DEFINED BY algorithm OPTIONAL}RSA公钥的OID 为 1.2.840.113549.1.1.1PrivateKeyPrivateKeyInfo ::= SEQUENCE {    version         Version,    algorithm       AlgorithmIdentifier,    PrivateKey      BIT STRING}AlgorithmIdentifier ::= SEQUENCE {    algorithm       OBJECT IDENTIFIER,    parameters      ANY DEFINED BY algorithm OPTIONAL}RSA私钥的OID 为 1.2.840.113549.1.1.1与PKCS#1相比将文件包含的加密算法和Key分开存储，因此可以存储其他加密算法的KeySSLSSL - Secure Sockets Layer,现在应该叫”TLS”,但由于习惯问题,我们还是叫”SSL”比较多.http协议默认情况下是不加密内容的,这样就很可能在内容传播的时候被别人监听到,对于安全性要求较高的场合,必须要加密,https就是带加密的http协议,而https的加密是基于SSL的,它执行的是一个比较下层的加密,也就是说,在加密前,你的服务器程序在干嘛,加密后也一样在干嘛,不用动,这个加密对用户和开发者来说都是透明的.More:[维基百科]OpenSSL - 简单地说,OpenSSL是SSL的一个实现,SSL只是一种规范.理论上来说,SSL这种规范是安全的,目前的技术水平很难破解,但SSL的实现就可能有些漏洞,如著名的”心脏出血”.OpenSSL还提供了一大堆强大的工具软件,强大到90%我们都用不到.证书标准X.509 - 这是一种证书标准,主要定义了证书中应该包含哪些内容.其详情可以参考RFC5280,SSL使用的就是这种证书标准.相关的文件扩展名这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式.CRT - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.CER - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.KEY - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER.查看KEY的办法: openssl rsa -in mykey.key -text -noout如果是DER格式的话,同理应该这样了: openssl rsa -in mykey.key -text -noout -inform derCSR - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.查看的办法: openssl req -noout -text -in my.csr (如果是DER格式的话照旧加上-inform der,这里不写了)PFX/P12 - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.生成pfx的命令类似这样:openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.JKS - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫”keytool”的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了.证书编码的转换PEM转为DER openssl x509 -in cert.crt -outform der -out cert.derDER转为PEM openssl x509 -in cert.crt -inform der -outform pem -out cert.pem(提示:要转换KEY文件也类似,只不过把x509换成rsa,要转CSR的话,把x509换成req…)使用openssl生成秘钥生成2048位RSA秘钥，使用3des加密秘钥文件private.pem  openssl genrsa -des3 -out private.pem 2048导出公钥，默认为PKCS#8结构  openssl rsa -in private.pem -outform PEM -pubout -out public.pem导出PKCS#1结构的公钥，注意openssl版本，老版本可能不支持  openssl rsa -in private.pem -outform DER -RSAPublicKey_out -out public_pcks1.cer导出无加密保护的私钥  openssl rsa -in private.pem -out private_unencrypted.pem -outform PEM参考资料秘钥格式ASN.1 key structures in DER and PEM[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](https://www.cnblogs.com/guogangj/p/4118605.html)openssl之PEM系列之1—PEM编码文件结构介绍"
  },
  
  {
    "title": "Mac OS X 下生成RSA密钥对",
    "url": "/posts/generate-rsa-key-on-mac-os-x/",
    "categories": "mac os x, terminal, rsa",
    "tags": "",
    "date": "2018-07-18 15:15:18 +0800",
    





    
    "snippet": "Mac自带OpenSSL,可以利用openssl来生成RSA密钥对1.生成私钥,1024指密钥的长度➜  test openssl genrsa -out private_key.pem 1024Generating RSA private key, 1024 bit long modulus.....................................................",
    "content": "Mac自带OpenSSL,可以利用openssl来生成RSA密钥对1.生成私钥,1024指密钥的长度➜  test openssl genrsa -out private_key.pem 1024Generating RSA private key, 1024 bit long modulus.......................................................................++++++.......................................................................++++++e is 65537 (0x10001)➜  test cat private_key.pem -----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQDJrT1W3ZyBAYIMNb0XDBQTIGw4TpbrLelQ/K6Yl6abciAUAZNnj5EHlFhMvpe3iHU0xPIcTM0IM9ZnMjecikHC4lBJ0JmXEsHf4j6Cf2+KRFHTaxPPhqf65wiGvduTf70xOCvaPeyYVu4x69jm2rtxOeVvF1PJSrV+ZDCoDmYD3QIDAQABAoGAToUwmJ13zZJ0u6RAlrSRLFE3UUTn5XDeojV/FNIWf/cTHjbu2SdAZB8Rse+SylZKq9zyFqqgOU1VcKBQnpYFu9XFvpoP/xGC/T99MN3chBaQY4wY80FM8NEjWZbPZPTczE/HypE+J14/0i0x6jujhFiAAmcE/1ivRzRGvo6qC9ECQQDmcki4jO4VTju7+WWINatj36pPn/JVUFH8Tqw98tQLg5VMPFfPNsl9L7CSqACCFvl1wiERuxfunRB09dNHb4sHAkEA4ApECRgqo+/7Smd2WTa4hSQ+aYs6J7+9e8zjgfIuYBn5ONOsuIuVVntHyhSc2Xzbp1wkakCzTy/Tyw02kGCs+wJBAMFLHPpHo7AVRf9+yo48zjzgr99H/yFWVN54MvtnQjtCLKmcd97kSo+Jv+bTqlFz6dy/b7OKpiFMdzBTvdtOkWMCQQC621ULUMCfopQv5kLq/ZzATw5O8PQ8Gstq6eQGiXrsZD1cjA9Oi/yt+HxTqwV2z5BT8aHdjMEAlp9Kh2au3DLpAkB+koitVpjxmWyzQ/Sl4Xa843oR+qneofZZ3m9johtn+7NQu3JXI1xBckxmZ4DtODtC7MUIqlOEej5OT9QVwljv-----END RSA PRIVATE KEY-----2.生成公钥➜  test openssl rsa -in private_key.pem -pubout -out public_key.pemwriting RSA key➜  test cat public_key.pem -----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJrT1W3ZyBAYIMNb0XDBQTIGw4TpbrLelQ/K6Yl6abciAUAZNnj5EHlFhMvpe3iHU0xPIcTM0IM9ZnMjecikHC4lBJ0JmXEsHf4j6Cf2+KRFHTaxPPhqf65wiGvduTf70xOCvaPeyYVu4x69jm2rtxOeVvF1PJSrV+ZDCoDmYD3QIDAQAB-----END PUBLIC KEY-----3.使用pkcs8命令转换私钥格式 PKCS标准➜  test openssl pkcs8 -topk8 -inform PEM -in private_key.pem -outform PEM -nocrypt-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAMmtPVbdnIEBggw1vRcMFBMgbDhOlust6VD8rpiXpptyIBQBk2ePkQeUWEy+l7eIdTTE8hxMzQgz1mcyN5yKQcLiUEnQmZcSwd/iPoJ/b4pEUdNrE8+Gp/rnCIa925N/vTE4K9o97JhW7jHr2Obau3E55W8XU8lKtX5kMKgOZgPdAgMBAAECgYBOhTCYnXfNknS7pECWtJEsUTdRROflcN6iNX8U0hZ/9xMeNu7ZJ0BkHxGx75LKVkqr3PIWqqA5TVVwoFCelgW71cW+mg//EYL9P30w3dyEFpBjjBjzQUzw0SNZls9k9NzMT8fKkT4nXj/SLTHqO6OEWIACZwT/WK9HNEa+jqoL0QJBAOZySLiM7hVOO7v5ZYg1q2Pfqk+f8lVQUfxOrD3y1AuDlUw8V882yX0vsJKoAIIW+XXCIRG7F+6dEHT100dviwcCQQDgCkQJGCqj7/tKZ3ZZNriFJD5pizonv717zOOB8i5gGfk406y4i5VWe0fKFJzZfNunXCRqQLNPL9PLDTaQYKz7AkEAwUsc+kejsBVF/37KjjzOPOCv30f/IVZU3ngy+2dCO0IsqZx33uRKj4m/5tOqUXPp3L9vs4qmIUx3MFO9206RYwJBALrbVQtQwJ+ilC/mQur9nMBPDk7w9Dway2rp5AaJeuxkPVyMD06L/K34fFOrBXbPkFPxod2MwQCWn0qHZq7cMukCQH6SiK1WmPGZbLND9KXhdrzjehH6qd6h9lneb2OiG2f7s1C7clcjXEFyTGZngO04O0LsxQiqU4R6Pk5P1BXCWO8="
  },
  
  {
    "title": "低版本Xcode调试高版本的iOS系统",
    "url": "/posts/debug-application-on-newer-ios-from-an-older-xcode/",
    "categories": "xcode, ios",
    "tags": "",
    "date": "2018-07-13 17:10:45 +0800",
    





    
    "snippet": "在使用Xcode作为iOS开发的主IDE的情况下,遇到这种情况最好是AppStore中安装最新版本的Xcode.下面的方案只是一个临时debug的方案1.找到不支持的iOS版本,Xcode中可以使用快捷键: Cmd+Shift+2 ,下图表示不支持的版本是 iOS 12.0 (16A5318d)2.Terminal cd 到Xcode DeviceSupport 目录下  /Applicat...",
    "content": "在使用Xcode作为iOS开发的主IDE的情况下,遇到这种情况最好是AppStore中安装最新版本的Xcode.下面的方案只是一个临时debug的方案1.找到不支持的iOS版本,Xcode中可以使用快捷键: Cmd+Shift+2 ,下图表示不支持的版本是 iOS 12.0 (16A5318d)2.Terminal cd 到Xcode DeviceSupport 目录下  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport➜ cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport➜  DeviceSupport ls10.0         10.3         11.2         8.0          8.3          9.1         10.1         11.0         11.3         8.1          8.4          9.210.2         11.1         11.4 (15F79) 8.2          9.0          9.3➜  DeviceSupport 3.Important 去网上搜索真机支持包,可以输出关键字”xcode 12.0 (16A5318d) 真机支持包”,一般情况下百度网盘中都会有,下载下来,copy到2的目录下,然后重启Xcode,搞定4.不下载真机支持包的方案直接拷贝一个DeviceSupport现有的支持版本,重命名为 12.0 (16A5318d), 重启Xcode后搞定.注意这里需要用到root权限,命令前加sudo即可.➜  DeviceSupport sudo cp -rf 11.4\\ \\(15F79\\) 12.0\\ \\(16A5318d\\) Password:➜  DeviceSupport ls10.0            11.0            11.4 (15F79)    8.2             9.110.1            11.1            12.0 (16A5318d) 8.3             9.210.2            11.2            8.0             8.4             9.310.3            11.3            8.1             9.0             xinchun➜  DeviceSupport "
  },
  
  {
    "title": "xcodebuild 使用注意事项",
    "url": "/posts/xcodebuild-shi-yong-zhu-yi-shi-xiang/",
    "categories": "xcode, xcodebuild",
    "tags": "",
    "date": "2018-05-16 11:17:34 +0800",
    





    
    "snippet": "##1.xcodebuild cocoapod CONFIGURATION_BUILD_DIR ###现象``` bash xcodebuild命令用法示例xcodebuild -sdk iphoneos -configuration ${BUILD_CONFIGURATION} -derivedDataPath=”../build” -workspace ‘../SohuInk.xcwor...",
    "content": "##1.xcodebuild cocoapod CONFIGURATION_BUILD_DIR ###现象``` bash xcodebuild命令用法示例xcodebuild -sdk iphoneos -configuration ${BUILD_CONFIGURATION} -derivedDataPath=”../build” -workspace ‘../SohuInk.xcworkspace’ -scheme ‘SohuInk_Jenkins’ -archivePath “../SohuInk_Jenkins.xcarchive” archive如果项目中使用了cocoapod并且xcodebuild 命令参数中指定了CONFIGURATION_BUILD_DIR并且值为相对路径,此时在Xcode Tools Version 5.0下的xcodebuild构建会报如下错误:  ``` bash error_infold: warning: directory not found for option '-L/XXXX/XXXX/pop'ld: library not found for -lAFNetworkingclang: error: linker command failed with exit code 1 (use -v to see invocation)** ARCHIVE FAILED **The following build commands failed:\tLd /Users/XXXX/XXXX/Objects-normal/arm64/SohuInk normal arm64\tLd /Users/XXXX/XXXX normal armv7(2 failures)###解决方案####方案1,不好用Xcode Tools version 5.0 支持参数 derivedDataPath 可以放弃CONFIGURATION_BUILD_DIR配置指定该参数,我实际操作是发现使用相对路径的情况下,虽然可以archive success,但是build的目录没有改变,依然在xcode默认的derivedData目录下.####方案2,OKCONFIGURATION_BUILD_DIR的值指定为绝对路径,一切OK,可成功archive.###结论  xcodebuild中的CONFIGURATION_BUILD_DIR值需要使用绝对路径##参考链接Stackoverflow上关于使用xcodebuild CONFIGURATION_BUILD_DIR最好使用绝对路径的说明 @Chilloutmanhttps://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html"
  },
  
  {
    "title": "Mac Terminal 快捷键记录",
    "url": "/posts/mac-terminal-shortcut-keys/",
    "categories": "mac, terminal",
    "tags": "",
    "date": "2018-05-01 18:16:04 +0800",
    





    
    "snippet": "Mac 命令行编辑快捷键的方法，对Mac的应用有所帮助。###Mac 命令行命令Command      | Description ———— | ————- history      | 显示命令历史列表  ↑(Ctrl+p)    | 显示上一条命令↓(Ctrl+n)    | 显示下一条命令clear        | 清除 shell 提示屏幕exit         | 注销his...",
    "content": "Mac 命令行编辑快捷键的方法，对Mac的应用有所帮助。###Mac 命令行命令Command      | Description ———— | ————- history      | 显示命令历史列表  ↑(Ctrl+p)    | 显示上一条命令↓(Ctrl+n)    | 显示下一条命令clear        | 清除 shell 提示屏幕exit         | 注销history      | 显示命令历史reset        | 刷新 shell 提示屏幕 ###Mac 命令行编辑快捷键Command      | Description ———— | ————- ↑(Ctrl+p)    | 显示上一条命令↓(Ctrl+n)    | 显示下一条命令!num         | 执行命令历史列表的第num条命令!!           | 执行上一条命令!?string?    | 执行含有string字符串的最新命令Ctrl+r       | 然后输入若干字符，开始向上搜索包含该字符的命令，继续按  Ctrl+r，搜索上一条匹配的命令Ctrl+s       | 与Ctrl+r类似,只是正向检索→(Ctrl+f)    | 光标向前移动一个字符,相当与-&gt;←(Ctrl+b)    | 光标向后移动一个字符,相当与&lt;-opt+←        | 光标向前移动一个单词opt+→        | 光标向后移动一个单词ls !$        | 执行命令ls，并以上一条命令的参数为其参数Ctrl+a       | 移动到当前行的开头Ctrl+e       | 移动到当前行的结尾Esc+b        | 移动到当前单词的开头Esc+f        | 移动到当前单词的结尾Ctrl+l       | 清屏Ctrl+u       | 剪切命令行中光标所在处之前的所有字符（不包括自身）Ctrl+k       | 剪切命令行中光标所在处之后的所有字符（包括自身）Ctrl+d       | 删除光标所在处字符Ctrl+h       | 删除光标所在处前一个字符Ctrl+y       | 粘贴刚才所删除的字符Ctrl+w       | 剪切光标所在处之前的一个词（以空格、标点等为分隔符）Ctrl+t       | 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符Ctrl+v       | 插入特殊字符,如Ctrl+v+Tab加入Tab字符键 ,先按下Ctrl+V,抬起后再按下Tab Esc+t        | 颠倒光标所在处及其相邻单词的位置Ctrl+c       | 删除整行Ctrl+(x u)   | 按住Ctrl的同时再先后按x和u，撤销刚才的操作Ctrl+s       | 挂起当前shellCtrl+q       | 重新启用挂起的shell                      ###下面的应用可能稍稍高级一点点Command                 | Description ———————– | ————- # !!                   | 上一条命令# !-n                  | 倒数第N条历史命令# !-n:p                | 打印上一条命令（不执行）# !?string?            | 最新一条含有“string”的命令# !-n:gs/str1/str2/    | 将倒数第N条命令的str1替换为str2，并执行（若不加g,则仅替换第一个)###参考http://notes.11ten.net/mac-command-line-editing-commonly-used-shortcut-keys.html"
  },
  
  {
    "title": "Git Commands 使用手记",
    "url": "/posts/git-command-shi-yong-shou-ji/",
    "categories": "git",
    "tags": "",
    "date": "2018-04-30 17:44:10 +0800",
    





    
    "snippet": "本文主要用来记录自己在使用Git的过程遇到的一些问题及解决方案.##1.Git push error: dst refspec dev_1.0 matches more than one.导火索Git 删除远程库中的一个分支的时候报错,如下:  git push origin --delete dev_1.0  error: dst refspec dev_1.0 matches more ...",
    "content": "本文主要用来记录自己在使用Git的过程遇到的一些问题及解决方案.##1.Git push error: dst refspec dev_1.0 matches more than one.导火索Git 删除远程库中的一个分支的时候报错,如下:  git push origin --delete dev_1.0  error: dst refspec dev_1.0 matches more than one.  error: failed to push some refs to 'git@xxxxx:xxx/xxx.git'  出现这个错误的原因是在于远程Git服务器上名称为dev_1.0的有两个对象：一个是tag，一个是branch；在执行 git push origin –delete dev_1.0这个命令时Git服务器不知道要删除哪个。###解决办法删除名称为dev_1.0的branch：git push origin :refs/heads/dev_1.0删除名称为dev_1.0的tag:git push origin :refs/tags/dev_1.0"
  },
  
  {
    "title": "获取mobileprovision文件的UUID",
    "url": "/posts/get-mobileprovison-uuid/",
    "categories": "ios, xcode, provisioning profile",
    "tags": "",
    "date": "2017-12-02 13:06:26 +0800",
    





    
    "snippet": "###Provision Profile 文件在Mac OS中的默认存放位置:  ~/Library/MobileDevice/Provisioning Profiles###1.通过GUI的工具查看:iPhone配置实用工具###2.命令行工具0xc010d/mobileprovision-read安装方法在 Terminal中键入下面的命令并回车``` bash Terminalcurl...",
    "content": "###Provision Profile 文件在Mac OS中的默认存放位置:  ~/Library/MobileDevice/Provisioning Profiles###1.通过GUI的工具查看:iPhone配置实用工具###2.命令行工具0xc010d/mobileprovision-read安装方法在 Terminal中键入下面的命令并回车``` bash Terminalcurl https://raw.githubusercontent.com/0xc010d/mobileprovision-read/master/main.m | clang -framework Foundation -framework Security -o /usr/local/bin/mobileprovision-read -x objective-c -####mobileprovision-read 命令介绍  ``` bash Terminal  ➜  ~ mobileprovision-read mobileprovision-read -- mobileprovision files querying tool.USAGEmobileprovision-read -f fileName [-o option]OPTIONS    type – prints mobileprovision profile type (debug, ad-hoc, enterprise, appstore)    appid – prints application identifierWill print raw provision's plist if option is not specified.You can also use key path as an option.EXAMPLESmobileprovision-read -f test.mobileprovision -o type    Prints profile typemobileprovision-read -f test.mobileprovision -o UUID    Prints profile UUIDmobileprovision-read -f test.mobileprovision -o ProvisionedDevices    Prints provisioned devices UDIDsmobileprovision-read -f test.mobileprovision -o Entitlements.get-task-allow    Prints 0 if profile doesn't allow debugging 1 otherwise➜  ~ eg:mobileprovision-read -f “filepath” -o UUID  -&gt; 打印输出mobileprovision的UUIDmobileprovision-read -f “provisoning-profile-file-path” -o ProvisionedDevices  -&gt; 列出描述文件所包含的device UUID列表###3.自定义脚本使用了苹果的security和PlistBuddy工具.mobileapp.sh使用方法:./mobileapp.sh “provisoning-profile-file-path”注意,如果filepath中含有空格,请将filepath加上双引号.eg:bash Terminal➜  Desktop ./mobilepp.sh \"/Users/newspring/Library/MobileDevice/Provisioning Profiles/1213b96b-4ac1-4365-ae45-350eb6beadf2.mobileprovision\" security: SecPolicySetValue: One or more parameters passed to a function were not valid.UUID is:1213b96b-4ac1-4365-ae45-350eb6beadf2###参考链接https://my.oschina.net/ioslighter/blog/494342"
  },
  
  {
    "title": "Install macOS by U Disk",
    "url": "/posts/install-macos-by-u-disk/",
    "categories": "macOS",
    "tags": "",
    "date": "2017-05-29 16:46:55 +0800",
    





    
    "snippet": "动手之前,TimeMachine备份数据!动手之前,TimeMachine备份数据!动手之前,TimeMachine备份数据!  1.8GB或者更大容量的U盘,Apple建议不小于12G  2.使用 应用程序–&gt;实用工具–&gt;磁盘工具 格盘 (参考图片 格盘)          名称 Sierra 使用其它名称注意在后面的Terminal命令中作出替换      格式 Mac OS...",
    "content": "动手之前,TimeMachine备份数据!动手之前,TimeMachine备份数据!动手之前,TimeMachine备份数据!  1.8GB或者更大容量的U盘,Apple建议不小于12G  2.使用 应用程序–&gt;实用工具–&gt;磁盘工具 格盘 (参考图片 格盘)          名称 Sierra 使用其它名称注意在后面的Terminal命令中作出替换      格式 Mac OS 扩展 (日志式)      方案 GUID 分区图        3.AppStore中下载Sierra系统.下载耗时较长,可以冲杯咖啡,休息一下去了.(参照图片 原版安装包)  4.使用Terminal(应用程序→实用工具→终端),输入命令`sudo /Applications/Install\\ macOS\\ Sierra.app/Contents/Resources/createinstallmedia –volume /Volumes/Sierra –applicationpath /Applications/Install\\ macOS\\ Sierra.app –nointeraction`耐心等待,直至出现Done.启动U盘制作结束.  5.重新启动PC,按照Option不放,直到出现启动菜单选项.###附几张网络图片,仅供参考格盘原版安装包步骤4,参考图###参考资料创建可引导的macOS安装器,https://support.apple.com/zh-cn/HT201372iPlaySoft简单制作 macOS Sierra 正式版U盘USB启动安装盘方法教程"
  },
  
  {
    "title": "MacBook Pro (13-inch Mid 2012) 升级SSD和16G内存",
    "url": "/posts/update-ssd-and-meomory-for-macbook-pro-13-inch-mid-2012/",
    "categories": "MacBook Pro, Mac OS X, SSD",
    "tags": "",
    "date": "2017-05-29 11:52:22 +0800",
    





    
    "snippet": "##我的MacBook Pro电脑配置机器型号: MacBook Pro (13-inch, Mid 2012) 普通屏根据苹果官网的查询 苹果官网的MBP型号查询 型号应该是MD101或者MD102处理器: 2.5 GHz Intel Core i5原配内存: 2G*2 1600Hz DDR3原配硬盘: 500G 机械硬盘虽然现在来看,这个配置可以卡出翔来,厚度堪当砖,但是回想一下,对于当...",
    "content": "##我的MacBook Pro电脑配置机器型号: MacBook Pro (13-inch, Mid 2012) 普通屏根据苹果官网的查询 苹果官网的MBP型号查询 型号应该是MD101或者MD102处理器: 2.5 GHz Intel Core i5原配内存: 2G*2 1600Hz DDR3原配硬盘: 500G 机械硬盘虽然现在来看,这个配置可以卡出翔来,厚度堪当砖,但是回想一下,对于当时还是在装有Windows系统的Samsung本子上, 用GNUstep来Build&amp;Run Objective_C 的我来说, 这简直就是女神一般的存在.在升级到macOS Sierra后,我已经再也无法忍受启动Xcode时候的无限风火轮.原来打算购买新的MacBook Pro,去官网看了一下,新的本子为了追求超薄,内存什么的都采用了焊接的工艺,换句话说,要买就得直接上顶配,不然以后没法升级.大体预算了一下,需要软妹币小两万.摸了摸自己的口袋,想了想老丈人的礼金,含着泪默默地关闭了apple.com.打开了京东.##升级方案SSD的升级方案,按照网上的介绍有三种:  1.主硬盘位保持原装机械硬盘不动,光驱位替换为SSD  2.主硬盘位换为SSD,光驱位换为拆下来的机械硬盘  3.主硬盘位换为SSD,光驱位不动.在此,我的建议是,如果是Fusion类型的话(机械硬盘和SSD混用,方案1或者方案2),首先查看一下光驱位和主硬盘位的SATA串口的类型.如果只有一个是SATA3,那么SSD放在SATA3串口的位置.如果都是SATA3,那么主硬盘位放机械硬盘,光驱位放SSD,因为主硬盘会有SMS保护(SMS是什么后面会有介绍).但具体的要根据自己的实际情况,比如说因为光驱位的供电模式等原因造成的SSD不识别,那只能把SSD放在主硬盘位.对我来说,我采用的是方案3,主要原因有下:1.主硬盘位对于硬盘的保护比较好,垂直位置上和键盘不重叠,而光驱位位于键盘的正下方,相对来说不如主硬盘位稳定.2.哥是一个纯粹的人,要什么Fusion啊,要存储的话直接上外置硬盘就好了.###查看主硬盘位和光驱位SATA类型的方法关于本机–&gt;概览–&gt;系统报告–&gt;SATA/SATA Express. 如图,看链接速度,SATA3为6千兆位. SATA2为3千兆位. 我的CD-ROM的协商的链接速度:1.5 千兆位. 原装硬盘的协商的链接速度为3千兆位,说明原装的机械硬盘上的串口速度最高到SATA2.##购买的SSD和内存购买时间正巧赶上了京东618店庆搞活动.SSD我买的是 SAMSUNG 850 EVO 250G SATA3内存我买的是金士顿的8G内存条.买两条.按照Apple官网的内存升级指南2012Mid的MBP最高可以升级到4G*2,可能是当年的单条8G还不是很流行,我实测直接升级到8G*2没有任何问题.另外还购买了SSK的2.5英寸的USB 3.0硬盘盒,用于装替换下来的原装硬盘.##替换SSD先来一张拆机前的准备图:做好Time Machine后,开始更换SSD,先拆开后盖,注意拆机前先洗手,祷告,触摸金属,释放自身静电,祈求上帝保佑:拆下来的螺丝,按照相对位置放好,便于以后重新安装上去. 后壳周边没有任何的暗扣,用塑料吸盘轻轻一吸就能起来.我曾经拆过三星,宏碁还有联想的笔记本(为了清灰,说多了都是泪),但是不得不说MBP内部光驱,硬盘,主板,风扇,电池的排列和构造简直是太完美了, 没有一处的细节不完美,没有一处的空间被浪费掉,且容我慢慢欣赏20s.断开内存条右边的电池电源线,撬开光驱右边最下面的硬盘数据线. 拆下硬盘上方的小的固定条,一共两个螺丝.利用翘起的塑料小片, 轻轻拉出硬盘(注意藏在硬盘下面的排线,不要扯断了).轻轻拔出左侧的SATA3接口,整个机械硬盘就完全拆下来了.按照上图的1,2,3,4的位置,把这四个螺丝拆下来,同样的位置安装到SSD上.将SSD轻轻的装回原硬盘的位置,如下图所示,安装好以后,SSD会比原有的机械硬盘略薄一些,不过有螺丝的固定,没有影响. ##替换内存内存条的替换没有什么可说的,具体的可以参加Apple的指南.Apple MBP 安装和拆卸内存指南这里放一张基本流程的图:需要注意的一点是,一共上下两根条子,由于这两根条子挨得过于靠近,安装下面的条子的时候,不要把上面的条子的两边的压脚给弄坏了,金手指对齐插好以后,两边轻轻一按就能就位,要用巧劲,不要用蛮力.##数据恢复插入启动U盘,开机启动,先利用磁盘工具将SSD抹掉格式化为:OS X 扩展 (日志式),GUID 分区图.然后插入Time Machine的外置硬盘,选择将Time Machine备份的最新内容恢复到刚刚格式化的SSD分区中.小技巧:合上后盖后,先不要着急上螺丝,先插U盘,点亮机器,识别出来SSD,确认机器不报警以后,再断电上螺丝.制作启动U盘,参见另一篇blog 传送门U盘安装macOS系统##后续配置###开启TrimTRIM 是系统级的命令，可以允许操作系统与固态硬盘通信，判断 SSD 上哪些区域没有使用，并准备好擦除和复写。如果缺少 TRIM 支持，系统会在 SSD 可用容量减少时遇到写入速度变慢的现象.可以在「关于本机」里查看系统有没有开启 TRIM 支持：sudo trimforce enable命令执行后会出现警告语，根据提示输入两次「Y」以后，如图显示，就说明 TRIM 支持开启成功了（命令执行完成后会自动重启) :注意,旧版本的OS X系统可能需要先禁用rootlesssudo nvram boot-args=rootless=0据说 OS X El Capitan以后不需要,我当前用的Sierra不需要这个.###关闭突发移动感应器(Sudden Motion Sensor, SMS)突发移动感应器 (SMS) 技术是针对硬盘设计的内建保护功能，有助于防止电脑在掉落或遭遇异常强烈的振动时出现磁盘问题。目前普遍的观点是MBP的SMS功能在主硬盘位上有,光驱位上没有,由于SMS对SSD没有任何的保护作用,为了防止SMS对主硬盘位上SSD造成数据损坏,建议关闭.SMS的详细介绍可以在Apple的官方文档上查看 Mac 笔记本电脑：关于突发移动感应器sudo pmset -g  //查看看sms的状态,1为开启,0位关闭  sudo pmset sms -a 0 //关闭sms  sudo pmset -g  //重新查看sms的状态是否为0.  关于是否需要关闭SMS的讨论,可以参见这里,http://bbs.feng.com/read-htm-tid-4285975.html###关闭Time Machine的本地快照本地快照的详情,同样参见Apple Time Machine 官方介绍这个功能会增加SSD的写入量,降低SSD的寿命.sudo tmutil disablelocal //禁用本地快照sudo tmutil enablelocal  //启用本地快照在Time Machine的偏好设置中可以查看,本地快照的状态,出现了红色的部分即为启用,不出现即为禁用.##最终成果开机10s以内,Xcode工程秒开,硬盘读写速度爽的飞起.##参考链接http://www.superqq.com/blog/2015/08/27/macbook-replace-ssd-solid-state/http://chaishiwei.com/blog/972.htmlhttps://www.zhihu.com/question/21100176"
  },
  
  {
    "title": "iOS 操作系统目录说明",
    "url": "/posts/ios-cao-zuo-xi-tong-mu-lu-shuo-ming/",
    "categories": "iOS",
    "tags": "",
    "date": "2017-01-03 11:28:24 +0800",
    





    
    "snippet": "iOS的设备越狱后,安装openssh,可以通过ssh连接工具(Mac OS 下直接使用Terminal)连接到手机上查看相关的系统目录:ssh 连接命令常用格式:`ssh [-l login_name] [-p port] [user@]hostname示例:$ ssh root@10.2.98.87默认的openssh连接密码为:alpine一、iPhone的图片是放在：/private...",
    "content": "iOS的设备越狱后,安装openssh,可以通过ssh连接工具(Mac OS 下直接使用Terminal)连接到手机上查看相关的系统目录:ssh 连接命令常用格式:`ssh [-l login_name] [-p port] [user@]hostname示例:$ ssh root@10.2.98.87默认的openssh连接密码为:alpine一、iPhone的图片是放在：/private /var/ mobile/Media /DCIM当中的。二、iPhone中其他基本文件的存放文件目录如下：1、/Applications常用软件的安装目录  /private/var/mobile/Media/iphone video Recorderiphone video Recorder录像文件存放目录            path      description                  iphone video Recorderdfsajdfks      的飞机考六级来看看带分了                  First Header      Second Header      Third Header                  Content Cell      Content Cell      Content Cell              Content Cell      Content Cell      Content Cell      录像文件存放目录 | /private /var/ mobile/Media /iphone video Recorder3、/private /var/ mobile/Media /DCIM 相机拍摄的照片文件存放目录4、/private/var/ mobile /Media/iTunes_Control/Music iTunes上传的多媒体文件（例如MP3、MP4等）存放目录，文件没有被修改，但是文件名字被修改了，直接下载到电脑即可读取。5、/private /var/root/Media/EBooks熊猫看书存放目录 6、/Library/Ringtones系统自带的来电铃声存放目录（用iTunes将文件转换为ACC文件，把后缀名改成.m4r,用iPhone_PC_Suite传到/Library/Ringtones即可） 7、/System/Library/Audio/UISounds短信记其它系统默认效果铃声（m4r铃声文件改扩展名为.caf）短信铃声文件名为sms-received开头的caf文件8、/private/var/ mobile /Library/AddressBook系统电话本的存放目录。9、/private /var/ mobile/Media /iphone Recorderiphone Recorder录音软件文件存放目录10、/Applications/Preferences.app/zh_CN.lproj软件Preferences.app的中文汉化文件存放目录11、/Library/Wallpaper 系统q1ang纸的存放目录12、/System/Library/Audio/UISounds 系统声音文件的存放目录13、/private/var/root/Media/PXL ibrickr上传安装程序建立的一个数据库，估计和windows的uninstall记录差不多。14、/bin 和linux系统差不多，是系统执行指令的存放目录。 15、/private/var/ mobile /Library/SMS 系统短信的存放目录16、/private/var/run系统进程运行的临时目录？（查看这里可以看到系统启动的所有进程）17、/private/var/logs/CrashReporter系统错误记录报iPhone 特殊文件目录介绍  /private/var/mobile新刷完的机器，要在这个文件夹下建一个Documents的目录。  /private/var/mobile/Applications通过AppStore和iTunes安装的程序都在里面。  /private/var/stash这个文件夹下的Applications目录里面是所有通过Cydia和app安装的程序，Ringtones目录里是所有的手机铃音，自制铃音直接拷在里面即可，Themes目录里是所有Winterboard主题，可以手工修改。  /var/mobile/Media/ROMs/GBA　gpsPhone模拟器存放rom的目录。  /var/mobile/Media/textReadertextReader看书软件读取的电子书的存放路径。  /System/Library/Fonts/Cache系统字体目录，要替换的字体放在该目录下，权限644不变  /private/var/mobile/Media/Maps离线地图目录，把地图文件夹放到该目录下，文件夹赋予777权限  /private/var/mobile/Library/Downloadsipa文件存放目录，用Installous安装  /private/var/mobile/Library/Keyboard系统拼音字库文件位置  /var/stash/Themes.XXXXXXwinterboard主题文件存放路径  /private/var/mobile/Media/DCIM/999APPLE系统自带截屏文件存放路径"
  },
  
  {
    "title": "Block 声明语法 简记",
    "url": "/posts/block-sheng-ming-yu-fa-jian-ji/",
    "categories": "objective_C",
    "tags": "",
    "date": "2016-11-10 10:55:09 +0800",
    





    
    "snippet": "本地变量(Local Variable)  returnType (^blockName)(parameterTypes) = ^returnType(parameters) {…};属性(Property)  @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);方法参数(metho...",
    "content": "本地变量(Local Variable)  returnType (^blockName)(parameterTypes) = ^returnType(parameters) {…};属性(Property)  @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);方法参数(method parameter)      (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;  方法调用的时候的参数  [someObject someMethodThatTakesABlock:^returnType (parameters) {…}];重定义(typedef)  typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) {…};##参考资料http://fuckingblocksyntax.com/"
  },
  
  {
    "title": "Apple远程推送Pem证书生成-命令备忘",
    "url": "/posts/apple-remote-notificatoin-push-pem-file-generate/",
    "categories": "iOS",
    "tags": "",
    "date": "2016-08-26 11:12:01 +0800",
    





    
    "snippet": "###Develoepr Environment  去Apple Develop 网站申请Push证书并下载导入到Keychain中.  从Keychain中分别导出证书和密钥的.p12文件:cer.p12 key.p12  交换密码为:123456      使用openssl 将cer.p12及key.p12转成cer.pem和key.pem命令如下:    $ openssl pkcs...",
    "content": "###Develoepr Environment  去Apple Develop 网站申请Push证书并下载导入到Keychain中.  从Keychain中分别导出证书和密钥的.p12文件:cer.p12 key.p12  交换密码为:123456      使用openssl 将cer.p12及key.p12转成cer.pem和key.pem命令如下:    $ openssl pkcs12 -clcerts -nokeys -out cer.pem -in cer.p12$ openssl pkcs12 -nocerts -out key.pem -in key.p12        转换密钥文件时候,提示输一个pem的密码,转换完成后清除pem密码的命令:    $ openssl rsa -in key.pem -out key.pem              合并cer.pem及key.pem    $ cat cer.pem key.pem &gt; cer_key.pem      ###Release Environment 过程同上PS.测试生成的cer.pem及key.pem是否可用$ openssl s_client -connect gateway.push.apple.com:2195  -cert cer.pem -key key.pem 注：gateway.push.apple.com:2195用于appStore app;   gateway.sandbox.push.apple.com:2195用于沙盒app;   以上命令执行后会打印一大罗信息，最后处于可输入状态，打几个字符回车后自动断开连接即为正常。"
  },
  
  {
    "title": "使用CocoaLumberjack和XcodeColors实现分级Log和控制台打印彩色日志",
    "url": "/posts/shi-yong-cocoalumberjackhe-xcodecolorsshi-xian-fen-ji-loghe-kong-zhi-tai-da-yin-cai-se-ri-zhi/",
    "categories": "Xcode, iOS",
    "tags": "",
    "date": "2016-07-28 14:42:39 +0800",
    





    
    "snippet": "本文是基于:https://blog.cnbluebox.com/blog/2014/06/06/shi-yong-cocoalumberjackhe-xcodecolorsshi-xian-fen-ji-loghe-kong-zhi-tai-yan-se/ 的改动.Xcode是一款非常优秀的IDE,但是在日志打印上貌似没有那么多高级的特性，比如分级打印，显示颜色。本博客就介绍下两个开源组件...",
    "content": "本文是基于:https://blog.cnbluebox.com/blog/2014/06/06/shi-yong-cocoalumberjackhe-xcodecolorsshi-xian-fen-ji-loghe-kong-zhi-tai-yan-se/ 的改动.Xcode是一款非常优秀的IDE,但是在日志打印上貌似没有那么多高级的特性，比如分级打印，显示颜色。本博客就介绍下两个开源组件结合使用达到如下效果：##1.CocoaLumberjack###1.1基本介绍CocoaLumberjack是一个开源工程，为Xcode提供分级打印的策略，源码地址:CocoaLumberjackCocoaLumberjack包含几个对象分别可以把Log输出到不同的地方:  DDASLLogger 输出到Console.app  DDTTYLogger 输出到Xcode控制台  DDLogFileManager 输出到文件  DDAbstractDatabaseLogger 输出到DB通过ddLogLevel的int型变量或常量来定义打印等级  LOG_LEVEL_OFF 关闭Log  LOG_LEVEL_ERROR 只打印Error级别的Log  LOG_LEVEL_WARN 打印Error和Warning级别的Log  LOG_LEVEL_INFO 打印Error、Warn、Info级别的Log  LOG_LEVEL_DEBUG 打印Error、Warn、Info、Debug级别的Log  LOG_LEVEL_VERBOSE 打印Error、Warn、Info、Debug、Verbose级别的Log使用不同的宏打印不同级别的Log  DDLogError(frmt, …) 打印Error级别的Log  DDLogWarn(frmt, …) 打印Warn级别的Log  DDLogInfo(frmt, …) 打印Info级别的Log  DDLogDebug(frmt, …) 打印Debug级别的Log  DDLogVerbose(frmt, …) 打印Verbose级别的Log如果,现在想往已有的工程中引入CocoaLumberjack,可以使用下面的宏定义,#define NSLog(...) DDLogInfo(__VA_ARGS__)###1.2设置LogFormatter我们可以定制自己的Log的方式。通过创建一个类实现DDLogFormatter协议的方法- (NSString *)formatLogMessage:(DDLogMessage *)logMessage;,如下创建一个LogFormatter类，并实现如下方法：...NSDateFormatter *threadUnsafeDateFormatter;threadUnsafeDateFormatter = [[NSDateFormatter alloc] init];        [threadUnsafeDateFormatter setDateFormat:@\"yyyy/MM/dd HH:mm:ss:SSS\"];...      -(NSString *)formatLogMessage:(DDLogMessage *)logMessage{        NSString *levelStr = nil;    NSString *dateAndTime = [threadUnsafeDateFormatter stringFromDate:(logMessage-&gt;_timestamp)];        switch (logMessage.flag) {        case DDLogFlagError:        {            levelStr=@\"[ERROR]\";            break;        }        case DDLogFlagWarning:{            levelStr=@\"[WARN ]\";            break;        }        case DDLogFlagDebug:{            levelStr=@\"[DEBUG]\";            break;        }        case DDLogFlagInfo:        {            levelStr=@\"[INFO ]\";            break;        }        default:            levelStr=@\"[VBOSE]\";            break;    }        return [NSString stringWithFormat:@\"%@ %@ &gt; %@ [line %d] %@\",levelStr,dateAndTime,logMessage.function,logMessage.line,logMessage.message];}上面的例子中我们定制了Log能打印自己的等级、类和方法、代码行数。###1.3初始化CocoaLumberjack的引擎需要我们自己来启动。下面的示例代码 DDFileLogger *filelogger = [[DDFileLogger alloc] init];    filelogger.rollingFrequency = 60*60*24;//1h滚动一次    filelogger.logFileManager.maximumNumberOfLogFiles = 24;//最大文件数量24个        [[DDTTYLogger sharedInstance] setColorsEnabled:YES];    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor blackColor] backgroundColor:nil forFlag:DDLogFlagVerbose];    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor blueColor] backgroundColor:nil forFlag:DDLogFlagDebug];    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor purpleColor] backgroundColor:nil forFlag:DDLogFlagInfo];    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor orangeColor] backgroundColor:nil forFlag:DDLogFlagWarning];    [DDLog addLogger:[DDTTYLogger sharedInstance]];//写入xCode控制台    [DDLog addLogger:[DDASLLogger sharedInstance]];//写入到苹果的日志    [DDLog addLogger:filelogger];//写入到文件系统 Cache/Library/Log    filelogger.logFormatter = [[SHDDLogFormatter alloc] init];    [DDTTYLogger sharedInstance].logFormatter = [[SHDDLogFormatter alloc] init];        DDLogError(@\"DDLogError 中文错误\");      // red    DDLogWarn(@\"DDLogWarn 中文警告\");        // orange    DDLogDebug(@\"DDLogDebug 中文调试\");      // blue    DDLogInfo(@\"DDLogInfo 中文信息\");        // purple    DDLogVerbose(@\"DDLogVerbose 中文详细\");  // black    ##2.XcodeColors###2.1安装XcodeColors是一个Xcode插件，源码地址：XcodeColors; 代码下下来后打开工程run一次，插件就自动安装到了~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin路径下.安装完成重启Xcode也可以通过Alcatraz来安装,具体的参见Xcode常用插件集合###2.2配置scheme在Scheme中配置Environment Variables, 添加参数XcodeColors为YES.如下图###2.3为DDLog打开颜色[[DDTTYLogger sharedInstance] setColorsEnabled:YES];###2.4为特定的Log级别设定颜色    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor orangeColor] backgroundColor:nil forFlag:DDLogFlagWarning];完成以上步骤就可以看到控制台的不同颜色的打印了。。##参考文章https://blog.cnbluebox.com/blog/2014/06/06/shi-yong-cocoalumberjackhe-xcodecolorsshi-xian-fen-ji-loghe-kong-zhi-tai-yan-se/"
  },
  
  {
    "title": "为Octopress侧边栏增加访客地图",
    "url": "/posts/vistormap/",
    "categories": "octopress",
    "tags": "",
    "date": "2015-10-13 13:33:13 +0800",
    





    
    "snippet": "效果图我的Blog右下角那个旋转的3D地图,可以显示地域和访客的数量.Widget获取地址在这里:https://www.revolvermaps.com/?target=setupgl可以根据自己的喜好设定.分两步添加到Octopress的侧边栏中:1,获取code,并创建文件source/_includes/custom/asides/earth.html&lt;section&gt;&...",
    "content": "效果图我的Blog右下角那个旋转的3D地图,可以显示地域和访客的数量.Widget获取地址在这里:https://www.revolvermaps.com/?target=setupgl可以根据自己的喜好设定.分两步添加到Octopress的侧边栏中:1,获取code,并创建文件source/_includes/custom/asides/earth.html&lt;section&gt;&lt;h1&gt;访客地图&lt;/h1&gt;&lt;script type=\"text/javascript\" src=\"//ra.revolvermaps.com/0/0/6.js?i=0qld21p02br&amp;amp;m=0&amp;amp;s=220&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0\" async=\"async\"&gt;&lt;/script&gt;&lt;/section&gt;2,修改配置文件_config.ymldefault_asides: [custom/asides/about.html,asides/recent_posts.html, asides/github.html, asides/delicious.html, asides/pinboard.html, asides/googleplus.html,asides/category_list.html,custom/asides/recent_comments.html,custom/asides/earth.html]"
  },
  
  {
    "title": "iOS SDK中的私有API",
    "url": "/posts/private-api-in-ios/",
    "categories": "ios",
    "tags": "",
    "date": "2015-10-09 14:37:39 +0800",
    





    
    "snippet": "由于是私有API,再键入的时候不会有提示,注意在提交AppStore之前需要全部删除.1.查看View的层次结构  recursiveDescriptioneg:查看UISearchBar的View层级,找到Cancel-Button的位置并修改该按钮的样式    UISearchBar *searchBarView  = [[UISearchBar alloc] initWithFrame...",
    "content": "由于是私有API,再键入的时候不会有提示,注意在提交AppStore之前需要全部删除.1.查看View的层次结构  recursiveDescriptioneg:查看UISearchBar的View层级,找到Cancel-Button的位置并修改该按钮的样式    UISearchBar *searchBarView  = [[UISearchBar alloc] initWithFrame:CGRectMake(0, 0, 375, 44)];    searchBarView.showsCancelButton = YES;    //私有API,直接发消息给searchBarView的吧,编译器是不会过的,不信你试试看~~    NSLog(@\"%@\",[searchBarView performSelector:@selector(recursiveDescription)]);    打印结果如下:2015-10-09 15:12:20.568 findAward[5625:756750] &lt;UISearchBar: 0x144574710; frame = (0 0; 375 44); text = ''; gestureRecognizers = &lt;NSArray: 0x174247b90&gt;; layer = &lt;CALayer: 0x174430040&gt;&gt;   | &lt;UIView: 0x17418d750; frame = (0 0; 375 44); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x17442ff80&gt;&gt;   |    | &lt;UISearchBarBackground: 0x1445a4240; frame = (0 0; 375 44); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x174431200&gt;&gt;   |    | &lt;UINavigationButton: 0x14452b250; frame = (0 0; 34 30); opaque = NO; layer = &lt;CALayer: 0x17442e4c0&gt;&gt;   |    | &lt;UISearchBarTextField: 0x144645db0; frame = (0 0; 0 0); text = ''; clipsToBounds = YES; opaque = NO; layer = &lt;CALayer: 0x1702213a0&gt;&gt;   |    |    | &lt;_UISearchBarSearchFieldBackgroundView: 0x1445732c0; frame = (0 0; 0 0); opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17442fac0&gt;&gt;  根据打印的结果,我们可以看出,UISearchBar的二级subview里有一个,UINavigationButton随便猜猜,这个也是UIButton的子类了.故要获得它并修改他的样式的code如下: for (UIView *view in [[searchBarView.subviews lastObject] subviews]) {                if ([view isKindOfClass:[UIButton class]]) {                    UIButton *cancelBtn = (UIButton *)view;                    [cancelBtn setTitle:@\"取消\" forState:UIControlStateNormal];                    [cancelBtn setTitleColor:COLOR_EA4426 forState:UIControlStateNormal];                    [cancelBtn setTitleColor:COLOR_EA4426 forState:UIControlStateHighlighted];                }            }"
  },
  
  {
    "title": "xcode 统计项目中代码的行数",
    "url": "/posts/cloc/",
    "categories": "ios",
    "tags": "",
    "date": "2015-09-01 10:09:12 +0800",
    





    
    "snippet": "###方法一:终端命令进入项目目录下，命令如下find . -name \"*.m\" -or -name \"*.h\" -or -name \"*.xib\" -or -name \"*.c\" |xargs wc -l  列出每个文件的行数find . -name \"*.m\" -or -name \"*.h\" -or -name \"*.xib\" -or -name \"*.c\" |xargs grep -...",
    "content": "###方法一:终端命令进入项目目录下，命令如下find . -name \"*.m\" -or -name \"*.h\" -or -name \"*.xib\" -or -name \"*.c\" |xargs wc -l  列出每个文件的行数find . -name \"*.m\" -or -name \"*.h\" -or -name \"*.xib\" -or -name \"*.c\" |xargs grep -v \"^$\"|wc -l  列出代码行数总和grep -v \"^$\"是去掉空行注释也统计在代码量之内###方法二:使用CLOC,项目说明地址:http://cloc.sourceforge.net/  1.64 Perl脚本下载地址,https://github.com/douxinchun/CLOC使用方法:perl cloc-1.64.pl ./YourProjectNameresult:     200 files     744 text files.     630 unique files.                                               315 files ignored.http://cloc.sourceforge.net v 1.64  T=2.56 s (199.8 files/s, 22014.2 lines/s)-------------------------------------------------------------------------------Language                     files          blank        comment           code-------------------------------------------------------------------------------Objective C                    242           6916           4208          28460C/C++ Header                   265           3605           8066           4870JSON                             3              0              0            107Bourne Shell                     1              5              0             65-------------------------------------------------------------------------------SUM:                           511          10526          12274          33502-------------------------------------------------------------------------------"
  },
  
  {
    "title": "在网页中嵌入css的三种方法",
    "url": "/posts/zai-wang-ye-zhong-qian-ru-cssde-san-chong-fang-fa/",
    "categories": "css",
    "tags": "",
    "date": "2015-07-22 18:42:32 +0800",
    





    
    "snippet": "留存备忘假如有一段HTML代码如下：&lt;html&gt;&lt;head&gt;&lt;title&gt;Hi&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"myid\" class=\"myclass\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;在HTML代码中嵌入CSS有一下三种方法：1.外...",
    "content": "留存备忘假如有一段HTML代码如下：&lt;html&gt;&lt;head&gt;&lt;title&gt;Hi&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"myid\" class=\"myclass\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;在HTML代码中嵌入CSS有一下三种方法：1.外链式CSS。编写一个.css文件并且命名为style.css,内容如下：    #myid{     padding:5px;    }然后在HTML代码的&lt;head&gt;标签对,&lt;title&gt;下面改成这样:   &lt;head&gt;   &lt;title&gt;HI&lt;/title&gt;   &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt;   &lt;/head&gt;这样就OK了2.内嵌式CSS。直接在&lt;title&gt;标签加成这样：   &lt;head&gt;   &lt;title&gt;HI&lt;/title&gt;   &lt;style type=\"text/css\"&gt;   &lt;!--    #myid{     padding:5px;     }    --&gt;   &lt;/style&gt;   &lt;/head&gt;3.直接式CSS。直接为DIV添加style属性如下：&lt;div id=\"myid\" class=\"myclass\" style=\"padding:5px;\"&gt;&lt;/div&gt;"
  },
  
  {
    "title": "使用itms-services 协议来发布ipa文件",
    "url": "/posts/distribute-ipa-by-itms-services/",
    "categories": "iOS",
    "tags": "",
    "date": "2015-07-22 16:45:35 +0800",
    





    
    "snippet": "苹果允许用itms-services协议来直接在iphone/ipad上安装应用程序，我们可以直接生成该协议需要的相关文件，这样产品经理和测试都可以直接在设备上安装新版的应用:需要两个文件，一个是html，另一个是plist。文件index.html(请自动忽略css部分,我实在不会写前端):&lt;html&gt;&lt;head&gt;    &lt;style&gt;        b...",
    "content": "苹果允许用itms-services协议来直接在iphone/ipad上安装应用程序，我们可以直接生成该协议需要的相关文件，这样产品经理和测试都可以直接在设备上安装新版的应用:需要两个文件，一个是html，另一个是plist。文件index.html(请自动忽略css部分,我实在不会写前端):&lt;html&gt;&lt;head&gt;    &lt;style&gt;        body {            font-size: 50px;            margin-top:100px;            margin-left:auto;            margin-right:auto;            text-align:center;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;iOS 7.1 and above systems use the following link to install&lt;/p&gt;&lt;p&gt;&lt;a href=\"itms-services://?action=download-manifest&amp;amp;url=https://********/**/tue_test.plist\"&gt;Install TU/e App For Test&lt;/a&gt;&lt;/p&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;文件plist:&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt;   &lt;key&gt;items&lt;/key&gt;   &lt;array&gt;       &lt;dict&gt;           &lt;key&gt;assets&lt;/key&gt;           &lt;array&gt;               &lt;dict&gt;                   &lt;key&gt;kind&lt;/key&gt;                   &lt;string&gt;software-package&lt;/string&gt;                   &lt;key&gt;url&lt;/key&gt;                   &lt;string&gt;http://****/**/tue_test.ipa(ipa文件的访问地址)&lt;/string&gt;               &lt;/dict&gt;               &lt;dict&gt;                   &lt;key&gt;kind&lt;/key&gt;                   &lt;string&gt;display-image&lt;/string&gt;                   &lt;key&gt;needs-shine&lt;/key&gt;                   &lt;true/&gt;                   &lt;key&gt;url&lt;/key&gt;                   &lt;string&gt;图片的地址&lt;/string&gt;               &lt;/dict&gt;      &lt;dict&gt;                   &lt;key&gt;kind&lt;/key&gt;                   &lt;string&gt;full-size-image&lt;/string&gt;                   &lt;key&gt;needs-shine&lt;/key&gt;                   &lt;true/&gt;                   &lt;key&gt;url&lt;/key&gt;                   &lt;string&gt;图片的地址&lt;/string&gt;              &lt;/dict&gt;           &lt;/array&gt;           &lt;key&gt;metadata&lt;/key&gt;           &lt;dict&gt;               &lt;key&gt;bundle-identifier&lt;/key&gt;               &lt;string&gt;com.xx.xx(bundleID需要ipa中需要保持一致)&lt;/string&gt;               &lt;key&gt;bundle-version&lt;/key&gt;               &lt;string&gt;1.0(CFBundleVersion需要和ipa中的保持一致)&lt;/string&gt;               &lt;key&gt;kind&lt;/key&gt;               &lt;string&gt;software&lt;/string&gt;               &lt;key&gt;subtitle&lt;/key&gt;               &lt;string&gt;&lt;/string&gt;               &lt;key&gt;title&lt;/key&gt;               &lt;string&gt;TU/e测试版(随便起,用于踊跃alert确认时的提示)&lt;/string&gt;           &lt;/dict&gt;       &lt;/dict&gt;   &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt;###注意在iOS7.1之前,协议地址后的url需要使用http协议,  itms-services://?action=download-manifest&amp;url=http://**//tue_test.plist在iOS7.1以及以后,这里需要换成https协议,  itms-services://?action=download-manifest&amp;url=https://**//tue_test.plist否则使用Safari安装的时候,会提示”无法安装应用程序，因为“xx.xx.xx” 的证书无效;无法找到主机”1.2.3.4”“之类的错误.也就是说,原先存放plist的web服务器需要支持https协议.自己动手搭建一个https的web服务的话,其中证书的部分很令人头痛的.我在IIS上整了一个上午,最后的结果上自己生成的证书Safari不认.我去,果断放弃这条路,google了一个简便的方法.利用开源中国(http://git.oschina.net/)提供的代码托管服务,托管一下plist文件,然后ipa的安装包和index.html依旧放在自己的服务器上.itms-services协议后面的url地址,改成在plist文件在开源中国上的url(注意url结束到.plist为止,后面的那一串参数不要带,直接手动把http改为https).具体的流程参见这里,http://blog.csdn.net/sy_bz/article/details/33739779同理,我觉得github也应该可以代替开源中国.###附plist中的字段说明:            key值      说明                  assets                     software-package url      要安装的 ipa 地址              display-image url      安装ipa的时候,桌面显示呃图标              metadata                     bundle-identifier      bundle ID (和ipa保持一致)              bundle-version      CFBundleVersion(和ipa保持一致)              title      用户点击时弹框中的AppTitle提示              subtitle      不明,应该 也跟弹框的内容相关      以备后用自搭https服务器,可以查看的参照:http://zengrong.net/post/2108.html"
  },
  
  {
    "title": "Xcode中的调试器LLDB",
    "url": "/posts/xcodezhong-de-diao-shi-qi-lldb/",
    "categories": "XCode",
    "tags": "",
    "date": "2015-07-20 17:40:46 +0800",
    





    
    "snippet": "原文地址:http://objccn.io/issue-19-2/里面内容很多,本着实用主义,这里只记录我自己常用的命令:###1.查看某个变量的值 print  LLDB会做前缀匹配,一把简写为p, 使用po可以查看NSObject的description###2.改变某个变量的值expression简写为expr或者是e(还能再懒一点吗~~)",
    "content": "原文地址:http://objccn.io/issue-19-2/里面内容很多,本着实用主义,这里只记录我自己常用的命令:###1.查看某个变量的值 print  LLDB会做前缀匹配,一把简写为p, 使用po可以查看NSObject的description###2.改变某个变量的值expression简写为expr或者是e(还能再懒一点吗~~)"
  },
  
  {
    "title": "AutoLayout 使用总结",
    "url": "/posts/autolayout-summary/",
    "categories": "iOS",
    "tags": "",
    "date": "2015-07-20 16:55:20 +0800",
    





    
    "snippet": "###1.如何计算UITableViewCell的高度在IOS的布局中，计算和适应cell的高度是个经典的问题, 在frame时代(springs和struts方式布局时代)，我们都知道用sizeWithFont: 先计算出文字的高度，然后通过计算得出cell的高度，然后赋予heightForRow:。那在Autolayout时代如何计算cell的高度呢？因为sizeWithFont:方法已...",
    "content": "###1.如何计算UITableViewCell的高度在IOS的布局中，计算和适应cell的高度是个经典的问题, 在frame时代(springs和struts方式布局时代)，我们都知道用sizeWithFont: 先计算出文字的高度，然后通过计算得出cell的高度，然后赋予heightForRow:。那在Autolayout时代如何计算cell的高度呢？因为sizeWithFont:方法已经不太实用了。其实Autolayout不但更简单，还可以不用写过多的计算代码达到自适应高度。理论上是可以通过已知的完整的Constraints和view的属性来计算高度的，我们可以通过systemLayoutSizeFittingSize:方法来获取计算出来cell的size，我们知道cell的高度需要在tableView的代理方法tableView:heightForRowAtIndexPath:中实现的.可以参照:http://blog.cnbluebox.com/blog/2015/02/02/autolayout2/和http://www.ifun.cc/blog/2014/02/21/dong-tai-ji-suan-uitableviewcellgao-du-xiang-jie/  这两篇文章基本讲的比较全面了.此处不重复.核心的API是systemLayoutSizeFittingSize:,这个方法可以计算出cell在完整约束下的高度,其中使用这种方式需要注意的是:  UILabel以及UITextField等有preferredMaxLayoutWidth属性的VIew需要设置一下,不然计算出来的高度UILable的部分只有一行文字的高度  对于具有intrinsicContentSize的View需要在垂直方向上,将压缩阻力 (Compression Resistance) 和 内容吸附 (Content Hugging)设置为1000,最高级  要保证Cell在垂直方向上设置的Constraints,理论上可以计算出整个Cell的高度,可以降低某个垂直方向约束的优先级,来消除xib中的约束错误提示###2.AutoLayout下的动画在使用Autolayout时，动画的使用和以前也不同了，以前我们是修改frame，现在我们可以通过修改Constraints, 然后在动画时layoutIfNeeded就行了。//修改约束...[UIView animateWithDuration:0.2 animations:^{    [view layoutIfNeeded];}];Autolayout有时在动画时候会很方便，因为View之间的坐标是相互影响的，在传统frame中，如果改变一个view的frame,那么可能你要更改很多view的frame，才能让页面显得和谐。在Autolayout中可能只需要修改一个Constraint就可以了，在做动画时会很方便。###3.压缩阻力 (Compression Resistance) 和 内容吸附 (Content Hugging)对于压缩阻力 (Compression Resistance) 和 内容吸附 (Content Hugging)的介绍,可以参照这里:http://objccn.io/issue-3-5/API中对应的是:- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayout- "
  },
  
  {
    "title": "GoAgent+PHP 访问Google",
    "url": "/posts/acccess-the-real-world-through-the-gfw/",
    "categories": "goagent",
    "tags": "",
    "date": "2015-07-01 10:53:00 +0800",
    





    
    "snippet": "##前言GoAgent可以使用两种方式来翻墙上网:一种是官方推荐的,申请一个Google的Email账号,然后上传服务端需要的文件到Google App Engine;另外一种就就是通过国外的没有被屏蔽的PHP的空间来代替GAE作为服务端.本人以前(2015年以前)一直是使用第一种方式,但后来由于国内对于GAE一直是重点的屏蔽对象,导致许多的公布的ip地址不可用,火狐范上公布的ip也是只能用...",
    "content": "##前言GoAgent可以使用两种方式来翻墙上网:一种是官方推荐的,申请一个Google的Email账号,然后上传服务端需要的文件到Google App Engine;另外一种就就是通过国外的没有被屏蔽的PHP的空间来代替GAE作为服务端.本人以前(2015年以前)一直是使用第一种方式,但后来由于国内对于GAE一直是重点的屏蔽对象,导致许多的公布的ip地址不可用,火狐范上公布的ip也是只能用一两天,checkgoogleip上扫出来的ip,十个里面有9个都不靠谱,剩下的一个,没撑过2天也挂了.实在不再愿意每天折腾iplist,所以决定Google一下,在PHP空间上部署goagent服务.注意! 本文goagent为3.2.3版本(具体而言是3.2.3版本) 运行于Linux  内核版本：2.6.32-531.29.2.lve1.3.11.1.el6.x86_64客户端的系统是Mac OS X如果你用的是Windows系统,推荐使用Easy GoAgent,开箱即用.##在PHP空间上部署goagent这个不难 相对于我这里gae需要每2天换一次ip PHP空间一般相对较少被屏蔽不过一旦PHP空间被屏蔽 那就要重新申请其他的了.国外的免费的PHP空间有很多,比如:VHost Full,EcVps这里以免费空间ecvps为例  进入ecvps 申请免费空间 可以切换为中文页面显示 订购免费版的地址  选择现在订购 填一些信息 注意注册信息不要写中文 最好写音译  关于信息 写的不要太离谱 比如地址要和邮编要对的上之类 防止审核为欺诈订单  一般申请成功 注册邮箱就会收到确认的email,如果出现提示了没有通过审核欺诈,记得回去充填一下资料,填的再靠谱一些.      在会员中心面板上 点击 我的信件 标签 然后打开New Account Information里面有系统生成的 Domain Username Password注意如果连续7天没有访问流量 则此空间会被删除    下载安装FileZilla 或者其他的FTP软件打开FileZilla 填写远程主机的一些信息 全部根据New Account Information来          主机(Domain)username.ecvps.net用户名(Username) 就是New Account Information中的Username 如username密码(Password) 这个也根据New Account Information中给出的 填写端口不用填 点快速连接在本地站点中 选中goagent/server/php路径下的所有文件上传到远程站点的 /domains/xinchun.ecvps.net/public_html目录下      如果FTP连接不上的,可以使用EcVps Control中自带的FileManager功能打开goagent/local/proxy.ini文件 对于其中的[php]部分改动两行就可以了 分别是[php]enable = 1fetchserver = http://username.ecvps.net/index.php密码用可以用默认的也可以不用 则要统一修改goagent/server/php路径下所有文件内设定的默认密码网上一些文章用的是fetch.php 但注意新版goagent 3.2.3用的是index.php这里有官方说明,参见第13条,不要试图在浏览器里打开这个链接:  http://username.ecvps.net/index.php最后修改Chrome中的SwitchyOmega的自动切换的情景模式为GoAgent PHP##启动用Terminal cd到goagent的local目录:$ python proxy.py 然后就没有然后,##开机启动安装一个GoagentMac(Mac),然后查看包的内容,找到Info.plist ,用文件编辑器编辑,修改一下key值 GoAgentPath的value为proxy.py的路径.##额外内容使用探针一般来说 到这里 启动goagent就可以上youtube也可以去下载视频了如果想详细了解该PHP服务器的一些信息 可以使用探针点击右上方的探针下载 会下载tz.zip文件 然后解压成tz.php再上传到/domains/saburika.ecvps.net/public_html目录下此时访问http://saburika.ecvps.net/tz.php 就会出现你的php空间的详细信息了第二种上传方式不使用ftp上传 直接使用网页上传也是可以的这个要阅读New Account Information中给出的相关信息把给定的网址和端口复制到浏览器地址栏用系统给自己生成的Username和Password登录就会出现php空间的网页版操作面板了##附件goagent官方主页SwitchyOmega在Goagent的安装包local目录下自带,并且带有备份文件"
  },
  
  {
    "title": "在多台机器上协作使用Octopress",
    "url": "/posts/use-octopress-in-different-machines/",
    "categories": "octopress",
    "tags": "",
    "date": "2015-06-30 13:49:49 +0800",
    





    
    "snippet": "按照之前文章 在GitHub上搭建Octopress 中的步骤,就可以成功的搭建自己的Octopress框架下的博客了,但是接下来的问题是,如果这个是在公司的机器上搭建了环境,那么下班回到家后想继续更新一下自己的Blog怎么办呢.其实,想想原理很简单,Git是一个版本管理系统(分布式的),如果我们在下班前把自己的文件提交到Git的远程库上,然后到家的时候,把家里的PC搭建一个Ruby的环境,...",
    "content": "按照之前文章 在GitHub上搭建Octopress 中的步骤,就可以成功的搭建自己的Octopress框架下的博客了,但是接下来的问题是,如果这个是在公司的机器上搭建了环境,那么下班回到家后想继续更新一下自己的Blog怎么办呢.其实,想想原理很简单,Git是一个版本管理系统(分布式的),如果我们在下班前把自己的文件提交到Git的远程库上,然后到家的时候,把家里的PC搭建一个Ruby的环境,再把有关的文件从远程库上pull下来,OK,万事大吉,又可以继续编写自己的Blog了.###准备工作:参照  在GitHub上搭建Octopress  首先要在新机器上搭建一个Ruby的环境,Simple Guide:*  安装Git  安装ruby,例如：Ruby 1.9.3-p125  克隆项目接下来我们需要把GitHub上已经建好的博客项目clone下来。克隆远程仓库到本地$ git clone git@github.com:username/username.github.com.git octopress ##octopress 为你的本地项目文件夹切换到source分支$ cd octopress ##进入项目$ git checkout source ##切换到本地的source分支创建_deploy目录(存在的话,直接同步),并和远程库的master分支同步$ mkdir _deploy$ cd ./_deploy$ git pull origin master ##同步本地的master branch配置环境,在octopress目录下进行,$ gem install bundler$ rbenv rehash    # If you use rbenv, rehash to be able to run the bundle command$ bundle install$ rake setup_github_pages然后它会询问你的项目仓库的URL:  Enter the read/write url for your repository (For example, ‘git@github.com:your_username/your_username.github.com)输入仓库的URL，这样你就完成了全新的一个本地博客副本。注意:以上操作只需要在完全没有环境的机器上执行一次,不需要每次都执行###更新变化（重要）每次使用前，先确保拿到最新的文件(先GitHub上的远程库同步)$ cd octopress  #进入项目目录$ git pull origin source  # 更新本地source branch$ cd ./_deploy  #进入_deploy目录$ git pull origin master  # 更新本地master branch提交提交的时候，由于需要多台机器协作，需要把source分支push到origin中，这样另外一台机器才能拿到最新的源文件。$ rake generate$ git add .$ git commit -am \"提交注释\" $ git push origin source  # 将本地当前分支的更新推送到远程 source branch $ rake deploy             # 更新远程 master branch，并部署博文另外的机器更新变化在另外的机器上，就可以获取到相应的变化。$ cd octopress  #进入项目目录$ git pull origin source  # 更新本地source branch$ cd ./_deploy  #进入_deploy目录$ git pull origin master  # 更新本地master branch和远程库的 master保持同步"
  },
  
  {
    "title": "冰与火之歌 守夜人誓言",
    "url": "/posts/night-watcher-swear/",
    "categories": "冰与火之歌",
    "tags": "",
    "date": "2015-06-12 15:10:52 +0800",
    





    
    "snippet": "最近重温了一遍Game of Throne , 感觉守夜人的誓词太霸气了。翻译的也是信达雅.Night watcher swear(“Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. ...",
    "content": "最近重温了一遍Game of Throne , 感觉守夜人的誓词太霸气了。翻译的也是信达雅.Night watcher swear(“Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. I shall wear no crowns and win no glory. I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the fire that burns against the cold, the light that brings the dawn, the horn that wakes the sleepers, the shield that guards the realms of men. I pledge my life and honor to the Night’s Watch, for this night and all the nights to come.”)　守夜人誓言：「长夜将至，我从今开始守望，至死方休。我将不娶妻、不封地、不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死於斯。我是黑暗中的利剑，长城上的守卫。我是抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。」　　　繁体版: 　　永夜终至，吾辈铭记，巍巍大任，死亦无终。 　　无享妻爱，不履寸土，决绝子嗣，身归兄弟。 　　何言无冕，兄弟所望，何争俗荣，袍泽同心，尽忠职守，生死于斯，心念所归，无惧无退.　　铸兵利剑，暗夜无当；凝聚础石，长城屹立；腾焰熊熊，炽烈华光；耀耀破晓，璨以晨光；鸣无尽之号角，警外患之袭扰；锻坚钢之神盾，固王国之永宁.　　于今挺身，奉以生命，以夜为始，死亦无终。"
  },
  
  {
    "title": "加快Octopress国内访问速度",
    "url": "/posts/accelerate-the-speed-of-access-octopress-in-china/",
    "categories": "octopress",
    "tags": "",
    "date": "2015-05-11 14:13:23 +0800",
    





    
    "snippet": "##Overview本文最主要引自加快octopress国内访问速度和Octopress加速Google字体渲染,以下内容是在这两篇博文的指导上结合自己实践经验的总结.在github中搭建好了Octopress后,访问速度非常的慢,这是引文Octopress使用了Google API的CDN服务和Google Fonts.Google的CDN访问速度在国外的网络环境下是非常快的,但是在天朝,...",
    "content": "##Overview本文最主要引自加快octopress国内访问速度和Octopress加速Google字体渲染,以下内容是在这两篇博文的指导上结合自己实践经验的总结.在github中搭建好了Octopress后,访问速度非常的慢,这是引文Octopress使用了Google API的CDN服务和Google Fonts.Google的CDN访问速度在国外的网络环境下是非常快的,但是在天朝,非常非常的慢,尤其是使用了https来访问.于是,为了加快访问速度,我们只好把Google的web fonts缓存到本地的服务器并更改jQuery的cdn服务.###1.把jquery的cdn服务改成microsoft的 编辑文件 source/_includes/head.html  找到下图注释掉的部分,替换成   &lt;!--&lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt;--&gt;  &lt;script src=\"//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;###2.缓存google fonts (将PT Serif和PT Sans缓存到本地) 打开 source/_includes/custom/head.html&lt;!--Fonts from Google\"s Web font directory at http://google.com/webfonts --&gt;&lt;link href=\"//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;link href=\"//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic\" rel=\"stylesheet\" type=\"text/css\"&gt;将 https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic 以及 https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic 中的内容复制到本地,并在 source/stylesheets 下新建pt_sans.css和pt_serif.css文件,文件部分内容如下:/* cyrillic-ext */@font-face {  font-family: 'PT Serif';  font-style: normal;  font-weight: 400;  src: local('PT Serif'), local('PTSerif-Regular'), url(https://fonts.gstatic.com/s/ptserif/v8/5hX15RUpPERmeybVlLQEWBkAz4rYn47Zy2rvigWQf6w.woff2) format('woff2');  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;}/* cyrillic */@font-face {  font-family: 'PT Serif';  font-style: normal;  font-weight: 400;  src: local('PT Serif'), local('PTSerif-Regular'), url(https://fonts.gstatic.com/s/ptserif/v8/fU0HAfLiPHGlZhZpY6M7dBkAz4rYn47Zy2rvigWQf6w.woff2) format('woff2');  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}/* latin-ext */@font-face {  font-family: 'PT Serif';  font-style: normal;  font-weight: 400;  src: local('PT Serif'), local('PTSerif-Regular'), url(https://fonts.gstatic.com/s/ptserif/v8/CPRt--GVMETgA6YEaoGitxkAz4rYn47Zy2rvigWQf6w.woff2) format('woff2');  unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;}...注意,此处访问这两个链接可能需要翻墙.新建一个目录 source/fonts 把字体解压缩到这个目录下.douxinchundeiMac:fonts douxinchun$ pwd/Users/douxinchun/octopress/source/fontsdouxinchundeiMac:fonts douxinchun$ tree.├── pt_sans│   ├── 0XxGQsSc1g4rdRdjJKZrNAzyDMXhdD8sAj6OAJTFsBI.woff2│   ├── 7dSh6BcuqDLzS2qAASIeuoX0hVgzZQUfRDuZrPvH3D8.woff2│   ├── BJVWev7_auVaQ__OU8Qih1KPGs1ZzpMvnHX-7fPOuAc.woff2│   ├── CWlc_g68BGYDSGdpJvpktgLUuEpTyoUstqEm5AMlJo4.woff2│   ├── DVKQJxMmC9WF_oplMzlQqYX0hVgzZQUfRDuZrPvH3D8.woff2│   ├── GpWpM_6S4VQLPNAQ3iWvVYX0hVgzZQUfRDuZrPvH3D8.woff2│   ├── PIPMHY90P7jtyjpXuZ2cLJBw1xU1rKptJj_0jans920.woff2│   ├── fhNmDCnjccoUYyU4ZASaLVKPGs1ZzpMvnHX-7fPOuAc.woff2│   ├── g46X4VH_KHOWAAa-HpnGPgsYbbCjybiHxArTLjt7FRU.woff2│   ├── hpORcvLZtemlH8gI-1S-7gsYbbCjybiHxArTLjt7FRU.woff2│   ├── kTYfCWJhlldPf5LnG4ZnHAsYbbCjybiHxArTLjt7FRU.woff2│   ├── lILlYDvubYemzYzN7GbLkA7aC6SjiAOpAWOKfJDfVRY.woff2│   ├── lILlYDvubYemzYzN7GbLkBampu5_7CjHW5spxoeN3Vs.woff2│   ├── lILlYDvubYemzYzN7GbLkBdwxCXfZpKo5kWAx_74bHs.woff2│   ├── lILlYDvubYemzYzN7GbLkIjoYw3YTyktCCer_ilOlhE.woff2│   └── oysROHFTu1eTZ74Hcf8V-VKPGs1ZzpMvnHX-7fPOuAc.woff2└── pt_serif    ├── 03aPdn7fFF3H6ngCgAlQzAzyDMXhdD8sAj6OAJTFsBI.woff2    ├── 3Nwg9VzlwLXPq3fNKwVRMAsYbbCjybiHxArTLjt7FRU.woff2    ├── 5hX15RUpPERmeybVlLQEWBkAz4rYn47Zy2rvigWQf6w (1).woff2    ├── CPRt--GVMETgA6YEaoGitxkAz4rYn47Zy2rvigWQf6w.woff2    ├── Foydq9xJp--nfYIx2TBz9TrEaqfC9P2pvLXik1Kbr9s.woff2    ├── Foydq9xJp--nfYIx2TBz9WaVI6zN22yiurzcBKxPjFE.woff2    ├── Foydq9xJp--nfYIx2TBz9ZsnFT_2ovhuEig4Dh-CBQw.woff2    ├── Foydq9xJp--nfYIx2TBz9bllaL-ufMOTUcv7jfgmuJg.woff2    ├── I-OtoJZa3TeyH6D9oli3iXYhjbSpvc47ee6xR_80Hnw.woff2    ├── O_WhD9hODL16N4KLHLX7xQsYbbCjybiHxArTLjt7FRU.woff2    ├── QABk9IxT-LFTJ_dQzv7xpF4sYYdJg5dU2qzJEVSuta0.woff2    ├── QABk9IxT-LFTJ_dQzv7xpIgp9Q8gbYrhqGlRav_IXfk.woff2    ├── QABk9IxT-LFTJ_dQzv7xpKE8kM4xWR1_1bYURRojRGc.woff2    ├── QABk9IxT-LFTJ_dQzv7xpPZraR2Tg8w2lzm7kLNL0-w.woff2    ├── b31S45a_TNgaBApZhTgE6AsYbbCjybiHxArTLjt7FRU.woff2    └── fU0HAfLiPHGlZhZpY6M7dBkAz4rYn47Zy2rvigWQf6w.woff22 directories, 32 filesdouxinchundeiMac:fonts douxinchun$将文件pt_sans.css和pt_serif.css的web引用修改为本地引用,文件部分内容如下:/* cyrillic-ext */@font-face {  font-family: 'PT Sans';  font-style: normal;  font-weight: 400;  src: local('PT Sans'), local('PTSans-Regular'), url(/fonts/pt_sans/fhNmDCnjccoUYyU4ZASaLVKPGs1ZzpMvnHX-7fPOuAc.woff2) format('woff2');  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;}/* cyrillic */@font-face {  font-family: 'PT Sans';  font-style: normal;  font-weight: 400;  src: local('PT Sans'), local('PTSans-Regular'), url(/fonts/pt_sans/BJVWev7_auVaQ__OU8Qih1KPGs1ZzpMvnHX-7fPOuAc.woff2) format('woff2');  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}编辑 source/_includes/custom/head.html 为&lt;!--Fonts from Google\"s Web font directory at http://google.com/webfonts --&gt;&lt;link href=\"/stylesheets/pt_serif.css\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;link href=\"/stylesheets/pt_sans.css\" rel=\"stylesheet\" type=\"text/css\"&gt;部署访问,速度果然快了很多."
  },
  
  {
    "title": "在CentOS下安装SVN Server",
    "url": "/posts/set-up-svnserver-under-centos/",
    "categories": "Linux",
    "tags": "",
    "date": "2015-05-05 14:12:48 +0800",
    





    
    "snippet": "##OverView之前搭建SVN Server都是在WindowsServer下直接安装一个Visual SVN,近期在一个项目中发现对方使用的是阿里云的云服务器,而且是CentOS的操作系统.特此记录一下自己的搭建过程,以备后用.整个过程分为5个部分.  连接云服务器  安装SVN Server  配置SVN Server  配置防火墙开通端口  启动SVN服务.最后,我会在文章的末尾总...",
    "content": "##OverView之前搭建SVN Server都是在WindowsServer下直接安装一个Visual SVN,近期在一个项目中发现对方使用的是阿里云的云服务器,而且是CentOS的操作系统.特此记录一下自己的搭建过程,以备后用.整个过程分为5个部分.  连接云服务器  安装SVN Server  配置SVN Server  配置防火墙开通端口  启动SVN服务.最后,我会在文章的末尾总结一下自己在搭建的过程中遇到的问题汇总.###1.连接云服务器由于需要连接的是centOS系统,所有先放弃Windows和Mac OS X上的远端桌面连接工具吧.Windows上应该是需要一个SSH的客户端工具.打开Terminal ,root 是username 后面跟的是ip地址localhost:~ douxinchun$ ssh -l root 182.92.178.156按照提示输入密码,登录成功后显示如下:Last login: Mon May  4 16:31:40 2015 from 111.203.240.200Welcome to aliyun Elastic Compute Service![root@iZ256vx3u5fZ ~]# ###2.安装SVN Server检查是否安装rpm -qa subversion[root@iZ256vx3u5fZ /]# rpm -qa subversionsubversion-1.6.11-12.el6_6.x86_64[root@iZ256vx3u5fZ /]# 卸载旧的版本yum remove subversion安装yum install -y subversion验证安装是否成功svnserve --version[root@iZ256vx3u5fZ /]# svnserve --versionsvnserve，版本 1.6.11 (r934486)   编译于 Feb 10 2015，22:08:22版权所有 (C) 2000-2009 CollabNet。Subversion 是开放源代码软件，请参阅 http://subversion.tigris.org/ 站点。此产品包含由 CollabNet(http://www.Collab.Net/) 开发的软件。下列版本库后端(FS) 模块可用: * fs_base : 模块只能操作BDB版本库。* fs_fs : 模块与文本文件(FSFS)版本库一起工作。Cyrus SASL 认证可用。[root@iZ256vx3u5fZ /]# ###3.配置SVN Server首先,创建一个SVN的版本库[root@iZ256vx3u5fZ svn]# mkdir /home/svn/testRepo[root@iZ256vx3u5fZ svn]# svnadmin create /home/svn/testRepo[root@iZ256vx3u5fZ svn]# cd /home/svn/testRepo/[root@iZ256vx3u5fZ testRepo]# ls -a.  ..  conf  db  format  hooks  locks  README.txt如果创建成功,testRepo目录下会多出几个文件夹,进入到conf文件夹会有3个配置文件: (1). svnserve.conf:  svn服务综合配置文件.  (2). passwd:  用户名口令文件。 (3). authz:   权限配置文件####passwd文件[users]# harry = harryssecret# sally = sallyssecretsvnuser=123456                 svnuser为用户名.123456为密码####authz文件添加一行这个[/]svnuser=rw意思是svnuser用户对所有的目录有读写权限,如果需要详细的分组,可以参照这里[http://www.blogjava.net/rockblue1988/archive/2014/11/19/420246.aspx]####svnserve.conf文件#匿名访问者权限anon-access = none#验证用户权限auth-access = write#密码文件地址password-db = /home/svn/testRepo/passwd#权限文件地址authz-db = /home/svn/testRepo/authz#项目名称（UUID）realm =testRepo采用默认配置. 以上语句都必须顶格写, 左侧不能留空格, 否则会出错.###4.打开Linux下的防火墙端口默认是3690端口，你也可以用别的。已开启的跳过这一步修改iptables -I INPUT -p tcp --dport 3690 -j ACCEPT保存/etc/rc.d/init.d/iptables save重启service iptables restart查看/etc/init.d/iptables status###5.启动SVN服务svnserve -d -r /home/svn-d:守护进程-r:svn根目录这里注意启动时的目录一定不要再往下写一级,不然客户端再按照下面的地址访问的时候,会提示错误:XXXXXXX(别怪我,实在记不清了)non existent in revision 0假设服务端IP为182.92.178.156，那么如下设置后testRepo的访问目录就为：svn://182.92.178.156:3690/testRepo如果端口被占用可以重新换一个端口运行,更换端口可以让一台服务器运行多个SVN Server,不要忘记按照第4步在iptable中打开相应的端口svnserve -d -r /home/svn  --listen-port 3391关闭SVN服务ps -aux|grep svn  kill 1755 进程id  启动完成后,客户端就可以成功的连接了###6.遇到的问题1.端口被占用svnserve: 不能绑定服务器套接字: 地址已在使用更换端口,或者关闭正在运行的SVN服务,参见第5步,启动服务2.导入工程$ mkdir MyProject  $ mkdir MyProject/trunk  $ mkdir MyProject/branches  $ mkdir MyProject/tags  svn import MyProject svn://182.92.178.156/testRepo/MyProject -m \"first import project\"  3.导出工程svn co svn://192.168.5.228/testRepo/MyProject  4.客户端查看不到日志修改svnserver.conf文件里面：anon-access = read –&gt;修改为 anon-access = none###7.添加开机启动首先：编写一个启动脚本svn_startup.sh，我放在/root/svn_startup.sh#!/bin/bash/usr/bin/svnserve -d -r /home/svn/这里的svnserve路径保险起见，最好写绝对路径,因为启动的时候，环境变量也许没加载.绝对路径怎么查?which svnserve这里还有可能碰到一个问题，如果你在windows下建立和编写的脚步，拿到linux下，用vi或者vim修改后可能会无法执行，这是文件格式的问题vi svn_startup.sh输入:set ff 回车如果显示的结果不是fileformat=unix再次输入set ff=unix就OK了然后修改该脚本的执行权限chmod ug+x svn_startup.sh或者万能的chmod 777 svn_startup.sh最后：加入自动运行vi /etc/rc.d/rc.local在末尾添加脚本的路径，如：/root/svn_startup.sh现在，你可以重启一下试试了。 不懂得怎么确认成功？败给你了ps -ef|grep svnserve###参考来源http://blog.csdn.net/shangliuyan/article/details/7351675http://www.blogjava.net/rockblue1988/archive/2014/11/19/420246.aspxhttp://www.centoscn.com/CentosServer/ftp/2014/0306/2505.htmlhttp://www.blogjava.net/nkjava/archive/2011/08/29/357502.htmlhttp://bbs.csdn.net/topics/390757995"
  },
  
  {
    "title": "Xcode常用的插件集合",
    "url": "/posts/xcode-plugin-collection/",
    "categories": "Xcode",
    "tags": "",
    "date": "2015-04-01 10:24:50 +0800",
    





    
    "snippet": "本文主要总结了一下,我在Xcode下经常使用的的插件.##1.AlcatrazAlcatraz是一个Xcode的开源的包管理工具.使用它,我们可以查找和安装各种各样的插件,模板以及配色方案.安装Alcatraz很简单,打开Terminal,把下面一行粘贴进命令行即可,安装之前,友情提示:Alcatraz is available for OSX 10.9+ and Xcode 5+ only...",
    "content": "本文主要总结了一下,我在Xcode下经常使用的的插件.##1.AlcatrazAlcatraz是一个Xcode的开源的包管理工具.使用它,我们可以查找和安装各种各样的插件,模板以及配色方案.安装Alcatraz很简单,打开Terminal,把下面一行粘贴进命令行即可,安装之前,友情提示:Alcatraz is available for OSX 10.9+ and Xcode 5+ only.curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/master/Scripts/install.sh | sh删除插件命令rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin清空Alcatraz缓存的命令rm -rf ~/Library/Application\\ Support/Alcatraz安装完成之后 ,最后提示Alcatraz successfully installed!!1!🍻   Please restart your Xcode.重启Xcode,发现在Windows菜单项下会多出一个Pachage Manager的项,快捷键是⇧⌘9##2.VVDocumenterVVDocumenter可以帮我们自动生成注释文档,使用的方式也非常简单.在任何的类,方法或者你需要插入注释的地方输入”///”即可,这里引用一张原作者的gif图片来说明效果:安装方式也很简单,1.Alcatraz ,如果你安装了Alcatraz,直接打开Xcode-&gt;⇧⌘9-&gt;搜索VVDocumenter,Install.2.如果不想安装Alcatraz,把整个项目clone到本地,然后在Xcode中编译(⌘B),重启Xcode,Windows-&gt;会出现一个VVDocumenter项.安装成功.如果还不放心,可以在这查找到插件的存在 ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/GitHub:git@github.com:onevcat/VVDocumenter-Xcode.git##3.RTImageAssets用来生成 @3x 的图片资源对应的 @2x 和 @1x 版本，只要拖拽高清图到 @3x 的位置上，然后按 Ctrl+Shift+A 即可自动生成两张低清的补全空位。当然你也可以从 @2x 的图生成 @3x 版本，如果你对图片质量要求不高的话.附一张使用效果的gifGitHub:git@github.com:rickytan/RTImageAssets.git##4.XAlign自动对齐,效果gif图:安装方式 Terminal,    # install    $ curl http://qfi.sh/XAlign/build/install.sh | sh    or        # update    $ curl http://qfi.sh/XAlign/build/update.sh | sh##5.ClangFormat代码格式化工具##6.Auto Importer for Xcode自动引入头文件##7.KSImageNamed-Xcode图片名称自动补全##8.ZLGotoSandboxPlugin-Xcode快速定位simulator的沙盒路径 https://github.com/MakeZL/ZLGotoSandboxPlugin##9.XcodeColorsDebug的时侯使控制台输出的日志带有色彩,一般配合CocoaLumberjack来使用"
  },
  
  {
    "title": "Octopress学习旅程(1)",
    "url": "/posts/octopress-deeper-learn-1/",
    "categories": "octopress",
    "tags": "",
    "date": "2015-03-27 15:08:02 +0800",
    





    
    "snippet": "##1.rake -T主要用来记录学习Octopress中的一些知识点.先记录一个命令,rake -T 可以查看命令rake的介绍:localhost:octopress douxinchun$ rake -Trake clean                     # Clean out caches: .pygments-cache, .gist-cache, .sass-cache...",
    "content": "##1.rake -T主要用来记录学习Octopress中的一些知识点.先记录一个命令,rake -T 可以查看命令rake的介绍:localhost:octopress douxinchun$ rake -Trake clean                     # Clean out caches: .pygments-cache, .gist-cache, .sass-cacherake copydot[source,dest]      # copy dot files for deploymentrake deploy                    # Default deploy taskrake gen_deploy                # Generate website and deployrake generate                  # Generate jekyll siterake install[theme]            # Initial setup for Octopress: copies the default theme into the path of Jekyll's generatorrake integrate                 # Move all stashed posts back into the posts directory, ready for site generationrake isolate[filename]         # Move all other posts than the one currently being worked on to a temporary stash location (stash) so regenerat...rake list                      # list tasksrake new_page[filename]        # Create a new page in source/(filename)/index.mdrake new_post[title]           # Begin a new post in source/_postsrake preview                   # preview the site in a web browserrake push                      # deploy public directory to github pagesrake rsync                     # Deploy website via rsyncrake set_root_dir[dir]         # Update configurations to support publishing to root or sub directoryrake setup_github_pages[repo]  # Set up _deploy folder and deploy branch for Github Pages deploymentrake update_source[theme]      # Move source to source.old, install source theme updates, replace source/_includes/navigation.html with source....rake update_style[theme]       # Move sass to sass.old, install sass theme updates, replace sass/custom with sass.old/customrake watch                     # Watch the site and regenerate when it changes追加一个介绍的很详细的Octopress使用者的总结,内容很详细,留作备忘http://shengmingzhiqing.com/blog/octopress-tutorials-toc.html/##2.添加返回顶部以下步骤参考这里:http://www.udpwork.com/item/12851.html1)来这里Scroll To Top找一个自己喜欢的样式2)新建一个文件来存放widget代码,文件目录source/_includes/custom/,假设文件名为:scroll_to_top.html&lt;script type=\"text/javascript\" src=\"http://arrow.scrolltotop.com/arrow78.js\"&gt;&lt;/script&gt;&lt;noscript&gt;Not seeing a &lt;a href=\"http://www.scrolltotop.com/\"&gt;Scroll to Top Button&lt;/a&gt;? Go to our FAQ page for more info.&lt;/noscript&gt;这里需要注意默认Octopress引入的jquery.min.js和widget code中使用的jquery的版本可能是不一样的.如果你曾经按照本站中Blog加快Octopress国内访问速度中处理过Octopress的JQuery,那么你可以保留widget中的JQuery的引入,或者在文件source/_includes/head.html中,作如下修改:&lt;!--&lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt;--&gt;  &lt;!--&lt;script src=\"//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;--&gt;  &lt;!--为了添加scroll_to_top.html 提高了js的版本--&gt;  &lt;script src=\"//ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.3.min.js\"&gt;&lt;/script&gt;3)将scroll_to_top.html引入到页面中文件位置source/_layouts/default.html3)去除图片上的灰色背景Octopress默认的为所有的div添加了一个背景，所以上述完成之后看到的图片是有一个灰色背景的，需要去除一下。修改以下文件即可。sass/base/_theme.scssbody {  &gt; div:not(#ds-wrapper):not(#topcontrol) {    background: $sidebar-bg $noise-bg;    border-bottom: 1px solid $page-border-bottom;    &gt; div {      background: $main-bg $noise-bg;      border-right: 1px solid $sidebar-border;    }  }}其中我们添加的div的id为topcontrol。当然前面的ds-wrapper是为了去除多说评论框登陆的背景问题，如不需要可以去掉。大功告成!!!"
  },
  
  {
    "title": "iOS开发过程中遇到的Bug处理集合",
    "url": "/posts/ios-bug-collection/",
    "categories": "iOS开发过程中遇到的坑",
    "tags": "",
    "date": "2015-03-27 15:00:07 +0800",
    





    
    "snippet": "##1.iOS7 下UIScrollView 无法滑动的解决办法环境:Xcode6.2 iOS7 开启了AutoLayout 在Storyboard中拖入的一个UIScrollview接收的别人的code,在这个基础上开发了一个新的界面,然后手贱脑残的想用一下AutoLayout练练手(6和6+都出了,感觉以后使用AutoLayout会是主流),刚开始一切OK,跑起来顺畅的很,在3.5和4的...",
    "content": "##1.iOS7 下UIScrollView 无法滑动的解决办法环境:Xcode6.2 iOS7 开启了AutoLayout 在Storyboard中拖入的一个UIScrollview接收的别人的code,在这个基础上开发了一个新的界面,然后手贱脑残的想用一下AutoLayout练练手(6和6+都出了,感觉以后使用AutoLayout会是主流),刚开始一切OK,跑起来顺畅的很,在3.5和4的屏幕上适应的都不错,后来不知道怎么调整了一下UI,结果悲剧发生了,Scrollview死活滑动不了了,导致Scrollview上的下拉刷新也不好用了.第一反应是AutoLayout的问题,禁用了AutoLayout,Run,一切OK,能滑动了.但是这丫的是Storyboard啊,一个ViewControll禁用课AutoLayout,整个文件都禁用.Google解决方案,结果果然受AutoLayout的影响,然后解决方案都是说要在viewdidAppear中重设contentSize,好吧,把contentSize的设定从viewdidload移到viewdidAppear中,Run,Fail… …Fuck Google上清一水的解决方案都是这个,说好的滑动呢…最后,纠结了1分钟,在viewdidload,viewwillapear,viewdidappear,viewlayoutsubviews中都设置一次contentSize,Run,神奇的事情发生了,Scrollview动起来了,然后一个一个的去除contentSize,最终确定,只有在viewlayoutsubviews设置才会有效,,坑爹啊.具体的code如下:// Called just before the view controller's view's layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.- (void)viewWillLayoutSubviews{    NSLog(@\"viewWillLayoutSubviews\");    scrollview.contentSize = CGSizeMake(CGRectGetWidth(self.view.frame), CGRectGetHeight(self.view.frame)+1);    }坑爹啊,问题虽然解决了,但是这不科学啊,于是重新查看UIViewController的生命周期:2015-03-27 16:17:35.887 BugDemo[3195:937760] viewDidLoad2015-03-27 16:17:35.888 BugDemo[3195:937760] viewWillAppear2015-03-27 16:17:35.891 BugDemo[3195:937760] viewWillLayoutSubviews2015-03-27 16:17:35.892 BugDemo[3195:937760] viewDidLayoutSubviews2015-03-27 16:17:35.900 BugDemo[3195:937760] viewDidAppear发现生命周期的最后一个方法是viewDidAppear,只好理解为涉及了Autolayout,在viewDidAppear中设置已经晚了,可能是由于AutoLayout的某些原因,到了viewDidAppear的时候再设置contentSize属性已经不被scrllview接受或者被AutoLayout的某些机制给拦截了重设为另一个自适应的数值了.最后,总结,AutoLayout真是坑,界面还是乖乖的用code手写吧,这样出了问题好定位分析,解决.##2.UIScrollView不能响应UITouch事件的解决办法原因是：UIView的touch事件被UIScrollView捕获了。解决办法：让UIScrollView将事件传递过去。于是最简单的解决办法就是加一个UIScrollView的category。这样每个用到UIScrollView的地方只要导入这个category就可以直接响应相关的touch事件了。#import \"UIScrollView+UITouch.h\"        @implementation UIScrollView (UITouch)        - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {      [[self nextResponder] touchesBegan:touches withEvent:event];      [super touchesBegan:touches withEvent:event];    }        -(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {      [[self nextResponder] touchesMoved:touches withEvent:event];      [super touchesMoved:touches withEvent:event];    }    - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {      [[self nextResponder] touchesEnded:touches withEvent:event];      [super touchesEnded:touches withEvent:event];    }    @end ##3.UITableview点击背景隐藏键盘由于UITableview是UIScrollview的子类,如果按照2中的方式话,会响应touchbegin方法,但是UITablevieDelegate中的didSelectRowAtIndexPath就会不响应了.解决方法参照:http://stackoverflow.com/questions/2321038/dismiss-keyboard-by-touching-background-of-uitableviewUITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hideKeyboard)];[self.tableView addGestureRecognizer:gestureRecognizer];//The UITapGestureRecognizer solution works with table cell selection if you set://加入这一句,不会影响到tableview的didSelectRowAtIndexPath方法gestureRecognizer.cancelsTouchesInView = NO;然后,添加hideKeyboard方法,想下面这样- (void) hideKeyboard {    [self.view endEditing:YES];    ...    ...}此外,还有一种可以响应touchbegin的方案参见这里 http://www.cnblogs.com/tangbinblog/p/4066930.html ,不过这种方案看上去需要以子类的方式重写hitTest方法,暂时没有考证可行性.先Mark一下,等以后再来看看."
  },
  
  {
    "title": "为 Octopress 添加多说评论系统",
    "url": "/posts/wei-octopress-tian-jia-duo-shuo-ping-lun-xi-tong/",
    "categories": "octopress",
    "tags": "",
    "date": "2015-03-26 14:51:19 +0800",
    





    
    "snippet": "Update:最新消息,多说将于2017年6月1日正式关停服务,还是切换回disqus吧.octopress自带的disqus自定义的选项非常少,由于国内的原因,加载的速度巨慢,对中文的支持非常不好,于是参照其他博主的意见找了一个国内的社会化评论插件多说来替代disqus添加的过程主要是参照了Havee’s Space中的Blog为 Octopress 添加多说评论系统其中有几点需要注意的事...",
    "content": "Update:最新消息,多说将于2017年6月1日正式关停服务,还是切换回disqus吧.octopress自带的disqus自定义的选项非常少,由于国内的原因,加载的速度巨慢,对中文的支持非常不好,于是参照其他博主的意见找了一个国内的社会化评论插件多说来替代disqus添加的过程主要是参照了Havee’s Space中的Blog为 Octopress 添加多说评论系统其中有几点需要注意的事情是:1.duoshuo_short_name 是指在多说控制面板中添加新站点，第三行有多说的二级域名中的你填入的部分.比如说,二级域名是 **http://douxinchun.duoshuo.com 中,那么duoshuo_short_name就是 **douxinchun.2.文件 source/_includes/post/duoshuo.html 中的内容可以参照多说控制台–&gt;工具中提供的通用代码3.文件_includes/custom/asides/recent_comments.html中的内容可以参照多说控制台–&gt;工具中最新评论的code最后完成以后,rake preview,一切OK,但还会有一个小问题,就是当需要登陆或者输入邮箱地址的时候，会出现如下图的问题，登陆框的背后有一层带颜色的层。###原因具体原因是我所使用的css为所有的body div增加了一个背景。下图为id为ds-wrapper的div的背景属性 ds-wrapper div background###解决解决方案参照 技术小黑屋的Blog:集成多说评论，思路就是对所有body div的设置不应用到id为ds-wrapper的div 默认的设置如下。文件为sass/base/_theme.scsssass/base/_theme.scssbody {  &gt; div {    background: $sidebar-bg $noise-bg;    border-bottom: 1px solid $page-border-bottom;    &gt; div {      background: $main-bg $noise-bg;      border-right: 1px solid $sidebar-border;    }  }}使用not把ds-wrapper加入例外，修改为这样的设置  修改后的_theme.scss文件body {  &gt; div:not(#ds-wrapper){    background: $sidebar-bg $noise-bg;    border-bottom: 1px solid $page-border-bottom;    &gt; div {      background: $main-bg $noise-bg;      border-right: 1px solid $sidebar-border;    }  }}到这里，就比较完美的添加完多说的评论了."
  },
  
  {
    "title": "在GitHub上搭建Octopress",
    "url": "/posts/install-octopress/",
    "categories": "octopress",
    "tags": "",
    "date": "2015-02-10 18:38:16 +0800",
    





    
    "snippet": "##前言GitHub果真是一个神奇的地方.以前在使用Baidu空间和CSDN来写博客的时候,就听前辈们说过GitHub可以写博客.经过一番Google后终于弄明白了原理.首先是github中有一个功能叫做Pages,这个功能具体的作用不详,但是其中的一项是能够把你上传的html文件显示为一个网页.其次是有好事者(别的博主都这么称呼)做了一个基于github的管理工具:Octopress.然后...",
    "content": "##前言GitHub果真是一个神奇的地方.以前在使用Baidu空间和CSDN来写博客的时候,就听前辈们说过GitHub可以写博客.经过一番Google后终于弄明白了原理.首先是github中有一个功能叫做Pages,这个功能具体的作用不详,但是其中的一项是能够把你上传的html文件显示为一个网页.其次是有好事者(别的博主都这么称呼)做了一个基于github的管理工具:Octopress.然后,我们就可以使用Octopress这个开源的框架加上Github Pages服务来搭建自己的Blog.到这里可能你会觉得非常兴奋,恨不得立马就要下手开搞.引用一句Octopress官方网站的标题:  OctopressA blogging framework for hackers.所以,如果没有一定的Git命令基础,html知识和Linux命令行知识的话,最好不要轻易的下决定.另外,Octopress框架下的Blog系统,需要使用Markdown语言来写博客,如果之前没有使用过的话,需要简单的学习一下,废话少说,开始介绍我的搭建之旅.搭建Octopress我是在iMac上面成功搭建的Octopress,具体的环境如下:  Mac OS X 10.9.5 (这个版本号下安装Ruby1.9.3p125是非常头疼的)安装Octopress基本上要按照以下几个步骤:\t1. 注册GitHub账号   \t\t2. 安装Ruby1.9.3p125 (后来,在更新机器的过程中发现也可以使用ruby-1.9.3-p551,so,大家在安装的时候,执行 rvm install 1.9.3 就行,不要在意小版本) \t\t3. 安装Octopress      \t\t4. 部署到GitHub上  这里是Octopress的官方安装指南，各位可以按照其中的步骤进行安装.需要注意一点,官方的教程中的第2步:  2.Install Ruby 1.9.3 or greater using either rbenv or RVM.提到可以使用更高版本的Ruby,这一点,我在2.0.0下做过验证,没有成功,强烈建议使用版本1.9.3p125或者1.9.3Octopress的官方指南推荐使用的是RVM和rbenv。我在安装的过程中使用的是RVM,这里同时给出两种方式来安装Ruby1.9.3git呢我们的mac默认安装,GitHub账号注册部分,直接跳过.安装低版本的Ruby1.通过Ruby安装Ruby1.9.3安装Homeview这里我使用Homebrew来安装rbenv，如果你没有Homebrew，打开终端,copy 执行以下命令。(此处注意请随时关注Homebrew的官网首页的安装命令是否更新)```bash Terminal/usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”有了Homebrew就可以安装rbenv了$ brew update$ brew install rbenv$ brew install ruby-build##### 安装Ruby使用rbenv安装1.9.3版本的ruby$ rbenv install 1.9.3$ rbenv local 1.9.3$ rbenv rehash$ ruby –version #ruby 1.9.3p125 (2012-02-16 revision 34643) [x86_64-darwin13.4.0]安装完成后可以用ruby --version进行验证#### 2.通过Rvm安装Ruby1.9.3p125[RVM](http://www.rvm.io/) 全称[Ruby Version Manager](http://www.rvm.io/), 是一个非常好用的ruby版本管理以及安装工具. RVM的安装方法,也可按照官方首页.##### 安装rvm$ \\curl -sSL https://get.rvm.io | bash -s stable$ source ~/.bashrc$ source ~/.bash_profile修改 RVM 的 Ruby 下载源到国内的 淘宝镜像服务器，这样能提高安装速度$ sed -i .bak -E ‘s!https?://cache.ruby-lang.org/pub/ruby!https://ruby.taobao.org/mirrors/ruby!’ $rvm_path/config/db##### Ruby的安装与切换 (RVM管理) * 列出已知的ruby版本 $ rvm list known  * 安装一个ruby版本 $ rvm install 1.9.3  * 使用一个ruby版本 $ rvm use 1.9.3p125 * 如果想设置为默认版本，可以这样 $ rvm use 1.9.3p125 –default * 查询已经安装的ruby $ rvm list  * 卸载一个已安装版本 $ rvm remove 1.9.3p125  ```安装Octopress安装Ruby完成后就按照官方指南安装Octpress## clone octopress$ git clone git://github.com/imathis/octopress.git octopress$ cd octopress## 安装依赖$ gem install bundler$ rbenv rehash$ bundle install此处,至于如果bundle install的时候,出现类似下面的情况:...Gem::RemoteFetcher::FetchError: Errno::ECONNRESET: Connection reset by peer - SSL_connect (https://rubygems.org/gems/compass-core-1.0.3.gem)...此处省略1W字...An error occurred while installing compass-core (1.0.3), and Bundler cannotcontinue.Make sure that `gem install compass-core -v '1.0.3'` succeeds before bundling.则需要使用 Bundler 的 Gem 源代码镜像命令bundle config mirror.https://rubygems.org https://ruby.taobao.org或者是在目录下找到Gemfile文件,替换``` plain Gemfilesource ‘https://rubygems.org/’为source “https://ruby.taobao.org”当然了,如果你有足够的毅力,你也可以按照最后一行的提示,直接在Terminal中打:gem install compass-core -v '1.0.3',然后success后再继续bundle install,然后不断重复这一过程,Believe me,it's not a dead circle.~~在此,感谢一下万能的淘宝,顺便感谢一下GFW!## 安装octopress默认主题  ```bash Terminal $ rake install部署接下来需要把Blog部署到github上去，第一步要做的是去github创建一个username.github.com的repo，比如我的就叫douxinchun.github.com。然后运行以下命令，并依照提示建立github和Octopress的关联$ rake setup_github_pages创建博客生成博客$ rake generate$ rake deploy把修改完的代码上传到github,repo:douxinchun.github.com下的source分支下$ git add .$ git commit -m 'create blog'$ git push origin source完成后等待一段时间后就能访问http://username.github.com看到自己的博客了简单的修改配置配置文件路径为~/octopress/_config.ymlurl:                # For rewriting urls for RSS, etctitle:              # Used in the header and title tagssubtitle:           # A description used in the headerauthor:             # Your name, for RSS, Copyright, Metadatasimple_search:      # Search engine for simple site searchdescription:        # A default meta description for your sitedate_format:        # Format dates using Ruby's date strftime syntaxsubscribe_rss:      # Url for your blog's feed, defauts to /atom.xmlsubscribe_email:    # Url to subscribe by email (service required)category_feeds:     # Enable per category RSS feeds (defaults to false in 2.1)email:              # Email address for the RSS feed if you want it.编辑完成后,执行这个操作部署到GitHub中$ rake generate$ rake deploy将修改保存到GitHub的远程库中$ git add .$ git commit -m \"simple settings\" $ git push origin source支持中文标签目前版本的Octopress会在/source/blog/categories下创建一个index.markdown来作为分类的首页，但这个首页在标签有中文时会出现无法跳转的情况，原因是因为在出现中文标签时Octopress会把文件的路径中的中文转换成拼音，而在Category跳转时是直接写了中文路径，结果自然是404。解决方法是自己实现一个分类首页并处理中文。首先按照这里的方法实现index.html,给Blog添加分类将plugins/category_list_tag.rb中的category_url = File.join(category_dir, category.gsub(/_|\\P{Word}/, '-').gsub(/-{2,}/, '-').downcase)替换成category_url = File.join(category_dir, category.to_url.downcase)这样你的博客就可以支持中文标签的跳转了。写博客经过上面几部后，博客已经成功搭建，现在就可以开始写博文了。####创建博文## 使用终端$ rake new_post['title']生成的文件在~/source/_posts目录下如果使用的是zsh,可能会遇到下面的情况zsh: no matches found: new_post[...]原因是诸如[]之类的不是正确的命令字符。当然，我们也可以使用转义符来解决这一问题。但每次都需要敲入转义符，实在是太麻烦了。解决方案是在~/.zshrc文件下，加入这样一行内容：alias rake=\"noglob rake\"添加在最后一行,即可编辑博文## ...markdown写博文$ rake preview #localhost:4000$ rake generate$ git add .$ git commit -m \"comment\" $ git push origin source$ rake deploy  参考资料  http://octopress.org/     Octopress作者站点  http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/      唐巧的Blog中搭建Octopress的部分其他的博主搭建Octopress的Blog:  http://msching.github.io/blog/2014/04/11/starting/      基于Github和Octopress搭建属于自己的博客 - 码农人生  http://biaobiaoqi.me/blog/2013/03/21/building-octopress-in-github-mac/       安装Octopress的记录 - Peter潘 - 博客园安装ruby1.9.3-p125时google的一些站点,如果你在安装Ruby 1.9.3的时候遇到问题,不妨浏览一下下面的网址,看能不能找到解决方案:  http://stackoverflow.com/questions/26208230/rvm-install-1-9-3-on-os-x-10-9-5-failing?answertab=active#tab-top  https://github.com/wayneeseguin/rvm/issues/1975  http://stackoverflow.com/questions/24502284/error-installing-ruby-1-9-3-p547-with-rvm-on-osx-10-9-3  https://www.ruby-lang.org/zh_tw/downloads/#third-party-tools  https://github.com/wayneeseguin/rvm/issues/2837  http://stackoverflow.com/questions/15587298/cant-install-ruby-1-9-3-via-rvm-in-os-x-lion-even-with-with-gcc-clang  http://stackoverflow.com/questions/21068346/issue-with-rubygems-rb-when-installing-rails  http://stackoverflow.com/questions/14592945/cannot-compile-ruby-1-9-3  http://stackoverflow.com/questions/15643486/cant-install-ruby-2-0-0-p0-with-rvm-error-running-make-j8/15655034#15655034  http://stackoverflow.com/questions/14072524/error-installing-ruby-with-rvm-osx-10-8  https://ruby-china.org/wiki/install_ruby_guide  http://blog.fengqijun.me/blog/2013/08/29/move-from-rvm-to-rbenv/  http://about.ac/2012/04/install-ruby-with-rbenv.html  https://ruby-china.org/wiki/rvm-guide"
  }
  
]

